{
"scope": "source.swift",
"completions":
 [ 
{ "trigger": "lineRangeForRange \t func String -> Range Index " , "contents": "lineRangeForRange(${1:Range<Index>})" },{ "trigger": "pause \t func NSProgress -> void" , "contents": "pause(${1:})" },{ "trigger": "copyWithZone \t func NSRegularExpression -> AnyObject" , "contents": "copyWithZone(${1:NSZone})" },{ "trigger": "removeSuiteNamed \t func NSUserDefaults -> void" , "contents": "removeSuiteNamed(${1:String})" },{ "trigger": "removeAttribute \t func NSMutableAttributedString -> void" , "contents": "removeAttribute(${1:String}, range:${2:NSRange})" },{ "trigger": "sharedSupportURL \t NSURL", "contents": "sharedSupportURL" },{ "trigger": "tX \t CGFloat", "contents": "tX" },{ "trigger": "streamStatus \t NSStreamStatus", "contents": "streamStatus" },{ "trigger": "member \t func NSSet -> AnyObject?" , "contents": "member(${1:AnyObject})" },{ "trigger": "encodeWithCoder \t func NSURLQueryItem -> void" , "contents": "encodeWithCoder(${1:NSCoder})" },{ "trigger": "copyWithZone \t func NSUUID -> AnyObject" , "contents": "copyWithZone(${1:NSZone})" },{ "trigger": "XPath \t String", "contents": "XPath" },{ "trigger": "encodeWithCoder \t func NSIndexSet -> void" , "contents": "encodeWithCoder(${1:NSCoder})" },{ "trigger": "dateByAddingUnit \t func NSCalendar -> NSDate?" , "contents": "dateByAddingUnit(${1:NSCalendarUnit}, value:${2:Int}, toDate:${3:NSDate}, options:${4:NSCalendarOptions})" },{ "trigger": "NSOrderedSet \t :" , "contents": "NSOrderedSet(${1:})" },{ "trigger": "intersectsIndexesInRange \t func NSIndexSet -> Bool" , "contents": "intersectsIndexesInRange(${1:NSRange})" },{ "trigger": "mainDocumentURL \t NSURL", "contents": "mainDocumentURL" },{ "trigger": "NSLocaleQuotationBeginDelimiterKey \t String", "contents": "NSLocaleQuotationBeginDelimiterKey" },{ "trigger": "NSIntegralRectWithOptions \t func unknown -> NSRect" , "contents": "NSIntegralRectWithOptions(${1:NSRect}, _:${2:NSAlignmentOptions})" },{ "trigger": "NSCalendarIdentifierPersian \t String", "contents": "NSCalendarIdentifierPersian" },{ "trigger": "NSLocaleCurrencySymbol \t String", "contents": "NSLocaleCurrencySymbol" },{ "trigger": "fastestEncoding \t UInt", "contents": "fastestEncoding" },{ "trigger": "componentsSeparatedByString \t func NSString -> [String]" , "contents": "componentsSeparatedByString(${1:String})" },{ "trigger": "commonPrefixWithString \t func NSString -> String" , "contents": "commonPrefixWithString(${1:String}, options:${2:NSStringCompareOptions})" },{ "trigger": "shouldUseExtendedBackgroundIdleMode \t Bool", "contents": "shouldUseExtendedBackgroundIdleMode" },{ "trigger": "NSXMLNodeNeverEscapeContents \t Int", "contents": "NSXMLNodeNeverEscapeContents" },{ "trigger": "serverTrust \t SecTrust", "contents": "serverTrust" },{ "trigger": "unknown \t location: length:" , "contents": "unknown(${1:Int}, length:${2:Int})" },{ "trigger": "URLForResource \t func NSBundle -> NSURL?" , "contents": "URLForResource(${1:String?}, withExtension:${2:String?}, subdirectory:${3:String?})" },{ "trigger": "pathForResource \t func NSBundle -> String?" , "contents": "pathForResource(${1:String?}, ofType:${2:String?}, inDirectory:${3:String?})" },{ "trigger": "replaceItemAtURL \t func NSFileManager -> NSURL" , "contents": "replaceItemAtURL(${1:NSURL}, withItemAtURL:${2:NSURL}, backupItemName:${3:String?}, options:${4:NSFileManagerItemReplacementOptions})" },{ "trigger": "stringFromJoules \t func NSEnergyFormatter -> String" , "contents": "stringFromJoules(${1:Double})" },{ "trigger": "pattern \t String", "contents": "pattern" },{ "trigger": "ready \t Bool", "contents": "ready" },{ "trigger": "NSDecimalNumberHandler.defaultDecimalNumberHandler \t class NSDecimalNumberHandler -> NSDecimalNumberHandler{" , "contents": "NSDecimalNumberHandler.defaultDecimalNumberHandler(${1:})" },{ "trigger": "receivePort \t NSPort", "contents": "receivePort" },{ "trigger": "failureResponse \t NSURLResponse", "contents": "failureResponse" },{ "trigger": "NSDecimalNumberHandler \t coder:" , "contents": "NSDecimalNumberHandler(coder:${1:NSCoder})" },{ "trigger": "NSDateIntervalFormatter \t coder:" , "contents": "NSDateIntervalFormatter(${1:NSCoder})" },{ "trigger": "pathsForResourcesOfType \t func NSBundle -> [String]" , "contents": "pathsForResourcesOfType(${1:String?}, inDirectory:${2:String?})" },{ "trigger": "negativeSuffix \t String", "contents": "negativeSuffix" },{ "trigger": "NSRecoveryAttempterErrorKey \t String", "contents": "NSRecoveryAttempterErrorKey" },{ "trigger": "NSZeroSize \t NSSize", "contents": "NSZeroSize" },{ "trigger": "NSNotification \t NSNotification", "contents": "NSNotification" },{ "trigger": "write \t func NSOutputStream -> Int" , "contents": "write(${1:UnsafePointer<UInt8>}, maxLength:${2:Int})" },{ "trigger": "isEqualToDate \t func NSDate -> Bool" , "contents": "isEqualToDate(${1:NSDate})" },{ "trigger": "NSDataWritingOptions \t rawValue:" , "contents": "NSDataWritingOptions(${1:UInt})" },{ "trigger": "components \t func NSCalendar -> NSDateComponents?" , "contents": "components(${1:NSCalendarUnit}, fromDate:${2:NSDate})" },{ "trigger": "NSURLErrorCancelledReasonInsufficientSystemResources \t Int", "contents": "NSURLErrorCancelledReasonInsufficientSystemResources" },{ "trigger": "NSURLProtectionSpace \t proxyHost: port: type: realm: authenticationMethod:" , "contents": "NSURLProtectionSpace(proxyHost:${1:String}, port:${2:Int}, type:${3:String?}, realm:${4:String?}, authenticationMethod:${5:String?})" },{ "trigger": "NSURLResponse \t coder:" , "contents": "NSURLResponse(coder:${1:NSCoder})" },{ "trigger": "hash \t Int", "contents": "hash" },{ "trigger": "NSAlignmentOptions \t NSAlignmentOptions", "contents": "NSAlignmentOptions" },{ "trigger": "Float \t _:" , "contents": "Float(_:${1:NSNumber})" },{ "trigger": "NSURLRequest \t coder:" , "contents": "NSURLRequest(coder:${1:NSCoder})" },{ "trigger": "NSURLSessionConfiguration \t :" , "contents": "NSURLSessionConfiguration(${1:})" },{ "trigger": "canonicalXMLStringPreservingComments \t func NSXMLNode -> String" , "contents": "canonicalXMLStringPreservingComments(${1:Bool})" },{ "trigger": "NSXMLParser \t contentsOfURL:" , "contents": "NSXMLParser(contentsOfURL:${1:NSURL})" },{ "trigger": "NSFileHandle \t fileDescriptor: closeOnDealloc:" , "contents": "NSFileHandle(fileDescriptor:${1:Int32}, closeOnDealloc:${2:Bool})" },{ "trigger": "NSPredicate \t fromMetadataQueryString:" , "contents": "NSPredicate(fromMetadataQueryString:${1:String})" },{ "trigger": "objectForKey \t func NSUserDefaults -> AnyObject?" , "contents": "objectForKey(${1:String})" },{ "trigger": "cancellable \t Bool", "contents": "cancellable" },{ "trigger": "NSURLProtocol.canInitWithRequest \t class NSURLProtocol -> Bool" , "contents": "NSURLProtocol.canInitWithRequest(${1:NSURLRequest})" },{ "trigger": "notationDeclarationForName \t func NSXMLDTD -> NSXMLDTDNode?" , "contents": "notationDeclarationForName(${1:String})" },{ "trigger": "NSURLCredential \t coder:" , "contents": "NSURLCredential(coder:${1:NSCoder})" },{ "trigger": "NSLocale.localeIdentifierFromComponents \t class NSLocale -> String" , "contents": "NSLocale.localeIdentifierFromComponents(${1:[String })" },{ "trigger": "NSBinarySearchingOptions \t NSBinarySearchingOptions", "contents": "NSBinarySearchingOptions" },{ "trigger": "uploadTaskWithRequest \t func NSURLSession -> Void" , "contents": "uploadTaskWithRequest(${1:NSURLRequest}, fromData:${2:NSData?}, completionHandler:${3:NSData?}, NSURLResponse?:${4:}, NSError?:${5:})" },{ "trigger": "NSStringCompareOptions \t rawValue:" , "contents": "NSStringCompareOptions(${1:UInt})" },{ "trigger": "pathForResource \t func NSBundle -> String?" , "contents": "pathForResource(${1:String?}, ofType:${2:String?})" },{ "trigger": "NSMutableString \t extendedGraphemeClusterLiteral:" , "contents": "NSMutableString(extendedGraphemeClusterLiteral:${1:StaticString})" },{ "trigger": "NSURLErrorCancelledReasonUserForceQuitApplication \t Int", "contents": "NSURLErrorCancelledReasonUserForceQuitApplication" },{ "trigger": "version \t Int", "contents": "version" },{ "trigger": "NSNotification \t :" , "contents": "NSNotification(${1:})" },{ "trigger": "main \t func NSOperation -> void" , "contents": "main(${1:})" },{ "trigger": "elementDeclarationForName \t func NSXMLDTD -> NSXMLDTDNode?" , "contents": "elementDeclarationForName(${1:String})" },{ "trigger": "NSRectEdge \t NSRectEdge", "contents": "NSRectEdge" },{ "trigger": "stringByDeletingLastPathComponent \t :", "contents": "stringByDeletingLastPathComponent" },{ "trigger": "allowsFloats \t Bool", "contents": "allowsFloats" },{ "trigger": "Generator \t dictionary:" , "contents": "Generator(${1:[NSObject })" },{ "trigger": "fileDescriptor \t Int", "contents": "fileDescriptor" },{ "trigger": "lastPathComponent \t :", "contents": "lastPathComponent" },{ "trigger": "countStyle \t NSByteCountFormatterCountStyle", "contents": "countStyle" },{ "trigger": "stringByStandardizingPath \t String", "contents": "stringByStandardizingPath" },{ "trigger": "NSCountedSet \t NSCountedSet", "contents": "NSCountedSet" },{ "trigger": "copyWithZone \t func NSScanner -> AnyObject" , "contents": "copyWithZone(${1:NSZone})" },{ "trigger": " \t func unknown -> Bool" , "contents": "(${1:CGFloat}, rhs:${2:CGFloat})" },{ "trigger": "paddingPosition \t NSNumberFormatterPadPosition", "contents": "paddingPosition" },{ "trigger": "NSExpression.supportsSecureCoding \t static NSExpression -> Bool" , "contents": "NSExpression.supportsSecureCoding(${1:})" },{ "trigger": "attributesAtIndex \t func NSAttributedString -> [String" , "contents": "attributesAtIndex(${1:Int}, effectiveRange:${2:NSRangePointer})" },{ "trigger": "NSURLErrorCannotOpenFile \t Int", "contents": "NSURLErrorCannotOpenFile" },{ "trigger": "removeAllObjects \t func NSMutableArray -> void" , "contents": "removeAllObjects(${1:})" },{ "trigger": "Dictionary._conditionallyBridgeFromObject \t static Dictionary -> Bool" , "contents": "Dictionary._conditionallyBridgeFromObject(${1:NSDictionary}, inout:${2:Dictionary?})" },{ "trigger": "patchVersion \t Int", "contents": "patchVersion" },{ "trigger": "sortUsingDescriptors \t func NSMutableArray -> void" , "contents": "sortUsingDescriptors(${1:[NSSortDescriptor]})" },{ "trigger": "NSStream.getBoundStreamsWithBufferSize \t class NSStream -> void" , "contents": "NSStream.getBoundStreamsWithBufferSize(${1:Int}, inputStream:${2:AutoreleasingUnsafeMutablePointer<NSInputStream?>}, outputStream:${3:AutoreleasingUnsafeMutablePointer<NSOutputStream?>})" },{ "trigger": "isCoderError \t Bool", "contents": "isCoderError" },{ "trigger": "Bool._conditionallyBridgeFromObject \t static Bool -> Bool" , "contents": "Bool._conditionallyBridgeFromObject(${1:NSNumber}, inout:${2:Bool?})" },{ "trigger": "NSURLSession \t NSURLSession", "contents": "NSURLSession" },{ "trigger": "timeStyle \t NSDateFormatterStyle", "contents": "timeStyle" },{ "trigger": "NSCocoaErrorDomain \t String", "contents": "NSCocoaErrorDomain" },{ "trigger": "NSNumber \t coder:" , "contents": "NSNumber(coder:${1:NSCoder})" },{ "trigger": "uploadTaskWithRequest \t func NSURLSession -> NSURLSessionUploadTask" , "contents": "uploadTaskWithRequest(${1:NSURLRequest}, fromFile:${2:NSURL})" },{ "trigger": "NSXMLNode.elementWithName \t class NSXMLNode -> AnyObject" , "contents": "NSXMLNode.elementWithName(${1:String})" },{ "trigger": "stringFromValue \t func NSEnergyFormatter -> String" , "contents": "stringFromValue(${1:Double}, unit:${2:NSEnergyFormatterUnit})" },{ "trigger": "componentsInTimeZone \t func NSCalendar -> NSDateComponents?" , "contents": "componentsInTimeZone(${1:NSTimeZone}, fromDate:${2:NSDate})" },{ "trigger": "NSExpression.expressionForEvaluatedObject \t class NSExpression -> NSExpression" , "contents": "NSExpression.expressionForEvaluatedObject(${1:})" },{ "trigger": "givenName \t String", "contents": "givenName" },{ "trigger": "NSEqualSizes \t func unknown -> Bool" , "contents": "NSEqualSizes(${1:NSSize}, _:${2:NSSize})" },{ "trigger": "NSMutableArray \t contentsOfFile:" , "contents": "NSMutableArray(contentsOfFile:${1:String})" },{ "trigger": "NSAffineTransform \t NSAffineTransform", "contents": "NSAffineTransform" },{ "trigger": "URLForResource \t func NSBundle -> NSURL?" , "contents": "URLForResource(${1:String?}, withExtension:${2:String?}, subdirectory:${3:String?}, localization:${4:String?})" },{ "trigger": "NSRegistrationDomain \t String", "contents": "NSRegistrationDomain" },{ "trigger": "NSXMLNodePromoteSignificantWhitespace \t Int", "contents": "NSXMLNodePromoteSignificantWhitespace" },{ "trigger": "keyPath \t String", "contents": "keyPath" },{ "trigger": "NSDate \t NSDate", "contents": "NSDate" },{ "trigger": "NSFileHandle \t forUpdatingAtPath:" , "contents": "NSFileHandle(forUpdatingAtPath:${1:String})" },{ "trigger": "NSCharacterSet \t range:" , "contents": "NSCharacterSet(range:${1:NSRange})" },{ "trigger": "longValue \t Int", "contents": "longValue" },{ "trigger": "addObjectsFromArray \t func NSMutableSet -> void" , "contents": "addObjectsFromArray(${1:[AnyObject]})" },{ "trigger": "copyWithZone \t func NSError -> AnyObject" , "contents": "copyWithZone(${1:NSZone})" },{ "trigger": "AMSymbol \t String", "contents": "AMSymbol" },{ "trigger": "mountedVolumeURLsIncludingResourceValuesForKeys \t func NSFileManager -> [NSURL]?" , "contents": "mountedVolumeURLsIncludingResourceValuesForKeys(${1:[String]?}, options:${2:NSVolumeEnumerationOptions})" },{ "trigger": "NSTimeZone.knownTimeZoneNames \t class NSTimeZone -> [String]" , "contents": "NSTimeZone.knownTimeZoneNames(${1:})" },{ "trigger": "NSURLCache.sharedURLCache \t class NSURLCache -> NSURLCache" , "contents": "NSURLCache.sharedURLCache(${1:})" },{ "trigger": "NSHTTPURLResponse \t URL: statusCode: HTTPVersion: headerFields:" , "contents": "NSHTTPURLResponse(URL:${1:NSURL}, statusCode:${2:Int}, HTTPVersion:${3:String?}, headerFields:${4:[String })" },{ "trigger": "unionOrderedSet \t func NSMutableOrderedSet -> void" , "contents": "unionOrderedSet(${1:NSOrderedSet})" },{ "trigger": "bytes \t UnsafePointer", "contents": "bytes" },{ "trigger": "editingStringForObjectValue \t func NSFormatter -> String?" , "contents": "editingStringForObjectValue(${1:AnyObject})" },{ "trigger": "NSSocketPort \t TCPPort:" , "contents": "NSSocketPort(TCPPort:${1:UInt16})" },{ "trigger": "URLsForResourcesWithExtension \t func NSBundle -> [NSURL]?" , "contents": "URLsForResourcesWithExtension(${1:String?}, subdirectory:${2:String?}, localization:${3:String?})" },{ "trigger": "NSCalendarIdentifierHebrew \t String", "contents": "NSCalendarIdentifierHebrew" },{ "trigger": "NSDivideRect \t func unknown -> void" , "contents": "NSDivideRect(${1:NSRect}, _:${2:UnsafeMutablePointer<NSRect>}, _:${3:UnsafeMutablePointer<NSRect>}, _:${4:CGFloat}, _:${5:NSRectEdge})" },{ "trigger": "getBytes \t func NSData -> void" , "contents": "getBytes(${1:UnsafeMutablePointer<Void>}, range:${2:NSRange})" },{ "trigger": "stringFromDateComponents \t func NSDateComponentsFormatter -> String?" , "contents": "stringFromDateComponents(${1:NSDateComponents})" },{ "trigger": "encodeBytes \t func NSCoder -> void" , "contents": "encodeBytes(${1:UnsafePointer<Void>}, length:${2:Int})" },{ "trigger": "addObjects \t func NSMutableOrderedSet -> void" , "contents": "addObjects(${1:UnsafePointer<AnyObject?>}, count:${2:Int})" },{ "trigger": "NSURLErrorAppTransportSecurityRequiresSecureConnection \t Int", "contents": "NSURLErrorAppTransportSecurityRequiresSecureConnection" },{ "trigger": "NSComparisonPredicate \t coder:" , "contents": "NSComparisonPredicate(${1:NSCoder})" },{ "trigger": "NSURL \t fileURLWithFileSystemRepresentation: isDirectory: relativeToURL:" , "contents": "NSURL(fileURLWithFileSystemRepresentation:${1:UnsafePointer<Int8>}, isDirectory:${2:Bool}, relativeToURL:${3:NSURL?})" },{ "trigger": "NSURLErrorDNSLookupFailed \t Int", "contents": "NSURLErrorDNSLookupFailed" },{ "trigger": "NSURLProtectionSpaceFTP \t String", "contents": "NSURLProtectionSpaceFTP" },{ "trigger": "prefix \t String", "contents": "prefix" },{ "trigger": "NSURLErrorBackgroundSessionRequiresSharedContainer \t Int", "contents": "NSURLErrorBackgroundSessionRequiresSharedContainer" },{ "trigger": "writeToURL \t func NSData -> Bool" , "contents": "writeToURL(${1:NSURL}, atomically:${2:Bool})" },{ "trigger": "rangeOfComposedCharacterSequenceAtIndex \t func NSString -> NSRange" , "contents": "rangeOfComposedCharacterSequenceAtIndex(${1:Int})" },{ "trigger": "NSURLProtocol.setProperty \t class NSURLProtocol -> void" , "contents": "NSURLProtocol.setProperty(${1:AnyObject}, forKey:${2:String}, inRequest:${3:NSMutableURLRequest})" },{ "trigger": "NSCharacterSet.illegalCharacterSet \t class NSCharacterSet -> NSCharacterSet" , "contents": "NSCharacterSet.illegalCharacterSet(${1:})" },{ "trigger": "decodeTopLevelObjectOfClassDecodedObjectType \t func NSCoder -> DecodedObjectType?" , "contents": "decodeTopLevelObjectOfClassDecodedObjectType(${1:DecodedObjectType.Type}, forKey:${2:String})" },{ "trigger": "base64EncodedDataWithOptions \t func NSData -> NSData" , "contents": "base64EncodedDataWithOptions(${1:NSDataBase64EncodingOptions})" },{ "trigger": "NSOrderedSet \t objects:" , "contents": "NSOrderedSet(objects:${1:AnyObject...})" },{ "trigger": "isDateInTomorrow \t func NSCalendar -> Bool" , "contents": "isDateInTomorrow(${1:NSDate})" },{ "trigger": "NSOutputStream \t toMemory:" , "contents": "NSOutputStream(${1:})" },{ "trigger": "format \t String", "contents": "format" },{ "trigger": "NSURLErrorSecureConnectionFailed \t Int", "contents": "NSURLErrorSecureConnectionFailed" },{ "trigger": "NSComparisonPredicate \t NSComparisonPredicate", "contents": "NSComparisonPredicate" },{ "trigger": "NSFileTypeBlockSpecial \t String", "contents": "NSFileTypeBlockSpecial" },{ "trigger": "DTDKind \t NSXMLDTDNodeKind", "contents": "DTDKind" },{ "trigger": "removeAttributeForName \t func NSXMLElement -> void" , "contents": "removeAttributeForName(${1:String})" },{ "trigger": "NSMutableOrderedSet \t arrayLiteral:" , "contents": "NSMutableOrderedSet(arrayLiteral:${1:AnyObject...})" },{ "trigger": "operatingSystemVersionString \t String", "contents": "operatingSystemVersionString" },{ "trigger": "formUnionWithCharacterSet \t func NSMutableCharacterSet -> void" , "contents": "formUnionWithCharacterSet(${1:NSCharacterSet})" },{ "trigger": "NSNumberFormatterStyle \t NSNumberFormatterStyle", "contents": "NSNumberFormatterStyle" },{ "trigger": "fractionCompleted \t Double", "contents": "fractionCompleted" },{ "trigger": "NSTextCheckingType \t NSTextCheckingType", "contents": "NSTextCheckingType" },{ "trigger": "groupingSize \t Int", "contents": "groupingSize" },{ "trigger": "maximumLengthOfBytesUsingEncoding \t func NSString -> Int" , "contents": "maximumLengthOfBytesUsingEncoding(${1:UInt})" },{ "trigger": "prependTransform \t func NSAffineTransform -> void" , "contents": "prependTransform(${1:NSAffineTransform})" },{ "trigger": "NSOperationQueue \t :" , "contents": "NSOperationQueue(${1:})" },{ "trigger": "allKeysForObject \t func Generator -> [AnyObject]" , "contents": "allKeysForObject(${1:AnyObject})" },{ "trigger": "decodeInt32ForKey \t func NSCoder -> Int32" , "contents": "decodeInt32ForKey(${1:String})" },{ "trigger": "dateBySettingHour \t func NSCalendar -> NSDate?" , "contents": "dateBySettingHour(${1:Int}, minute:${2:Int}, second:${3:Int}, ofDate:${4:NSDate}, options:${5:NSCalendarOptions})" },{ "trigger": "objectsForKeys \t func Generator -> [AnyObject]" , "contents": "objectsForKeys(${1:[NSObject]}, notFoundMarker:${2:AnyObject})" },{ "trigger": "bottom \t CGFloat", "contents": "bottom" },{ "trigger": "expiresDate \t NSDate", "contents": "expiresDate" },{ "trigger": "NSFileHandle.fileHandleWithStandardError \t class NSFileHandle -> NSFileHandle" , "contents": "NSFileHandle.fileHandleWithStandardError(${1:})" },{ "trigger": "rotateByRadians \t func NSAffineTransform -> void" , "contents": "rotateByRadians(${1:CGFloat})" },{ "trigger": "encodeByrefObject \t func NSCoder -> void" , "contents": "encodeByrefObject(${1:AnyObject?})" },{ "trigger": "mutableCopyWithZone \t func NSIndexSet -> AnyObject" , "contents": "mutableCopyWithZone(${1:NSZone})" },{ "trigger": "negativeFormat \t String", "contents": "negativeFormat" },{ "trigger": "NSMutableString \t unicodeScalarLiteral:" , "contents": "NSMutableString(unicodeScalarLiteral:${1:StaticString})" },{ "trigger": "NSMaxX \t func unknown -> CGFloat" , "contents": "NSMaxX(${1:NSRect})" },{ "trigger": "indexesOfObjectsPassingTest \t func NSOrderedSet -> Bool" , "contents": "indexesOfObjectsPassingTest(${1:AnyObject}, Int:${2:}, UnsafeMutablePointer<ObjCBool>:${3:})" },{ "trigger": "fileSystemRepresentation \t :", "contents": "fileSystemRepresentation" },{ "trigger": "encodeWithCoder \t func NSCalendar -> void" , "contents": "encodeWithCoder(${1:NSCoder})" },{ "trigger": "delegateQueue \t NSOperationQueue", "contents": "delegateQueue" },{ "trigger": "NSXMLNode.elementWithName \t class NSXMLNode -> AnyObject" , "contents": "NSXMLNode.elementWithName(${1:String}, URI:${2:String})" },{ "trigger": "relativeString \t String", "contents": "relativeString" },{ "trigger": "NSURLErrorClientCertificateRejected \t Int", "contents": "NSURLErrorClientCertificateRejected" },{ "trigger": "NSValue \t NSValue", "contents": "NSValue" },{ "trigger": "NSDate.supportsSecureCoding \t static NSDate -> Bool" , "contents": "NSDate.supportsSecureCoding(${1:})" },{ "trigger": "addAttribute \t func NSXMLElement -> void" , "contents": "addAttribute(${1:NSXMLNode})" },{ "trigger": "NSLocaleLanguageDirection \t NSLocaleLanguageDirection", "contents": "NSLocaleLanguageDirection" },{ "trigger": "insertChildren \t func NSXMLElement -> void" , "contents": "insertChildren(${1:[NSXMLNode]}, atIndex:${2:Int})" },{ "trigger": "decimalNumberByRaisingToPower \t func NSDecimalNumber -> NSDecimalNumber" , "contents": "decimalNumberByRaisingToPower(${1:Int}, withBehavior:${2:NSDecimalNumberBehaviors?})" },{ "trigger": "removeAllObjects \t func NSMutableDictionary -> void" , "contents": "removeAllObjects(${1:})" },{ "trigger": "localizedStandardRangeOfString \t func NSString -> NSRange" , "contents": "localizedStandardRangeOfString(${1:String})" },{ "trigger": "postNotificationName \t func NSNotificationCenter -> void" , "contents": "postNotificationName(${1:String}, object:${2:AnyObject?}, userInfo:${3:[NSObject })" },{ "trigger": "objectValue \t AnyObject", "contents": "objectValue" },{ "trigger": "getRelationship \t func NSFileManager -> void" , "contents": "getRelationship(${1:UnsafeMutablePointer<NSURLRelationship>}, ofDirectoryAtURL:${2:NSURL}, toItemAtURL:${3:NSURL})" },{ "trigger": "identifier \t String", "contents": "identifier" },{ "trigger": "classForClassName \t func NSKeyedUnarchiver -> AnyClass?" , "contents": "classForClassName(${1:String})" },{ "trigger": "resultType \t NSTextCheckingType", "contents": "resultType" },{ "trigger": "parameterString \t String", "contents": "parameterString" },{ "trigger": "arrayForKey \t func NSUserDefaults -> [AnyObject]?" , "contents": "arrayForKey(${1:String})" },{ "trigger": "NSNumber \t integer:" , "contents": "NSNumber(integer:${1:Int})" },{ "trigger": "NSURLProtectionSpace \t coder:" , "contents": "NSURLProtectionSpace(coder:${1:NSCoder})" },{ "trigger": "NSFormattingUnitStyle \t NSFormattingUnitStyle", "contents": "NSFormattingUnitStyle" },{ "trigger": "NSRunLoop.mainRunLoop \t class NSRunLoop -> NSRunLoop" , "contents": "NSRunLoop.mainRunLoop(${1:})" },{ "trigger": "CGSize \t :" , "contents": "CGSize(${1:})" },{ "trigger": "NSMutableOrderedSet \t coder:" , "contents": "NSMutableOrderedSet(coder:${1:NSCoder})" },{ "trigger": "componentsJoinedByString \t func Generator -> String" , "contents": "componentsJoinedByString(${1:String})" },{ "trigger": "setURL \t func NSUserDefaults -> void" , "contents": "setURL(${1:NSURL?}, forKey:${2:String})" },{ "trigger": "decodeObject \t func NSCoder -> AnyObject?" , "contents": "decodeObject(${1:})" },{ "trigger": "removeChildAtIndex \t func NSXMLDTD -> void" , "contents": "removeChildAtIndex(${1:Int})" },{ "trigger": "second \t Int", "contents": "second" },{ "trigger": "becomeCurrentWithPendingUnitCount \t func NSProgress -> void" , "contents": "becomeCurrentWithPendingUnitCount(${1:Int64})" },{ "trigger": "* \t func unknown -> CGFloat" , "contents": "*(${1:CGFloat}, rhs:${2:CGFloat})" },{ "trigger": "NSBundle \t path:" , "contents": "NSBundle(${1:String})" },{ "trigger": "start \t func NSOperation -> void" , "contents": "start(${1:})" },{ "trigger": "configuration \t NSURLSessionConfiguration", "contents": "configuration" },{ "trigger": "nextWeekendAfter \t func NSCalendar -> NSDateInterval?" , "contents": "nextWeekendAfter(${1:NSDate}, options:${2:NSCalendarOptions})" },{ "trigger": "encodeWithCoder \t func NSOrderedSet -> void" , "contents": "encodeWithCoder(${1:NSCoder})" },{ "trigger": "synchronizeFile \t func NSFileHandle -> void" , "contents": "synchronizeFile(${1:})" },{ "trigger": "resolvePrefixForNamespaceURI \t func NSXMLElement -> String?" , "contents": "resolvePrefixForNamespaceURI(${1:String})" },{ "trigger": "copyWithZone \t func NSTextCheckingResult -> AnyObject" , "contents": "copyWithZone(${1:NSZone})" },{ "trigger": "Generator \t objects: forKeys:" , "contents": "Generator(${1:[AnyObject]}, forKeys:${2:[NSObject]})" },{ "trigger": "attributeDeclarationForName \t func NSXMLDTD -> NSXMLDTDNode?" , "contents": "attributeDeclarationForName(${1:String}, elementName:${2:String})" },{ "trigger": "NSAlignmentOptions \t rawValue:" , "contents": "NSAlignmentOptions(${1:UInt64})" },{ "trigger": "NSExpression \t coder:" , "contents": "NSExpression(coder:${1:NSCoder})" },{ "trigger": "subarrayWithRange \t func Generator -> [AnyObject]" , "contents": "subarrayWithRange(${1:NSRange})" },{ "trigger": "NSLocaleCollatorIdentifier \t String", "contents": "NSLocaleCollatorIdentifier" },{ "trigger": "NSZone \t NSZone", "contents": "NSZone" },{ "trigger": "NSPointFromCGPoint \t func unknown -> NSPoint" , "contents": "NSPointFromCGPoint(${1:CGPoint})" },{ "trigger": "exchangeObjectAtIndex \t func NSMutableOrderedSet -> void" , "contents": "exchangeObjectAtIndex(${1:Int}, withObjectAtIndex:${2:Int})" },{ "trigger": "sortRange \t func NSMutableOrderedSet -> void" , "contents": "sortRange(${1:NSRange}, options:${2:NSSortOptions}, usingComparator:${3:NSComparator})" },{ "trigger": "hasThousandSeparators \t Bool", "contents": "hasThousandSeparators" },{ "trigger": "streamError \t NSError", "contents": "streamError" },{ "trigger": "waitUntilExit \t func NSTask -> void" , "contents": "waitUntilExit(${1:})" },{ "trigger": "NSJSONSerialization.JSONObjectWithStream \t class NSJSONSerialization -> AnyObject" , "contents": "NSJSONSerialization.JSONObjectWithStream(${1:NSInputStream}, options:${2:NSJSONReadingOptions})" },{ "trigger": "addObject \t func NSMutableOrderedSet -> void" , "contents": "addObject(${1:AnyObject})" },{ "trigger": "scanHexFloat \t func NSScanner -> Bool" , "contents": "scanHexFloat(${1:UnsafeMutablePointer<Float>})" },{ "trigger": "start \t func NSThread -> void" , "contents": "start(${1:})" },{ "trigger": "NSURLProtectionSpaceSOCKSProxy \t String", "contents": "NSURLProtectionSpaceSOCKSProxy" },{ "trigger": "Bool._forceBridgeFromObject \t static Bool -> void" , "contents": "Bool._forceBridgeFromObject(${1:NSNumber}, inout:${2:Bool?})" },{ "trigger": "NSURLAuthenticationMethodClientCertificate \t String", "contents": "NSURLAuthenticationMethodClientCertificate" },{ "trigger": "NSMutableURLRequest \t NSMutableURLRequest", "contents": "NSMutableURLRequest" },{ "trigger": "integerForKey \t func NSUserDefaults -> Int" , "contents": "integerForKey(${1:String})" },{ "trigger": "NSCharacterSet.alphanumericCharacterSet \t class NSCharacterSet -> NSCharacterSet" , "contents": "NSCharacterSet.alphanumericCharacterSet(${1:})" },{ "trigger": "operatingSystemVersion \t NSOperatingSystemVersion", "contents": "operatingSystemVersion" },{ "trigger": "resignCurrent \t func NSProgress -> void" , "contents": "resignCurrent(${1:})" },{ "trigger": "stringByTrimmingCharactersInSet \t func NSString -> String" , "contents": "stringByTrimmingCharactersInSet(${1:NSCharacterSet})" },{ "trigger": "removeCachedResponseForRequest \t func NSURLCache -> void" , "contents": "removeCachedResponseForRequest(${1:NSURLRequest})" },{ "trigger": "minimumIntegerDigits \t Int", "contents": "minimumIntegerDigits" },{ "trigger": "caseInsensitiveCompare \t func String -> NSComparisonResult" , "contents": "caseInsensitiveCompare(${1:String})" },{ "trigger": "copy \t func NSObject -> AnyObject" , "contents": "copy(${1:})" },{ "trigger": "encodeWithCoder \t func NSString -> void" , "contents": "encodeWithCoder(${1:NSCoder})" },{ "trigger": "NSCharacterSet \t NSCharacterSet", "contents": "NSCharacterSet" },{ "trigger": "calendarIdentifier \t String", "contents": "calendarIdentifier" },{ "trigger": "encodeWithCoder \t func NSURL -> void" , "contents": "encodeWithCoder(${1:NSCoder})" },{ "trigger": "setChildren \t func NSXMLElement -> void" , "contents": "setChildren(${1:[NSXMLNode]?})" },{ "trigger": "NSNotification \t name: object: userInfo:" , "contents": "NSNotification(${1:String}, object:${2:AnyObject?}, userInfo:${3:[NSObject })" },{ "trigger": "insertChildren \t func NSXMLDocument -> void" , "contents": "insertChildren(${1:[NSXMLNode]}, atIndex:${2:Int})" },{ "trigger": "sortedArrayUsingComparator \t func NSOrderedSet -> [AnyObject]" , "contents": "sortedArrayUsingComparator(${1:NSComparator})" },{ "trigger": "copyWithZone \t func NSPredicate -> AnyObject" , "contents": "copyWithZone(${1:NSZone})" },{ "trigger": "NSURLSession.sharedSession \t class NSURLSession -> NSURLSession" , "contents": "NSURLSession.sharedSession(${1:})" },{ "trigger": "timeStyle \t NSDateIntervalFormatterStyle", "contents": "timeStyle" },{ "trigger": "classForKeyedArchiver \t AnyClass", "contents": "classForKeyedArchiver" },{ "trigger": "NSMidY \t func unknown -> CGFloat" , "contents": "NSMidY(${1:NSRect})" },{ "trigger": "NSURLErrorBackgroundTaskCancelledReasonKey \t String", "contents": "NSURLErrorBackgroundTaskCancelledReasonKey" },{ "trigger": "stringByAddingPercentEncodingWithAllowedCharacters \t func NSString -> String?" , "contents": "stringByAddingPercentEncodingWithAllowedCharacters(${1:NSCharacterSet})" },{ "trigger": "flushWithCompletionHandler \t func NSURLSession -> Void" , "contents": "flushWithCompletionHandler(${1: -> Void})" },{ "trigger": "privateFrameworksURL \t NSURL", "contents": "privateFrameworksURL" },{ "trigger": "NSHTTPURLResponse \t NSHTTPURLResponse", "contents": "NSHTTPURLResponse" },{ "trigger": "currencySymbol \t String", "contents": "currencySymbol" },{ "trigger": "NSExpression \t expressionType:" , "contents": "NSExpression(expressionType:${1:NSExpressionType})" },{ "trigger": "unitStringFromMeters \t func NSLengthFormatter -> String" , "contents": "unitStringFromMeters(${1:Double}, usedUnit:${2:UnsafeMutablePointer<NSLengthFormatterUnit>})" },{ "trigger": "isUbiquitousFileError \t Bool", "contents": "isUbiquitousFileError" },{ "trigger": "NSJSONReadingOptions \t NSJSONReadingOptions", "contents": "NSJSONReadingOptions" },{ "trigger": "enumerateObjectsUsingBlock \t func Generator -> Void" , "contents": "enumerateObjectsUsingBlock(${1:AnyObject}, Int:${2:}, UnsafeMutablePointer<ObjCBool>:${3:})" },{ "trigger": "NSURLErrorCancelled \t Int", "contents": "NSURLErrorCancelled" },{ "trigger": "NSOperatingSystemVersion \t majorVersion: minorVersion: patchVersion:" , "contents": "NSOperatingSystemVersion(${1:Int}, minorVersion:${2:Int}, patchVersion:${3:Int})" },{ "trigger": "abortParsing \t func NSXMLParser -> void" , "contents": "abortParsing(${1:})" },{ "trigger": "NSFileAppendOnly \t String", "contents": "NSFileAppendOnly" },{ "trigger": "indexesWithOptions \t func NSIndexSet -> Bool" , "contents": "indexesWithOptions(${1:NSEnumerationOptions}, passingTest:${2:Int}, UnsafeMutablePointer<ObjCBool>:${3:})" },{ "trigger": "request \t NSURLRequest", "contents": "request" },{ "trigger": "synchronize \t func NSUserDefaults -> Bool" , "contents": "synchronize(${1:})" },{ "trigger": "objectEnumerator \t func Generator -> NSEnumerator" , "contents": "objectEnumerator(${1:})" },{ "trigger": "NSAffineTransform \t coder:" , "contents": "NSAffineTransform(coder:${1:NSCoder})" },{ "trigger": "NSLocale.componentsFromLocaleIdentifier \t class NSLocale -> [String" , "contents": "NSLocale.componentsFromLocaleIdentifier(${1:String})" },{ "trigger": "setCookies \t func NSHTTPCookieStorage -> void" , "contents": "setCookies(${1:[NSHTTPCookie]}, forURL:${2:NSURL?}, mainDocumentURL:${3:NSURL?})" },{ "trigger": "stringFromPersonNameComponents \t func NSPersonNameComponentsFormatter -> String" , "contents": "stringFromPersonNameComponents(${1:NSPersonNameComponents})" },{ "trigger": "NSError.userInfoValueProviderForDomain \t class NSError -> NSError," , "contents": "NSError.userInfoValueProviderForDomain(${1:String -> NSError}, String:${2:})" },{ "trigger": "encodeWithCoder \t func NSPersonNameComponents -> void" , "contents": "encodeWithCoder(${1:NSCoder})" },{ "trigger": "fireDate \t NSDate", "contents": "fireDate" },{ "trigger": "Array._forceBridgeFromObject \t static Array -> void" , "contents": "Array._forceBridgeFromObject(${1:NSArray}, inout:${2:Array?})" },{ "trigger": "rangeOfHost \t NSRange", "contents": "rangeOfHost" },{ "trigger": "NSTimeZone \t name:" , "contents": "NSTimeZone(name:${1:String})" },{ "trigger": "readInBackgroundAndNotify \t func NSFileHandle -> void" , "contents": "readInBackgroundAndNotify(${1:})" },{ "trigger": "scanUpToCharactersFromSet \t func NSScanner -> String?" , "contents": "scanUpToCharactersFromSet(${1:NSCharacterSet})" },{ "trigger": "NSURLErrorHTTPTooManyRedirects \t Int", "contents": "NSURLErrorHTTPTooManyRedirects" },{ "trigger": "intersectSet \t func NSMutableSet -> void" , "contents": "intersectSet(${1:Set<NSObject>})" },{ "trigger": "NSPointToCGPoint \t func unknown -> CGPoint" , "contents": "NSPointToCGPoint(${1:NSPoint})" },{ "trigger": "sharedContainerIdentifier \t String", "contents": "sharedContainerIdentifier" },{ "trigger": "linkItemAtPath \t func NSFileManager -> void" , "contents": "linkItemAtPath(${1:String}, toPath:${2:String})" },{ "trigger": "formattingContext \t NSFormattingContext", "contents": "formattingContext" },{ "trigger": "removeObjectAtIndex \t func NSMutableOrderedSet -> void" , "contents": "removeObjectAtIndex(${1:Int})" },{ "trigger": "copyWithZone \t func NSFormatter -> AnyObject" , "contents": "copyWithZone(${1:NSZone})" },{ "trigger": "NSPredicate.supportsSecureCoding \t static NSPredicate -> Bool" , "contents": "NSPredicate.supportsSecureCoding(${1:})" },{ "trigger": "systemUptime \t NSTimeInterval", "contents": "systemUptime" },{ "trigger": "NSXMLNodePreservePrefixes \t Int", "contents": "NSXMLNodePreservePrefixes" },{ "trigger": "valid \t Bool", "contents": "valid" },{ "trigger": "stringFromKilograms \t func NSMassFormatter -> String" , "contents": "stringFromKilograms(${1:Double})" },{ "trigger": "containsString \t func NSString -> Bool" , "contents": "containsString(${1:String})" },{ "trigger": "NSXMLNodePreserveEmptyElements \t Int", "contents": "NSXMLNodePreserveEmptyElements" },{ "trigger": "NSMakeRect \t func unknown -> NSRect" , "contents": "NSMakeRect(${1:CGFloat}, _:${2:CGFloat}, _:${3:CGFloat}, _:${4:CGFloat})" },{ "trigger": "dateTemplate \t String", "contents": "dateTemplate" },{ "trigger": "_bridgeToObject \t func UInt -> NSNumber" , "contents": "_bridgeToObject(${1:})" },{ "trigger": "isEqualToOrderedSet \t func NSOrderedSet -> Bool" , "contents": "isEqualToOrderedSet(${1:NSOrderedSet})" },{ "trigger": "NSEqualRanges \t func unknown -> Bool" , "contents": "NSEqualRanges(${1:NSRange}, _:${2:NSRange})" },{ "trigger": "NSRunLoop \t NSRunLoop", "contents": "NSRunLoop" },{ "trigger": "setClass \t func NSKeyedUnarchiver -> void" , "contents": "setClass(${1:AnyClass?}, forClassName:${2:String})" },{ "trigger": "URLCache \t NSURLCache", "contents": "URLCache" },{ "trigger": "NSURLSessionTaskPriorityDefault \t Float", "contents": "NSURLSessionTaskPriorityDefault" },{ "trigger": "unsignedLongLongValue \t UInt", "contents": "unsignedLongLongValue" },{ "trigger": "NSCharacterSet.capitalizedLetterCharacterSet \t class NSCharacterSet -> NSCharacterSet" , "contents": "NSCharacterSet.capitalizedLetterCharacterSet(${1:})" },{ "trigger": "NSJSONWritingOptions \t NSJSONWritingOptions", "contents": "NSJSONWritingOptions" },{ "trigger": "NSNumber \t bool:" , "contents": "NSNumber(bool:${1:Bool})" },{ "trigger": "roundingIncrement \t NSNumber", "contents": "roundingIncrement" },{ "trigger": "NSProgressFileOperationKindReceiving \t String", "contents": "NSProgressFileOperationKindReceiving" },{ "trigger": "minusSign \t String", "contents": "minusSign" },{ "trigger": "NSRegularExpression.escapedPatternForString \t class NSRegularExpression -> String" , "contents": "NSRegularExpression.escapedPatternForString(${1:String})" },{ "trigger": "addTimer \t func NSRunLoop -> void" , "contents": "addTimer(${1:NSTimer}, forMode:${2:String})" },{ "trigger": "NSStream \t NSStream", "contents": "NSStream" },{ "trigger": "isDeletableFileAtPath \t func NSFileManager -> Bool" , "contents": "isDeletableFileAtPath(${1:String})" },{ "trigger": "classNamed \t func NSBundle -> AnyClass?" , "contents": "classNamed(${1:String})" },{ "trigger": "NSLocale.ISOLanguageCodes \t class NSLocale -> [String]" , "contents": "NSLocale.ISOLanguageCodes(${1:})" },{ "trigger": "decomposedStringWithCompatibilityMapping \t String", "contents": "decomposedStringWithCompatibilityMapping" },{ "trigger": "removeCredential \t func NSURLCredentialStorage -> void" , "contents": "removeCredential(${1:NSURLCredential}, forProtectionSpace:${2:NSURLProtectionSpace}, options:${3:[String }, task:${4:NSURLSessionTask})" },{ "trigger": "NSURLProtectionSpaceHTTPProxy \t String", "contents": "NSURLProtectionSpaceHTTPProxy" },{ "trigger": "dictionaryForKey \t func NSUserDefaults -> [String" , "contents": "dictionaryForKey(${1:String})" },{ "trigger": "NSKeyedArchiver \t NSKeyedArchiver", "contents": "NSKeyedArchiver" },{ "trigger": "NSXMLNodeKind \t NSXMLNodeKind", "contents": "NSXMLNodeKind" },{ "trigger": "NSInputStream \t data:" , "contents": "NSInputStream(${1:NSData})" },{ "trigger": "NSURLCacheStoragePolicy \t NSURLCacheStoragePolicy", "contents": "NSURLCacheStoragePolicy" },{ "trigger": "NSURLCredentialStorage \t NSURLCredentialStorage", "contents": "NSURLCredentialStorage" },{ "trigger": "NSProcessInfo \t NSProcessInfo", "contents": "NSProcessInfo" },{ "trigger": "NSThread.exit \t class NSThread -> void" , "contents": "NSThread.exit(${1:})" },{ "trigger": "NSOrderedSet \t set:" , "contents": "NSOrderedSet(${1:Set<NSObject>})" },{ "trigger": "NSAttributedString \t NSAttributedString", "contents": "NSAttributedString" },{ "trigger": "NSCharacterSet.URLUserAllowedCharacterSet \t class NSCharacterSet -> NSCharacterSet" , "contents": "NSCharacterSet.URLUserAllowedCharacterSet(${1:})" },{ "trigger": "objectAtIndex \t func Generator -> AnyObject" , "contents": "objectAtIndex(${1:Int})" },{ "trigger": "shortValue \t Int", "contents": "shortValue" },{ "trigger": "localizedCaseInsensitiveContainsString \t func String -> Bool" , "contents": "localizedCaseInsensitiveContainsString(${1:String})" },{ "trigger": "removeDependency \t func NSOperation -> void" , "contents": "removeDependency(${1:NSOperation})" },{ "trigger": "NSStreamNetworkServiceTypeVideo \t String", "contents": "NSStreamNetworkServiceTypeVideo" },{ "trigger": "encodeObject \t func NSCoder -> void" , "contents": "encodeObject(${1:AnyObject?}, forKey:${2:String})" },{ "trigger": "NSPort \t coder:" , "contents": "NSPort(coder:${1:NSCoder})" },{ "trigger": "address \t NSData", "contents": "address" },{ "trigger": "intersectOrderedSet \t func NSMutableOrderedSet -> void" , "contents": "intersectOrderedSet(${1:NSOrderedSet})" },{ "trigger": "isEqualToAttributedString \t func NSAttributedString -> Bool" , "contents": "isEqualToAttributedString(${1:NSAttributedString})" },{ "trigger": "addOperationWithBlock \t func NSOperationQueue -> Void" , "contents": "addOperationWithBlock(${1: -> Void})" },{ "trigger": "replaceCharactersInRange \t func NSMutableAttributedString -> void" , "contents": "replaceCharactersInRange(${1:NSRange}, withAttributedString:${2:NSAttributedString})" },{ "trigger": "displayNameForKey \t func NSLocale -> String?" , "contents": "displayNameForKey(${1:String}, value:${2:String})" },{ "trigger": "setStringValue \t func NSXMLNode -> void" , "contents": "setStringValue(${1:String}, resolvingEntities:${2:Bool})" },{ "trigger": "NSComparisonPredicateModifier \t NSComparisonPredicateModifier", "contents": "NSComparisonPredicateModifier" },{ "trigger": "NSFileExtensionHidden \t String", "contents": "NSFileExtensionHidden" },{ "trigger": "copyWithZone \t func NSXMLNode -> AnyObject" , "contents": "copyWithZone(${1:NSZone})" },{ "trigger": "attributesOfFileSystemForPath \t func NSFileManager -> [String" , "contents": "attributesOfFileSystemForPath(${1:String})" },{ "trigger": "era \t Int", "contents": "era" },{ "trigger": "indexOfObjectPassingTest \t func Generator -> Bool" , "contents": "indexOfObjectPassingTest(${1:AnyObject}, Int:${2:}, UnsafeMutablePointer<ObjCBool>:${3:})" },{ "trigger": "secondsFromGMTForDate \t func NSTimeZone -> Int" , "contents": "secondsFromGMTForDate(${1:NSDate})" },{ "trigger": "NSURLSessionDataTask \t NSURLSessionDataTask", "contents": "NSURLSessionDataTask" },{ "trigger": "matchesInString \t func NSRegularExpression -> [NSTextCheckingResult]" , "contents": "matchesInString(${1:String}, options:${2:NSMatchingOptions}, range:${3:NSRange})" },{ "trigger": "networkServiceType \t NSURLRequestNetworkServiceType", "contents": "networkServiceType" },{ "trigger": "bundlePath \t String", "contents": "bundlePath" },{ "trigger": "NSDecimalCompact \t func unknown -> void" , "contents": "NSDecimalCompact(${1:UnsafeMutablePointer<NSDecimal>})" },{ "trigger": "majorVersion \t Int", "contents": "majorVersion" },{ "trigger": "NSCalendarIdentifierEthiopicAmeteMihret \t String", "contents": "NSCalendarIdentifierEthiopicAmeteMihret" },{ "trigger": "decimalNumberByDividingBy \t func NSDecimalNumber -> NSDecimalNumber" , "contents": "decimalNumberByDividingBy(${1:NSDecimalNumber})" },{ "trigger": "minusSet \t func NSMutableSet -> void" , "contents": "minusSet(${1:Set<NSObject>})" },{ "trigger": "getIndexes \t func NSIndexPath -> void" , "contents": "getIndexes(${1:UnsafeMutablePointer<Int>}, range:${2:NSRange})" },{ "trigger": "firstIndex \t Int", "contents": "firstIndex" },{ "trigger": "NSCalendar \t NSCalendar", "contents": "NSCalendar" },{ "trigger": "NSBundle \t forClass:" , "contents": "NSBundle(forClass:${1:AnyClass})" },{ "trigger": "decodeBytesWithReturnedLength \t func NSCoder -> UnsafeMutablePointer Void " , "contents": "decodeBytesWithReturnedLength(${1:UnsafeMutablePointer<Int>})" },{ "trigger": "stringFromMeters \t func NSLengthFormatter -> String" , "contents": "stringFromMeters(${1:Double})" },{ "trigger": "insertObject \t func NSMutableOrderedSet -> void" , "contents": "insertObject(${1:AnyObject}, atIndex:${2:Int})" },{ "trigger": "NSStreamStatus \t NSStreamStatus", "contents": "NSStreamStatus" },{ "trigger": "NSOperatingSystemVersion \t :" , "contents": "NSOperatingSystemVersion(${1:})" },{ "trigger": "bitmapRepresentation \t NSData", "contents": "bitmapRepresentation" },{ "trigger": "replaceObjectsAtIndexes \t func NSMutableOrderedSet -> void" , "contents": "replaceObjectsAtIndexes(${1:NSIndexSet}, withObjects:${2:[AnyObject]})" },{ "trigger": "NSUserDefaults.resetStandardUserDefaults \t class NSUserDefaults -> void" , "contents": "NSUserDefaults.resetStandardUserDefaults(${1:})" },{ "trigger": "stringByTrimmingCharactersInSet \t func String -> String" , "contents": "stringByTrimmingCharactersInSet(${1:NSCharacterSet})" },{ "trigger": "mutableCopyWithZone \t func NSData -> AnyObject" , "contents": "mutableCopyWithZone(${1:NSZone})" },{ "trigger": "NSDateComponentsFormatter \t coder:" , "contents": "NSDateComponentsFormatter(${1:NSCoder})" },{ "trigger": "roundingMode \t NSNumberFormatterRoundingMode", "contents": "roundingMode" },{ "trigger": "capitalizedStringWithLocale \t func NSString -> String" , "contents": "capitalizedStringWithLocale(${1:NSLocale?})" },{ "trigger": "NSDecimalCopy \t func unknown -> void" , "contents": "NSDecimalCopy(${1:UnsafeMutablePointer<NSDecimal>}, _:${2:UnsafePointer<NSDecimal>})" },{ "trigger": "hasSuffix \t func NSString -> Bool" , "contents": "hasSuffix(${1:String})" },{ "trigger": "NSCharacterSet.nonBaseCharacterSet \t class NSCharacterSet -> NSCharacterSet" , "contents": "NSCharacterSet.nonBaseCharacterSet(${1:})" },{ "trigger": "NSValue \t range:" , "contents": "NSValue(${1:NSRange})" },{ "trigger": "doubleForKey \t func NSUserDefaults -> Double" , "contents": "doubleForKey(${1:String})" },{ "trigger": "NSStreamNetworkServiceType \t String", "contents": "NSStreamNetworkServiceType" },{ "trigger": "NSXMLNode.namespaceWithName \t class NSXMLNode -> AnyObject" , "contents": "NSXMLNode.namespaceWithName(${1:String}, stringValue:${2:String})" },{ "trigger": "Generator \t coder:" , "contents": "Generator(coder:${1:NSCoder})" },{ "trigger": "scaleBy \t func NSAffineTransform -> void" , "contents": "scaleBy(${1:CGFloat})" },{ "trigger": "decodePoint \t func NSCoder -> NSPoint" , "contents": "decodePoint(${1:})" },{ "trigger": "stringByResolvingSymlinksInPath \t String", "contents": "stringByResolvingSymlinksInPath" },{ "trigger": "precomposedStringWithCompatibilityMapping \t String", "contents": "precomposedStringWithCompatibilityMapping" },{ "trigger": "encodeObject \t func NSCoder -> void" , "contents": "encodeObject(${1:AnyObject?})" },{ "trigger": "encodeWithCoder \t func NSIndexPath -> void" , "contents": "encodeWithCoder(${1:NSCoder})" },{ "trigger": "NSURLErrorCannotLoadFromNetwork \t Int", "contents": "NSURLErrorCannotLoadFromNetwork" },{ "trigger": "copyWithZone \t func NSDateComponents -> AnyObject" , "contents": "copyWithZone(${1:NSZone})" },{ "trigger": "Generator \t :" , "contents": "Generator(${1:})" },{ "trigger": "percentEncodedHost \t String", "contents": "percentEncodedHost" },{ "trigger": "NSHTTPCookieDiscard \t String", "contents": "NSHTTPCookieDiscard" },{ "trigger": "ordinalityOfUnit \t func NSCalendar -> Int" , "contents": "ordinalityOfUnit(${1:NSCalendarUnit}, inUnit:${2:NSCalendarUnit}, forDate:${3:NSDate})" },{ "trigger": "NSDecimalRound \t func unknown -> void" , "contents": "NSDecimalRound(${1:UnsafeMutablePointer<NSDecimal>}, _:${2:UnsafePointer<NSDecimal>}, _:${3:Int}, _:${4:NSRoundingMode})" },{ "trigger": "NSFileTypeUnknown \t String", "contents": "NSFileTypeUnknown" },{ "trigger": "NSURL \t fileURLWithPath: isDirectory:" , "contents": "NSURL(fileURLWithPath:${1:String}, isDirectory:${2:Bool})" },{ "trigger": "resolveNamespaceForName \t func NSXMLElement -> NSXMLNode?" , "contents": "resolveNamespaceForName(${1:String})" },{ "trigger": "stringByExpandingTildeInPath \t String", "contents": "stringByExpandingTildeInPath" },{ "trigger": "NSComparisonPredicateOptions \t rawValue:" , "contents": "NSComparisonPredicateOptions(${1:UInt})" },{ "trigger": "startSecureConnection \t func NSURLSessionStreamTask -> void" , "contents": "startSecureConnection(${1:})" },{ "trigger": "NSDateComponentsFormatterZeroFormattingBehavior \t NSDateComponentsFormatterZeroFormattingBehavior", "contents": "NSDateComponentsFormatterZeroFormattingBehavior" },{ "trigger": "isSupersetOfSet \t func NSCharacterSet -> Bool" , "contents": "isSupersetOfSet(${1:NSCharacterSet})" },{ "trigger": "stringFromTimeInterval \t func NSDateComponentsFormatter -> String?" , "contents": "stringFromTimeInterval(${1:NSTimeInterval})" },{ "trigger": "isEqualToDictionary \t func Generator -> Bool" , "contents": "isEqualToDictionary(${1:[NSObject })" },{ "trigger": "NSLocale.lineDirectionForLanguage \t class NSLocale -> NSLocaleLanguageDirection" , "contents": "NSLocale.lineDirectionForLanguage(${1:String})" },{ "trigger": "== \t func unknown -> Bool" , "contents": "==(${1:CGSize}, rhs:${2:CGSize})" },{ "trigger": "NSNotificationCenter \t NSNotificationCenter", "contents": "NSNotificationCenter" },{ "trigger": "terminationReason \t NSTaskTerminationReason", "contents": "terminationReason" },{ "trigger": "sortedCookiesUsingDescriptors \t func NSHTTPCookieStorage -> [NSHTTPCookie]" , "contents": "sortedCookiesUsingDescriptors(${1:[NSSortDescriptor]})" },{ "trigger": "realm \t String", "contents": "realm" },{ "trigger": "NSCharacterSet.lowercaseLetterCharacterSet \t class NSCharacterSet -> NSCharacterSet" , "contents": "NSCharacterSet.lowercaseLetterCharacterSet(${1:})" },{ "trigger": "NSTimeZone \t NSTimeZone", "contents": "NSTimeZone" },{ "trigger": "lock \t func NSRecursiveLock -> void" , "contents": "lock(${1:})" },{ "trigger": "NSDecimal \t NSDecimal", "contents": "NSDecimal" },{ "trigger": "abbreviationForDate \t func NSTimeZone -> String?" , "contents": "abbreviationForDate(${1:NSDate})" },{ "trigger": "fragment \t String", "contents": "fragment" },{ "trigger": "NSRectFromString \t func unknown -> NSRect" , "contents": "NSRectFromString(${1:String})" },{ "trigger": "insertChild \t func NSXMLDocument -> void" , "contents": "insertChild(${1:NSXMLNode}, atIndex:${2:Int})" },{ "trigger": "NSMinX \t func unknown -> CGFloat" , "contents": "NSMinX(${1:NSRect})" },{ "trigger": "canBeConvertedToEncoding \t func NSString -> Bool" , "contents": "canBeConvertedToEncoding(${1:UInt})" },{ "trigger": "indexesOfObjectsWithOptions \t func NSOrderedSet -> Bool" , "contents": "indexesOfObjectsWithOptions(${1:NSEnumerationOptions}, passingTest:${2:AnyObject}, Int:${3:}, UnsafeMutablePointer<ObjCBool>:${4:})" },{ "trigger": "String.pathWithComponents \t static String -> String" , "contents": "String.pathWithComponents(${1:[String]})" },{ "trigger": "NSCharacterSet.uppercaseLetterCharacterSet \t class NSCharacterSet -> NSCharacterSet" , "contents": "NSCharacterSet.uppercaseLetterCharacterSet(${1:})" },{ "trigger": "NSDecimalNumber \t integerLiteral:" , "contents": "NSDecimalNumber(integerLiteral:${1:Int})" },{ "trigger": "cancel \t func NSThread -> void" , "contents": "cancel(${1:})" },{ "trigger": "atEnd \t Bool", "contents": "atEnd" },{ "trigger": "predicateWithSubstitutionVariables \t func NSPredicate -> Self" , "contents": "predicateWithSubstitutionVariables(${1:[String })" },{ "trigger": "localizedStandardContainsString \t func NSString -> Bool" , "contents": "localizedStandardContainsString(${1:String})" },{ "trigger": "removeObjectForKey \t func NSCache -> void" , "contents": "removeObjectForKey(${1:AnyObject})" },{ "trigger": "NSSymbolStringEncoding \t UInt", "contents": "NSSymbolStringEncoding" },{ "trigger": "NSCache \t :" , "contents": "NSCache(${1:})" },{ "trigger": "writeData \t func NSURLSessionStreamTask -> Void" , "contents": "writeData(${1:NSData}, timeout:${2:NSTimeInterval}, completionHandler:${3:NSError? -> Void})" },{ "trigger": "NSIndexSet \t coder:" , "contents": "NSIndexSet(coder:${1:NSCoder})" },{ "trigger": "scanFloat \t func NSScanner -> Float?" , "contents": "scanFloat(${1:})" },{ "trigger": "encodeWithCoder \t func NSURLAuthenticationChallenge -> void" , "contents": "encodeWithCoder(${1:NSCoder})" },{ "trigger": "addAttribute \t func NSMutableAttributedString -> void" , "contents": "addAttribute(${1:String}, value:${2:AnyObject}, range:${3:NSRange})" },{ "trigger": "NSIndexSet \t indexesInRange:" , "contents": "NSIndexSet(indexesInRange:${1:NSRange})" },{ "trigger": "maximumRangeOfUnit \t func NSCalendar -> NSRange" , "contents": "maximumRangeOfUnit(${1:NSCalendarUnit})" },{ "trigger": "NSSortDescriptor \t NSSortDescriptor", "contents": "NSSortDescriptor" },{ "trigger": "dataTaskWithURL \t func NSURLSession -> Void" , "contents": "dataTaskWithURL(${1:NSURL}, completionHandler:${2:NSData?}, NSURLResponse?:${3:}, NSError?:${4:})" },{ "trigger": "NSPersonNameComponentSuffix \t String", "contents": "NSPersonNameComponentSuffix" },{ "trigger": "fastestEncoding \t NSStringEncoding", "contents": "fastestEncoding" },{ "trigger": "enumerateLines \t func String -> " , "contents": "enumerateLines(body:${1:line}, inout:${2:Bool -> })" },{ "trigger": "NSMaxY \t func unknown -> CGFloat" , "contents": "NSMaxY(${1:NSRect})" },{ "trigger": "copyWithZone \t func NSURL -> AnyObject" , "contents": "copyWithZone(${1:NSZone})" },{ "trigger": "addOperation \t func NSOperationQueue -> void" , "contents": "addOperation(${1:NSOperation})" },{ "trigger": "setAttributesWithDictionary \t func NSXMLElement -> void" , "contents": "setAttributesWithDictionary(${1:[String })" },{ "trigger": "NSValue \t rect:" , "contents": "NSValue(${1:NSRect})" },{ "trigger": "NSData \t NSData", "contents": "NSData" },{ "trigger": "addObjectsFromArray \t func NSMutableArray -> void" , "contents": "addObjectsFromArray(${1:[AnyObject]})" },{ "trigger": "maximumFractionDigits \t Int", "contents": "maximumFractionDigits" },{ "trigger": "removeAllIndexes \t func NSMutableIndexSet -> void" , "contents": "removeAllIndexes(${1:})" },{ "trigger": "Int \t _:" , "contents": "Int(_:${1:NSNumber})" },{ "trigger": "compare \t func NSString -> NSComparisonResult" , "contents": "compare(${1:String}, options:${2:NSStringCompareOptions}, range:${3:NSRange}, locale:${4:AnyObject?})" },{ "trigger": "NSHomeDirectory \t func unknown -> String" , "contents": "NSHomeDirectory(${1:})" },{ "trigger": "boolForKey \t func NSUserDefaults -> Bool" , "contents": "boolForKey(${1:String})" },{ "trigger": "getCString \t func NSString -> Bool" , "contents": "getCString(${1:UnsafeMutablePointer<Int8>}, maxLength:${2:Int}, encoding:${3:UInt})" },{ "trigger": "NSRoundingMode \t NSRoundingMode", "contents": "NSRoundingMode" },{ "trigger": "indexOfObjectPassingTest \t func NSOrderedSet -> Bool" , "contents": "indexOfObjectPassingTest(${1:AnyObject}, Int:${2:}, UnsafeMutablePointer<ObjCBool>:${3:})" },{ "trigger": "activeProcessorCount \t Int", "contents": "activeProcessorCount" },{ "trigger": "characterIsMember \t func NSCharacterSet -> Bool" , "contents": "characterIsMember(${1:unichar})" },{ "trigger": "NSFileHandle \t forWritingAtPath:" , "contents": "NSFileHandle(forWritingAtPath:${1:String})" },{ "trigger": "localizedCaseInsensitiveContainsString \t func NSString -> Bool" , "contents": "localizedCaseInsensitiveContainsString(${1:String})" },{ "trigger": "NSContainsRect \t func unknown -> Bool" , "contents": "NSContainsRect(${1:NSRect}, _:${2:NSRect})" },{ "trigger": "main \t func NSThread -> void" , "contents": "main(${1:})" },{ "trigger": "replaceObjectsInRange \t func NSMutableArray -> void" , "contents": "replaceObjectsInRange(${1:NSRange}, withObjectsFromArray:${2:[AnyObject]}, range:${3:NSRange})" },{ "trigger": "generate \t func NSOrderedSet -> Generator" , "contents": "generate(${1:})" },{ "trigger": "scheme \t String", "contents": "scheme" },{ "trigger": "NSFileDeviceIdentifier \t String", "contents": "NSFileDeviceIdentifier" },{ "trigger": "downloadTaskWithResumeData \t func NSURLSession -> Void" , "contents": "downloadTaskWithResumeData(${1:NSData}, completionHandler:${2:NSURL?}, NSURLResponse?:${3:}, NSError?:${4:})" },{ "trigger": "copyWithZone \t func NSValue -> AnyObject" , "contents": "copyWithZone(${1:NSZone})" },{ "trigger": "indexOfObjectWithOptions \t func Generator -> Bool" , "contents": "indexOfObjectWithOptions(${1:NSEnumerationOptions}, passingTest:${2:AnyObject}, Int:${3:}, UnsafeMutablePointer<ObjCBool>:${4:})" },{ "trigger": "NSDecimalNumber.setDefaultBehavior \t class NSDecimalNumber -> void" , "contents": "NSDecimalNumber.setDefaultBehavior(${1:NSDecimalNumberBehaviors})" },{ "trigger": "encodeDouble \t func NSCoder -> void" , "contents": "encodeDouble(${1:Double}, forKey:${2:String})" },{ "trigger": "setAttributes \t func NSFileManager -> void" , "contents": "setAttributes(${1:[String }, ofItemAtPath:${2:String})" },{ "trigger": "NSCalendarIdentifierChinese \t String", "contents": "NSCalendarIdentifierChinese" },{ "trigger": "NSDateComponents \t NSDateComponents", "contents": "NSDateComponents" },{ "trigger": "NSDataBase \t rawValue:" , "contents": "NSDataBase(${1:UInt})" },{ "trigger": "setLocalizedDateFormatFromTemplate \t func NSDateFormatter -> void" , "contents": "setLocalizedDateFormatFromTemplate(${1:String})" },{ "trigger": "NSURLQueryItem \t name: value:" , "contents": "NSURLQueryItem(${1:String}, value:${2:String?})" },{ "trigger": "NSKeyedArchiveRootObjectKey \t String", "contents": "NSKeyedArchiveRootObjectKey" },{ "trigger": "pathsForResourcesOfType \t func NSBundle -> [String]" , "contents": "pathsForResourcesOfType(${1:String?}, inDirectory:${2:String?}, forLocalization:${3:String?})" },{ "trigger": "NSNumber \t NSNumber", "contents": "NSNumber" },{ "trigger": "sortWithOptions \t func NSMutableOrderedSet -> void" , "contents": "sortWithOptions(${1:NSSortOptions}, usingComparator:${2:NSComparator})" },{ "trigger": "NSSocketPort \t protocolFamily: socketType: `protocol`: socket:" , "contents": "NSSocketPort(protocolFamily:${1:Int32}, socketType:${2:Int32}, `protocol`:${3:Int32}, socket:${4:NSSocketNativeHandle})" },{ "trigger": "replaceBytesInRange \t func NSMutableData -> void" , "contents": "replaceBytesInRange(${1:NSRange}, withBytes:${2:UnsafePointer<Void>}, length:${3:Int})" },{ "trigger": "NSDefaultRunLoopMode \t String", "contents": "NSDefaultRunLoopMode" },{ "trigger": "NSInputStream \t URL:" , "contents": "NSInputStream(URL:${1:NSURL})" },{ "trigger": "NSCalendarIdentifierJapanese \t String", "contents": "NSCalendarIdentifierJapanese" },{ "trigger": "NSDateComponentsFormatterZeroFormattingBehavior \t rawValue:" , "contents": "NSDateComponentsFormatterZeroFormattingBehavior(${1:UInt})" },{ "trigger": "NSStreamSocketSecurityLevelNone \t String", "contents": "NSStreamSocketSecurityLevelNone" },{ "trigger": "NSByteCountFormatter \t NSByteCountFormatter", "contents": "NSByteCountFormatter" },{ "trigger": "NSURLProtocol \t request: cachedResponse: client:" , "contents": "NSURLProtocol(${1:NSURLRequest}, cachedResponse:${2:NSCachedURLResponse?}, client:${3:NSURLProtocolClient?})" },{ "trigger": "hasBytesAvailable \t Bool", "contents": "hasBytesAvailable" },{ "trigger": "lockWhenCondition \t func NSConditionLock -> Bool" , "contents": "lockWhenCondition(${1:Int}, beforeDate:${2:NSDate})" },{ "trigger": "CGRectEdge \t CGRectEdge", "contents": "CGRectEdge" },{ "trigger": "NSData \t contentsOfURL: options:" , "contents": "NSData(contentsOfURL:${1:NSURL}, options:${2:NSDataReadingOptions})" },{ "trigger": "includesTimeRemainingPhrase \t Bool", "contents": "includesTimeRemainingPhrase" },{ "trigger": "decimalSeparator \t String", "contents": "decimalSeparator" },{ "trigger": "containsObject \t func NSOrderedSet -> Bool" , "contents": "containsObject(${1:AnyObject})" },{ "trigger": "NSXMLNode.textWithStringValue \t class NSXMLNode -> AnyObject" , "contents": "NSXMLNode.textWithStringValue(${1:String})" },{ "trigger": "replaceChildAtIndex \t func NSXMLElement -> void" , "contents": "replaceChildAtIndex(${1:Int}, withNode:${2:NSXMLNode})" },{ "trigger": "decodeDoubleForKey \t func NSCoder -> Double" , "contents": "decodeDoubleForKey(${1:String})" },{ "trigger": "rangeOfPassword \t NSRange", "contents": "rangeOfPassword" },{ "trigger": "arrayByAddingObjectsFromArray \t func Generator -> [AnyObject]" , "contents": "arrayByAddingObjectsFromArray(${1:[AnyObject]})" },{ "trigger": "NSXMLNodeLoadExternalEntitiesAlways \t Int", "contents": "NSXMLNodeLoadExternalEntitiesAlways" },{ "trigger": "encodeInt32 \t func NSCoder -> void" , "contents": "encodeInt32(${1:Int32}, forKey:${2:String})" },{ "trigger": "domain \t String", "contents": "domain" },{ "trigger": "NSStringFromRect \t func unknown -> String" , "contents": "NSStringFromRect(${1:NSRect})" },{ "trigger": "enumerateRangesUsingBlock \t func NSIndexSet -> Void" , "contents": "enumerateRangesUsingBlock(${1:NSRange}, UnsafeMutablePointer<ObjCBool>:${2:})" },{ "trigger": "NSXMLNodeOptionsNone \t Int", "contents": "NSXMLNodeOptionsNone" },{ "trigger": "validate \t func NSXMLDocument -> void" , "contents": "validate(${1:})" },{ "trigger": "options \t NSComparisonPredicateOptions", "contents": "options" },{ "trigger": "NSFileHFSCreatorCode \t String", "contents": "NSFileHFSCreatorCode" },{ "trigger": "NSCharacterSet.URLPasswordAllowedCharacterSet \t class NSCharacterSet -> NSCharacterSet" , "contents": "NSCharacterSet.URLPasswordAllowedCharacterSet(${1:})" },{ "trigger": "objCType \t UnsafePointer", "contents": "objCType" },{ "trigger": "NSDateComponentUndefined \t Int", "contents": "NSDateComponentUndefined" },{ "trigger": "charValue \t Int", "contents": "charValue" },{ "trigger": "executablePath \t String", "contents": "executablePath" },{ "trigger": "NSProcessInfo.processInfo \t class NSProcessInfo -> NSProcessInfo" , "contents": "NSProcessInfo.processInfo(${1:})" },{ "trigger": "enumerateObjectsWithOptions \t func NSSet -> Void" , "contents": "enumerateObjectsWithOptions(${1:NSEnumerationOptions}, usingBlock:${2:AnyObject}, UnsafeMutablePointer<ObjCBool>:${3:})" },{ "trigger": "CGFloat \t _:" , "contents": "CGFloat(_:${1:Double})" },{ "trigger": "CGSize \t CGSize", "contents": "CGSize" },{ "trigger": "Double._conditionallyBridgeFromObject \t static Double -> Bool" , "contents": "Double._conditionallyBridgeFromObject(${1:NSNumber}, inout:${2:Double?})" },{ "trigger": "NSByteCountFormatter \t coder:" , "contents": "NSByteCountFormatter(${1:NSCoder})" },{ "trigger": "storeCachedResponse \t func NSURLCache -> void" , "contents": "storeCachedResponse(${1:NSCachedURLResponse}, forDataTask:${2:NSURLSessionDataTask})" },{ "trigger": "numberStyle \t NSNumberFormatterStyle", "contents": "numberStyle" },{ "trigger": "decodeSize \t func NSCoder -> NSSize" , "contents": "decodeSize(${1:})" },{ "trigger": "URLByAppendingPathComponent \t func NSURL -> NSURL?" , "contents": "URLByAppendingPathComponent(${1:String})" },{ "trigger": "setCredential \t func NSURLCredentialStorage -> void" , "contents": "setCredential(${1:NSURLCredential}, forProtectionSpace:${2:NSURLProtectionSpace}, task:${3:NSURLSessionTask})" },{ "trigger": "NSCharacterSet.controlCharacterSet \t class NSCharacterSet -> NSCharacterSet" , "contents": "NSCharacterSet.controlCharacterSet(${1:})" },{ "trigger": "originalRequest \t NSURLRequest", "contents": "originalRequest" },{ "trigger": "NSAffineTransformStruct \t :" , "contents": "NSAffineTransformStruct(${1:})" },{ "trigger": "timeoutIntervalForRequest \t NSTimeInterval", "contents": "timeoutIntervalForRequest" },{ "trigger": "removeObject \t func NSMutableOrderedSet -> void" , "contents": "removeObject(${1:AnyObject})" },{ "trigger": "NSFileTypeSocket \t String", "contents": "NSFileTypeSocket" },{ "trigger": "NSLock \t :" , "contents": "NSLock(${1:})" },{ "trigger": "setObject \t func NSMutableOrderedSet -> void" , "contents": "setObject(${1:AnyObject}, atIndex:${2:Int})" },{ "trigger": "NSUserName \t func unknown -> String" , "contents": "NSUserName(${1:})" },{ "trigger": "NSStreamSOCKSProxyUserKey \t String", "contents": "NSStreamSOCKSProxyUserKey" },{ "trigger": "stringByReplacingCharactersInRange \t func NSString -> String" , "contents": "stringByReplacingCharactersInRange(${1:NSRange}, withString:${2:String})" },{ "trigger": "TLSMaximumSupportedProtocol \t SSLProtocol", "contents": "TLSMaximumSupportedProtocol" },{ "trigger": "NSXMLNodePreserveWhitespace \t Int", "contents": "NSXMLNodePreserveWhitespace" },{ "trigger": "NSVolumeEnumerationOptions \t rawValue:" , "contents": "NSVolumeEnumerationOptions(${1:UInt})" },{ "trigger": "isSubsetOfOrderedSet \t func NSOrderedSet -> Bool" , "contents": "isSubsetOfOrderedSet(${1:NSOrderedSet})" },{ "trigger": "removeObjectsForKeys \t func NSMutableDictionary -> void" , "contents": "removeObjectsForKeys(${1:[AnyObject]})" },{ "trigger": "NSFormattingContext \t NSFormattingContext", "contents": "NSFormattingContext" },{ "trigger": "decodePropertyListForKey \t func NSCoder -> AnyObject?" , "contents": "decodePropertyListForKey(${1:String})" },{ "trigger": "NSProgressFileTotalCountKey \t String", "contents": "NSProgressFileTotalCountKey" },{ "trigger": "setByAddingObject \t func NSSet -> Set NSObject " , "contents": "setByAddingObject(${1:AnyObject})" },{ "trigger": "addObject \t func NSMutableSet -> void" , "contents": "addObject(${1:AnyObject})" },{ "trigger": "dateStyle \t NSDateFormatterStyle", "contents": "dateStyle" },{ "trigger": "exponentSymbol \t String", "contents": "exponentSymbol" },{ "trigger": "isExecutableFileAtPath \t func NSFileManager -> Bool" , "contents": "isExecutableFileAtPath(${1:String})" },{ "trigger": "localName \t String", "contents": "localName" },{ "trigger": "parserError \t NSError", "contents": "parserError" },{ "trigger": "removeItemAtURL \t func NSFileManager -> void" , "contents": "removeItemAtURL(${1:NSURL})" },{ "trigger": "toRange \t func NSRange -> Range Int ?" , "contents": "toRange(${1:})" },{ "trigger": "scale \t func NSDecimalNumberHandler -> Int16" , "contents": "scale(${1:})" },{ "trigger": "multiplier \t NSNumber", "contents": "multiplier" },{ "trigger": "subpathsOfDirectoryAtPath \t func NSFileManager -> [String]" , "contents": "subpathsOfDirectoryAtPath(${1:String})" },{ "trigger": "NSURLErrorDomain \t String", "contents": "NSURLErrorDomain" },{ "trigger": "Generator \t object:" , "contents": "Generator(object:${1:AnyObject})" },{ "trigger": "localizedFailureReason \t String", "contents": "localizedFailureReason" },{ "trigger": "setSet \t func NSMutableSet -> void" , "contents": "setSet(${1:Set<NSObject>})" },{ "trigger": "NSXMLDocument \t rootElement:" , "contents": "NSXMLDocument(rootElement:${1:NSXMLElement?})" },{ "trigger": "NSMidX \t func unknown -> CGFloat" , "contents": "NSMidX(${1:NSRect})" },{ "trigger": "firstMatchInString \t func NSRegularExpression -> NSTextCheckingResult?" , "contents": "firstMatchInString(${1:String}, options:${2:NSMatchingOptions}, range:${3:NSRange})" },{ "trigger": "characterEncoding \t String", "contents": "characterEncoding" },{ "trigger": "NSStreamDataWrittenToMemoryStreamKey \t String", "contents": "NSStreamDataWrittenToMemoryStreamKey" },{ "trigger": "encodeInt64 \t func NSCoder -> void" , "contents": "encodeInt64(${1:Int64}, forKey:${2:String})" },{ "trigger": "bundleURL \t NSURL", "contents": "bundleURL" },{ "trigger": "fileURL \t Bool", "contents": "fileURL" },{ "trigger": "encodeConditionalObject \t func NSCoder -> void" , "contents": "encodeConditionalObject(${1:AnyObject?}, forKey:${2:String})" },{ "trigger": "NSTextCheckingType \t rawValue:" , "contents": "NSTextCheckingType(${1:UInt64})" },{ "trigger": "NSNotFound \t Int", "contents": "NSNotFound" },{ "trigger": "rangeOfString \t func NSString -> NSRange" , "contents": "rangeOfString(${1:String})" },{ "trigger": "+= \t func unknown -> void" , "contents": "+=(inout:${1:CGFloat}, rhs:${2:CGFloat})" },{ "trigger": "NSMutableData \t NSMutableData", "contents": "NSMutableData" },{ "trigger": "NSSizeFromString \t func unknown -> NSSize" , "contents": "NSSizeFromString(${1:String})" },{ "trigger": "NSDataSearchOptions \t rawValue:" , "contents": "NSDataSearchOptions(${1:UInt})" },{ "trigger": "descriptionWithLocale \t func NSOrderedSet -> String" , "contents": "descriptionWithLocale(${1:AnyObject?}, indent:${2:Int})" },{ "trigger": "unknown \t rawValue:" , "contents": "unknown(${1:RawValue})" },{ "trigger": "NSTimeZone.setDefaultTimeZone \t class NSTimeZone -> void" , "contents": "NSTimeZone.setDefaultTimeZone(${1:NSTimeZone})" },{ "trigger": "nextSibling \t NSXMLNode", "contents": "nextSibling" },{ "trigger": "discretionary \t Bool", "contents": "discretionary" },{ "trigger": "dataUsingEncoding \t func NSString -> NSData?" , "contents": "dataUsingEncoding(${1:UInt})" },{ "trigger": "NSFileCreationDate \t String", "contents": "NSFileCreationDate" },{ "trigger": "internationalCurrencySymbol \t String", "contents": "internationalCurrencySymbol" },{ "trigger": "globallyUniqueString \t String", "contents": "globallyUniqueString" },{ "trigger": "tryLock \t func NSConditionLock -> Bool" , "contents": "tryLock(${1:})" },{ "trigger": "lock \t func NSCondition -> void" , "contents": "lock(${1:})" },{ "trigger": "location \t Int", "contents": "location" },{ "trigger": "NSTaskTerminationReason \t NSTaskTerminationReason", "contents": "NSTaskTerminationReason" },{ "trigger": "String \t format: _:" , "contents": "String(${1:String}, _:${2:CVarArgType...})" },{ "trigger": "minimumSignificantDigits \t Int", "contents": "minimumSignificantDigits" },{ "trigger": "enumerateLinesUsingBlock \t func NSString -> Void" , "contents": "enumerateLinesUsingBlock(${1:String}, UnsafeMutablePointer<ObjCBool>:${2:})" },{ "trigger": "NSTimeZone.localTimeZone \t class NSTimeZone -> NSTimeZone" , "contents": "NSTimeZone.localTimeZone(${1:})" },{ "trigger": "secure \t Bool", "contents": "secure" },{ "trigger": "NSURLCredentialStorageRemoveSynchronizableCredentials \t String", "contents": "NSURLCredentialStorageRemoveSynchronizableCredentials" },{ "trigger": "unitStringFromValue \t func NSMassFormatter -> String" , "contents": "unitStringFromValue(${1:Double}, unit:${2:NSMassFormatterUnit})" },{ "trigger": "minimum \t NSNumber", "contents": "minimum" },{ "trigger": "countOfBytesExpectedToReceive \t Int", "contents": "countOfBytesExpectedToReceive" },{ "trigger": "day \t Int", "contents": "day" },{ "trigger": "NSXMLNodePreserveAttributeOrder \t Int", "contents": "NSXMLNodePreserveAttributeOrder" },{ "trigger": "removePersistentDomainForName \t func NSUserDefaults -> void" , "contents": "removePersistentDomainForName(${1:String})" },{ "trigger": "NSString \t UTF8String:" , "contents": "NSString(UTF8String:${1:UnsafePointer<Int8>})" },{ "trigger": "intersectsSet \t func NSOrderedSet -> Bool" , "contents": "intersectsSet(${1:Set<NSObject>})" },{ "trigger": "NSTimer \t NSTimer", "contents": "NSTimer" },{ "trigger": "stringsByAppendingPaths \t func NSString -> [String]" , "contents": "stringsByAppendingPaths(${1:[String]})" },{ "trigger": "rangeOfString \t func NSString -> NSRange" , "contents": "rangeOfString(${1:String}, options:${2:NSStringCompareOptions}, range:${3:NSRange}, locale:${4:NSLocale?})" },{ "trigger": "stringForKey \t func NSUserDefaults -> String?" , "contents": "stringForKey(${1:String})" },{ "trigger": "removeObject \t func NSMutableArray -> void" , "contents": "removeObject(${1:AnyObject}, inRange:${2:NSRange})" },{ "trigger": "NSBundle \t NSBundle", "contents": "NSBundle" },{ "trigger": "indexGreaterThanOrEqualToIndex \t func NSIndexSet -> Int" , "contents": "indexGreaterThanOrEqualToIndex(${1:Int})" },{ "trigger": "NSAffineTransformStruct \t m11: m12: m21: m22: tX: tY:" , "contents": "NSAffineTransformStruct(${1:CGFloat}, m12:${2:CGFloat}, m21:${3:CGFloat}, m22:${4:CGFloat}, tX:${5:CGFloat}, tY:${6:CGFloat})" },{ "trigger": "rangeOfWeekendContaining \t func NSCalendar -> NSDateInterval?" , "contents": "rangeOfWeekendContaining(${1:NSDate})" },{ "trigger": "NSUnionRect \t func unknown -> NSRect" , "contents": "NSUnionRect(${1:NSRect}, _:${2:NSRect})" },{ "trigger": "sortedArrayUsingFunction \t func Generator -> Int," , "contents": "sortedArrayUsingFunction(comparator:${1:@conventionc AnyObject}, AnyObject:${2:}, UnsafeMutablePointer<Void>:${3:}, context:${4:UnsafeMutablePointer<Void>})" },{ "trigger": "enumerateObjectsUsingBlock \t func NSSet -> Void" , "contents": "enumerateObjectsUsingBlock(${1:AnyObject}, UnsafeMutablePointer<ObjCBool>:${2:})" },{ "trigger": "NSObject \t :" , "contents": "NSObject(${1:})" },{ "trigger": "decimalNumberByRoundingAccordingToBehavior \t func NSDecimalNumber -> NSDecimalNumber" , "contents": "decimalNumberByRoundingAccordingToBehavior(${1:NSDecimalNumberBehaviors?})" },{ "trigger": "getTasksWithCompletionHandler \t func NSURLSession -> Void" , "contents": "getTasksWithCompletionHandler(${1:[NSURLSessionDataTask]}, [NSURLSessionUploadTask]:${2:}, [NSURLSessionDownloadTask]:${3:})" },{ "trigger": "uploadTaskWithStreamedRequest \t func NSURLSession -> NSURLSessionUploadTask" , "contents": "uploadTaskWithStreamedRequest(${1:NSURLRequest})" },{ "trigger": "timeoutIntervalForResource \t NSTimeInterval", "contents": "timeoutIntervalForResource" },{ "trigger": "NSDataWritingOptions \t NSDataWritingOptions", "contents": "NSDataWritingOptions" },{ "trigger": "uppercaseStringWithLocale \t func String -> String" , "contents": "uppercaseStringWithLocale(${1:NSLocale?})" },{ "trigger": "encodeInt \t func NSCoder -> void" , "contents": "encodeInt(${1:Int32}, forKey:${2:String})" },{ "trigger": "socket \t NSSocketNativeHandle", "contents": "socket" },{ "trigger": "beginEditing \t func NSMutableAttributedString -> void" , "contents": "beginEditing(${1:})" },{ "trigger": "NSCharacterSet.decimalDigitCharacterSet \t class NSCharacterSet -> NSCharacterSet" , "contents": "NSCharacterSet.decimalDigitCharacterSet(${1:})" },{ "trigger": "NSBundle.preferredLocalizationsFromArray \t class NSBundle -> [String]" , "contents": "NSBundle.preferredLocalizationsFromArray(${1:[String]}, forPreferences:${2:[String]?})" },{ "trigger": "NSLocaleCalendar \t String", "contents": "NSLocaleCalendar" },{ "trigger": "=== \t func unknown -> Bool" , "contents": "===(${1:NSNull?}, rhs:${2:NSNull?})" },{ "trigger": "NSXMLDocument \t contentsOfURL: options:" , "contents": "NSXMLDocument(contentsOfURL:${1:NSURL}, options:${2:Int})" },{ "trigger": "NSProgressFileOperationKindCopying \t String", "contents": "NSProgressFileOperationKindCopying" },{ "trigger": "NSIntersectsRect \t func unknown -> Bool" , "contents": "NSIntersectsRect(${1:NSRect}, _:${2:NSRect})" },{ "trigger": "NSXMLParserExternalEntityResolvingPolicy \t NSXMLParserExternalEntityResolvingPolicy", "contents": "NSXMLParserExternalEntityResolvingPolicy" },{ "trigger": "NSData \t contentsOfFile:" , "contents": "NSData(contentsOfFile:${1:String})" },{ "trigger": "NSMatchingFlags \t NSMatchingFlags", "contents": "NSMatchingFlags" },{ "trigger": "NSDataBase \t NSDataBase", "contents": "NSDataBase" },{ "trigger": "NSIntegralRect \t func unknown -> NSRect" , "contents": "NSIntegralRect(${1:NSRect})" },{ "trigger": "NSFileHandle.fileHandleWithStandardOutput \t class NSFileHandle -> NSFileHandle" , "contents": "NSFileHandle.fileHandleWithStandardOutput(${1:})" },{ "trigger": "countOfBytesExpectedToSend \t Int", "contents": "countOfBytesExpectedToSend" },{ "trigger": "error \t NSError", "contents": "error" },{ "trigger": "appStoreReceiptURL \t NSURL", "contents": "appStoreReceiptURL" },{ "trigger": "nodesForXPath \t func NSXMLNode -> [NSXMLNode]" , "contents": "nodesForXPath(${1:String})" },{ "trigger": "Generator \t objects: forKeys: count:" , "contents": "Generator(${1:UnsafePointer<AnyObject>}, forKeys:${2:UnsafePointer<NSObject>}, count:${3:Int})" },{ "trigger": "CGFloat \t :" , "contents": "CGFloat(${1:})" },{ "trigger": "countLimit \t Int", "contents": "countLimit" },{ "trigger": "bridge \t func NSDictionary -> [NSObject:" , "contents": "bridge(${1:})" },{ "trigger": "NSAttributedString \t string: attributes:" , "contents": "NSAttributedString(string:${1:String}, attributes:${2:[String })" },{ "trigger": "NSCondition \t NSCondition", "contents": "NSCondition" },{ "trigger": "weekOfMonth \t Int", "contents": "weekOfMonth" },{ "trigger": "NSMacOSRomanStringEncoding \t UInt", "contents": "NSMacOSRomanStringEncoding" },{ "trigger": "NSAttributedString \t string:" , "contents": "NSAttributedString(string:${1:String})" },{ "trigger": "NSPersonNameComponentsFormatter \t coder:" , "contents": "NSPersonNameComponentsFormatter(${1:NSCoder})" },{ "trigger": "elementsForLocalName \t func NSXMLElement -> [NSXMLElement]" , "contents": "elementsForLocalName(${1:String}, URI:${2:String?})" },{ "trigger": "NSURL.fileURLWithPathComponents \t class NSURL -> NSURL?" , "contents": "NSURL.fileURLWithPathComponents(${1:[String]})" },{ "trigger": "NSURLErrorCannotCloseFile \t Int", "contents": "NSURLErrorCannotCloseFile" },{ "trigger": "versionForClassName \t func NSCoder -> Int" , "contents": "versionForClassName(${1:String})" },{ "trigger": "NSPostingStyle \t NSPostingStyle", "contents": "NSPostingStyle" },{ "trigger": "dateFormat \t String", "contents": "dateFormat" },{ "trigger": "== \t func unknown -> Bool" , "contents": "==(${1:NSObject}, rhs:${2:NSObject})" },{ "trigger": "NSProgress \t totalUnitCount:" , "contents": "NSProgress(totalUnitCount:${1:Int64})" },{ "trigger": "URLByStandardizingPath \t NSURL", "contents": "URLByStandardizingPath" },{ "trigger": "previousSibling \t NSXMLNode", "contents": "previousSibling" },{ "trigger": "componentsToDisplayForPath \t func NSFileManager -> [String]?" , "contents": "componentsToDisplayForPath(${1:String})" },{ "trigger": "NSHeight \t func unknown -> CGFloat" , "contents": "NSHeight(${1:NSRect})" },{ "trigger": "NSKeyedArchiver.archiveRootObject \t class NSKeyedArchiver -> Bool" , "contents": "NSKeyedArchiver.archiveRootObject(${1:AnyObject}, toFile:${2:String})" },{ "trigger": "NSSearchPathForDirectoriesInDomains \t func unknown -> [String]" , "contents": "NSSearchPathForDirectoriesInDomains(${1:NSSearchPathDirectory}, _:${2:NSSearchPathDomainMask}, _:${3:Bool})" },{ "trigger": "dateByAddingTimeInterval \t func NSDate -> NSDate" , "contents": "dateByAddingTimeInterval(${1:NSTimeInterval})" },{ "trigger": "NSCountedSet \t set:" , "contents": "NSCountedSet(${1:Set<NSObject>})" },{ "trigger": "NSURLSessionStreamTask \t NSURLSessionStreamTask", "contents": "NSURLSessionStreamTask" },{ "trigger": "NSDecimalNumber \t mantissa: exponent: isNegative:" , "contents": "NSDecimalNumber(${1:UInt64}, exponent:${2:Int16}, isNegative:${3:Bool})" },{ "trigger": "NSOrderedSet \t array: copyItems:" , "contents": "NSOrderedSet(array:${1:[AnyObject]}, copyItems:${2:Bool})" },{ "trigger": "failWithError \t func NSCoder -> void" , "contents": "failWithError(${1:NSError})" },{ "trigger": "generate \t func NSIndexSet -> Generator" , "contents": "generate(${1:})" },{ "trigger": "components \t func NSCalendar -> NSDateComponents" , "contents": "components(${1:NSCalendarUnit}, fromDate:${2:NSDate}, toDate:${3:NSDate}, options:${4:NSCalendarOptions})" },{ "trigger": "NSURLAuthenticationChallenge \t authenticationChallenge:" , "contents": "NSURLAuthenticationChallenge(authenticationChallenge:${1:NSURLAuthenticationChallenge})" },{ "trigger": "anyObject \t func NSSet -> AnyObject?" , "contents": "anyObject(${1:})" },{ "trigger": "NSXMLNode.elementWithName \t class NSXMLNode -> AnyObject" , "contents": "NSXMLNode.elementWithName(${1:String}, stringValue:${2:String})" },{ "trigger": "supportsSecureCoding \t func NSSortDescriptor -> Bool" , "contents": "supportsSecureCoding(${1:})" },{ "trigger": "NSURLCache \t NSURLCache", "contents": "NSURLCache" },{ "trigger": "hasPrefix \t func String -> Bool" , "contents": "hasPrefix(${1:String})" },{ "trigger": "canBeConvertedToEncoding \t func String -> Bool" , "contents": "canBeConvertedToEncoding(${1:NSStringEncoding})" },{ "trigger": "NSOperationQueue.currentQueue \t class NSOperationQueue -> NSOperationQueue?" , "contents": "NSOperationQueue.currentQueue(${1:})" },{ "trigger": "minute \t Int", "contents": "minute" },{ "trigger": "NSRunLoopCommonModes \t String", "contents": "NSRunLoopCommonModes" },{ "trigger": "sortUsingComparator \t func NSMutableArray -> void" , "contents": "sortUsingComparator(${1:NSComparator})" },{ "trigger": "NSURLCredentialStorage.sharedCredentialStorage \t class NSURLCredentialStorage -> NSURLCredentialStorage" , "contents": "NSURLCredentialStorage.sharedCredentialStorage(${1:})" },{ "trigger": "NSDateComponentsFormatter \t NSDateComponentsFormatter", "contents": "NSDateComponentsFormatter" },{ "trigger": "scaleXBy \t func NSAffineTransform -> void" , "contents": "scaleXBy(${1:CGFloat}, yBy:${2:CGFloat})" },{ "trigger": "NSURLSessionTask \t :" , "contents": "NSURLSessionTask(${1:})" },{ "trigger": "cStringUsingEncoding \t func String -> [CChar]?" , "contents": "cStringUsingEncoding(${1:NSStringEncoding})" },{ "trigger": "encodeWithCoder \t func NSCachedURLResponse -> void" , "contents": "encodeWithCoder(${1:NSCoder})" },{ "trigger": "addCharactersInRange \t func NSMutableCharacterSet -> void" , "contents": "addCharactersInRange(${1:NSRange})" },{ "trigger": "NSIndexPath \t indexes: length:" , "contents": "NSIndexPath(${1:UnsafePointer<Int>}, length:${2:Int})" },{ "trigger": "objectEnumerator \t func NSOrderedSet -> NSEnumerator" , "contents": "objectEnumerator(${1:})" },{ "trigger": "removeNamespaceForPrefix \t func NSXMLElement -> void" , "contents": "removeNamespaceForPrefix(${1:String})" },{ "trigger": "nextNode \t NSXMLNode", "contents": "nextNode" },{ "trigger": "mutableCopyWithZone \t func NSAttributedString -> AnyObject" , "contents": "mutableCopyWithZone(${1:NSZone})" },{ "trigger": "NSURLProtectionSpaceHTTPS \t String", "contents": "NSURLProtectionSpaceHTTPS" },{ "trigger": "NSByteCountFormatterCountStyle \t NSByteCountFormatterCountStyle", "contents": "NSByteCountFormatterCountStyle" },{ "trigger": "NSXMLNodeExpandEmptyElement \t Int", "contents": "NSXMLNodeExpandEmptyElement" },{ "trigger": "secondsFromGMT \t Int", "contents": "secondsFromGMT" },{ "trigger": "NSBundle.pathForResource \t class NSBundle -> String?" , "contents": "NSBundle.pathForResource(${1:String?}, ofType:${2:String?}, inDirectory:${3:String})" },{ "trigger": "NSHTTPCookiePort \t String", "contents": "NSHTTPCookiePort" },{ "trigger": "NSProgress \t NSProgress", "contents": "NSProgress" },{ "trigger": "scanFloat \t func NSScanner -> Bool" , "contents": "scanFloat(${1:UnsafeMutablePointer<Float>})" },{ "trigger": "stopSecureConnection \t func NSURLSessionStreamTask -> void" , "contents": "stopSecureConnection(${1:})" },{ "trigger": "exchangeObjectAtIndex \t func NSMutableArray -> void" , "contents": "exchangeObjectAtIndex(${1:Int}, withObjectAtIndex:${2:Int})" },{ "trigger": "minorVersion \t Int", "contents": "minorVersion" },{ "trigger": "String \t data: encoding:" , "contents": "String(${1:NSData}, encoding:${2:NSStringEncoding})" },{ "trigger": "NSFormatter \t coder:" , "contents": "NSFormatter(${1:NSCoder})" },{ "trigger": "NSJSONSerialization.JSONObjectWithData \t class NSJSONSerialization -> Any" , "contents": "NSJSONSerialization.JSONObjectWithData(${1:NSData}, options:${2:NSJSONReadingOptions})" },{ "trigger": "close \t func NSStream -> void" , "contents": "close(${1:})" },{ "trigger": "priority \t Float", "contents": "priority" },{ "trigger": "NSPersonNameComponents \t NSPersonNameComponents", "contents": "NSPersonNameComponents" },{ "trigger": "minimumFractionDigits \t Int", "contents": "minimumFractionDigits" },{ "trigger": "NSPersonNameComponentPrefix \t String", "contents": "NSPersonNameComponentPrefix" },{ "trigger": "NSURLProtectionSpace \t NSURLProtectionSpace", "contents": "NSURLProtectionSpace" },{ "trigger": "NSURLAuthenticationMethodServerTrust \t String", "contents": "NSURLAuthenticationMethodServerTrust" },{ "trigger": "NSMutableData \t length:" , "contents": "NSMutableData(${1:Int})" },{ "trigger": "NSXMLParser \t data:" , "contents": "NSXMLParser(${1:NSData})" },{ "trigger": "NSXMLParser \t stream:" , "contents": "NSXMLParser(${1:NSInputStream})" },{ "trigger": "addCharactersInString \t func NSMutableCharacterSet -> void" , "contents": "addCharactersInString(${1:String})" },{ "trigger": "NSCalendarIdentifierCoptic \t String", "contents": "NSCalendarIdentifierCoptic" },{ "trigger": "stringByAppendingString \t func String -> String" , "contents": "stringByAppendingString(${1:String})" },{ "trigger": "NSData \t bytesNoCopy: length: deallocator: Int:" , "contents": "NSData(bytesNoCopy:${1:UnsafeMutablePointer<Void>}, length:${2:Int}, deallocator:${3:UnsafeMutablePointer<Void>}, Int:${4:})" },{ "trigger": "NSLocale \t coder:" , "contents": "NSLocale(coder:${1:NSCoder})" },{ "trigger": "NSTextCheckingResult \t coder:" , "contents": "NSTextCheckingResult(coder:${1:NSCoder})" },{ "trigger": "insertChild \t func NSXMLDTD -> void" , "contents": "insertChild(${1:NSXMLNode}, atIndex:${2:Int})" },{ "trigger": "NSURLProtocol.registerClass \t class NSURLProtocol -> Bool" , "contents": "NSURLProtocol.registerClass(${1:AnyClass})" },{ "trigger": "NSXMLNode.attributeWithName \t class NSXMLNode -> AnyObject" , "contents": "NSXMLNode.attributeWithName(${1:String}, URI:${2:String}, stringValue:${3:String})" },{ "trigger": "finishEncoding \t func NSKeyedArchiver -> void" , "contents": "finishEncoding(${1:})" },{ "trigger": "NSExpressionType \t NSExpressionType", "contents": "NSExpressionType" },{ "trigger": "intValue \t Int", "contents": "intValue" },{ "trigger": "NSFileOwnerAccountID \t String", "contents": "NSFileOwnerAccountID" },{ "trigger": "indexesInRange \t func NSIndexSet -> Bool" , "contents": "indexesInRange(${1:NSRange}, options:${2:NSEnumerationOptions}, passingTest:${3:Int}, UnsafeMutablePointer<ObjCBool>:${4:})" },{ "trigger": "NSKeyedArchiver.archivedDataWithRootObject \t class NSKeyedArchiver -> NSData" , "contents": "NSKeyedArchiver.archivedDataWithRootObject(${1:AnyObject})" },{ "trigger": "NSFileHandleReadToEndOfFileCompletionNotification \t String", "contents": "NSFileHandleReadToEndOfFileCompletionNotification" },{ "trigger": "NSJapaneseEUCStringEncoding \t UInt", "contents": "NSJapaneseEUCStringEncoding" },{ "trigger": "localizedName \t String", "contents": "localizedName" },{ "trigger": "decodeInt64ForKey \t func NSCoder -> Int64" , "contents": "decodeInt64ForKey(${1:String})" },{ "trigger": "NSPropertyListSerialization.propertyListWithData \t class NSPropertyListSerialization -> Any" , "contents": "NSPropertyListSerialization.propertyListWithData(${1:NSData}, options:${2:NSPropertyListReadOptions}, format:${3:UnsafeMutablePointer<NSPropertyListFormat>})" },{ "trigger": "NSDecimal \t _exponent: _length: _isNegative: _isCompact: _reserved: _mantissa: UInt16: UInt16: UInt16: UInt16: UInt16: UInt16: UInt16:" , "contents": "NSDecimal(${1:Int32}, _length:${2:UInt32}, _isNegative:${3:UInt32}, _isCompact:${4:UInt32}, _reserved:${5:UInt32}, _mantissa:${6:UInt16}, UInt16:${7:}, UInt16:${8:}, UInt16:${9:}, UInt16:${10:}, UInt16:${11:}, UInt16:${12:}, UInt16:${13:})" },{ "trigger": "XMLData \t NSData", "contents": "XMLData" },{ "trigger": "sortedArrayUsingFunction \t func Generator -> Int," , "contents": "sortedArrayUsingFunction(comparator:${1:@conventionc AnyObject}, AnyObject:${2:}, UnsafeMutablePointer<Void>:${3:}, context:${4:UnsafeMutablePointer<Void>}, hint:${5:NSData?})" },{ "trigger": "attributesAtIndex \t func NSAttributedString -> [String" , "contents": "attributesAtIndex(${1:Int}, longestEffectiveRange:${2:NSRangePointer}, inRange:${3:NSRange})" },{ "trigger": "enumerateIndexesWithOptions \t func NSIndexSet -> Void" , "contents": "enumerateIndexesWithOptions(${1:NSEnumerationOptions}, usingBlock:${2:Int}, UnsafeMutablePointer<ObjCBool>:${3:})" },{ "trigger": "NSBinarySearchingOptions \t rawValue:" , "contents": "NSBinarySearchingOptions(${1:UInt})" },{ "trigger": "substringWithRange \t func String -> String" , "contents": "substringWithRange(${1:Range<Index>})" },{ "trigger": "doubleValue \t Double", "contents": "doubleValue" },{ "trigger": "NSOrderedSet \t arrayLiteral:" , "contents": "NSOrderedSet(arrayLiteral:${1:AnyObject...})" },{ "trigger": "NSRecursiveLock \t NSRecursiveLock", "contents": "NSRecursiveLock" },{ "trigger": "NSStringEncodingConversionOptions \t NSStringEncodingConversionOptions", "contents": "NSStringEncodingConversionOptions" },{ "trigger": "lengthOfBytesUsingEncoding \t func NSString -> Int" , "contents": "lengthOfBytesUsingEncoding(${1:UInt})" },{ "trigger": "objectByApplyingXSLTString \t func NSXMLDocument -> AnyObject" , "contents": "objectByApplyingXSLTString(${1:String}, arguments:${2:[String })" },{ "trigger": "NSCompoundPredicate \t type: subpredicates:" , "contents": "NSCompoundPredicate(${1:NSCompoundPredicateType}, subpredicates:${2:[NSPredicate]})" },{ "trigger": "NSSortDescriptor \t key: ascending:" , "contents": "NSSortDescriptor(${1:String?}, ascending:${2:Bool})" },{ "trigger": "NSNotificationQueue \t NSNotificationQueue", "contents": "NSNotificationQueue" },{ "trigger": "NSHTTPCookieMaximumAge \t String", "contents": "NSHTTPCookieMaximumAge" },{ "trigger": "enumerateRangesWithOptions \t func NSIndexSet -> Void" , "contents": "enumerateRangesWithOptions(${1:NSEnumerationOptions}, usingBlock:${2:NSRange}, UnsafeMutablePointer<ObjCBool>:${3:})" },{ "trigger": "executing \t Bool", "contents": "executing" },{ "trigger": "substringToIndex \t func NSString -> String" , "contents": "substringToIndex(${1:Int})" },{ "trigger": "=== \t func unknown -> Bool" , "contents": "===(${1:AnyClass}, rhs:${2:AnyClass})" },{ "trigger": "suggestedFilename \t String", "contents": "suggestedFilename" },{ "trigger": "substringFromIndex \t func String -> String" , "contents": "substringFromIndex(${1:Index})" },{ "trigger": "tryLockWhenCondition \t func NSConditionLock -> Bool" , "contents": "tryLockWhenCondition(${1:Int})" },{ "trigger": "NSByteCountFormatter.stringFromByteCount \t class NSByteCountFormatter -> String" , "contents": "NSByteCountFormatter.stringFromByteCount(${1:Int64}, countStyle:${2:NSByteCountFormatterCountStyle})" },{ "trigger": "NSBlockOperation \t block:" , "contents": "NSBlockOperation(${1: -> Void})" },{ "trigger": "NSNumber \t bytes: objCType:" , "contents": "NSNumber(bytes:${1:UnsafePointer<Void>}, objCType:${2:UnsafePointer<Int8>})" },{ "trigger": "intersectSet \t func NSMutableOrderedSet -> void" , "contents": "intersectSet(${1:Set<NSObject>})" },{ "trigger": "containsValueForKey \t func NSCoder -> Bool" , "contents": "containsValueForKey(${1:String})" },{ "trigger": "persistentDomainForName \t func NSUserDefaults -> [String" , "contents": "persistentDomainForName(${1:String})" },{ "trigger": "NSLocale.canonicalLocaleIdentifierFromString \t class NSLocale -> String" , "contents": "NSLocale.canonicalLocaleIdentifierFromString(${1:String})" },{ "trigger": "NSDecimalNumber.defaultBehavior \t class NSDecimalNumber -> NSDecimalNumberBehaviors" , "contents": "NSDecimalNumber.defaultBehavior(${1:})" },{ "trigger": "closeFile \t func NSFileHandle -> void" , "contents": "closeFile(${1:})" },{ "trigger": "NSData \t base64EncodedData: options:" , "contents": "NSData(base64EncodedData:${1:NSData}, options:${2:NSDataBase64DecodingOptions})" },{ "trigger": "NSDateComponentsFormatter.localizedStringFromDateComponents \t class NSDateComponentsFormatter -> String?" , "contents": "NSDateComponentsFormatter.localizedStringFromDateComponents(${1:NSDateComponents}, unitsStyle:${2:NSDateComponentsFormatterUnitsStyle})" },{ "trigger": "NSFileGroupOwnerAccountID \t String", "contents": "NSFileGroupOwnerAccountID" },{ "trigger": "tryLock \t func NSLock -> Bool" , "contents": "tryLock(${1:})" },{ "trigger": "standardError \t AnyObject", "contents": "standardError" },{ "trigger": "rangeOfFragment \t NSRange", "contents": "rangeOfFragment" },{ "trigger": "resetBytesInRange \t func NSMutableData -> void" , "contents": "resetBytesInRange(${1:NSRange})" },{ "trigger": "NSCharacterSet \t charactersInString:" , "contents": "NSCharacterSet(charactersInString:${1:String})" },{ "trigger": "NSZone \t nilLiteral:" , "contents": "NSZone(${1:})" },{ "trigger": "qualityOfService \t NSQualityOfService", "contents": "qualityOfService" },{ "trigger": "NSURLErrorZeroByteResource \t Int", "contents": "NSURLErrorZeroByteResource" },{ "trigger": "NSIndexSet \t index:" , "contents": "NSIndexSet(index:${1:Int})" },{ "trigger": "containsIndexesInRange \t func NSIndexSet -> Bool" , "contents": "containsIndexesInRange(${1:NSRange})" },{ "trigger": "mutableCopy \t func NSObject -> AnyObject" , "contents": "mutableCopy(${1:})" },{ "trigger": "suspend \t func NSURLSessionTask -> void" , "contents": "suspend(${1:})" },{ "trigger": "setInteger \t func NSUserDefaults -> void" , "contents": "setInteger(${1:Int}, forKey:${2:String})" },{ "trigger": "insertChildren \t func NSXMLDTD -> void" , "contents": "insertChildren(${1:[NSXMLNode]}, atIndex:${2:Int})" },{ "trigger": "lastObject \t AnyObject", "contents": "lastObject" },{ "trigger": "NSXMLElement \t XMLString:" , "contents": "NSXMLElement(XMLString:${1:String})" },{ "trigger": "firstWeekday \t Int", "contents": "firstWeekday" },{ "trigger": "externalEntityResolvingPolicy \t NSXMLParserExternalEntityResolvingPolicy", "contents": "externalEntityResolvingPolicy" },{ "trigger": "predicate \t NSPredicate", "contents": "predicate" },{ "trigger": "isDate \t func NSCalendar -> Bool" , "contents": "isDate(${1:NSDate}, inSameDayAsDate:${2:NSDate})" },{ "trigger": "NSPersonNameComponentFamilyName \t String", "contents": "NSPersonNameComponentFamilyName" },{ "trigger": "NSXMLDocumentTidyHTML \t Int", "contents": "NSXMLDocumentTidyHTML" },{ "trigger": "isSubsetOfSet \t func NSSet -> Bool" , "contents": "isSubsetOfSet(${1:Set<NSObject>})" },{ "trigger": "countForObject \t func NSCountedSet -> Int" , "contents": "countForObject(${1:AnyObject})" },{ "trigger": "NSXMLNodeUseDoubleQuotes \t Int", "contents": "NSXMLNodeUseDoubleQuotes" },{ "trigger": "NSMouseInRect \t func unknown -> Bool" , "contents": "NSMouseInRect(${1:NSPoint}, _:${2:NSRect}, _:${3:Bool})" },{ "trigger": "wait \t func NSCondition -> void" , "contents": "wait(${1:})" },{ "trigger": "NSAffineTransformStruct \t NSAffineTransformStruct", "contents": "NSAffineTransformStruct" },{ "trigger": "substringWithRange \t func NSString -> String" , "contents": "substringWithRange(${1:NSRange})" },{ "trigger": "NSDateFormatter \t NSDateFormatter", "contents": "NSDateFormatter" },{ "trigger": "hasSpaceAvailable \t Bool", "contents": "hasSpaceAvailable" },{ "trigger": "encodeValueOfObjCType \t func NSCoder -> void" , "contents": "encodeValueOfObjCType(${1:UnsafePointer<Int8>}, at:${2:UnsafePointer<Void>})" },{ "trigger": "NSCompoundPredicateType \t NSCompoundPredicateType", "contents": "NSCompoundPredicateType" },{ "trigger": "setData \t func NSMutableData -> void" , "contents": "setData(${1:NSData})" },{ "trigger": "NSProgressEstimatedTimeRemainingKey \t String", "contents": "NSProgressEstimatedTimeRemainingKey" },{ "trigger": "uploadTaskWithRequest \t func NSURLSession -> Void" , "contents": "uploadTaskWithRequest(${1:NSURLRequest}, fromFile:${2:NSURL}, completionHandler:${3:NSData?}, NSURLResponse?:${4:}, NSError?:${5:})" },{ "trigger": "NSPropertyListMutabilityOptions \t rawValue:" , "contents": "NSPropertyListMutabilityOptions(${1:UInt})" },{ "trigger": "NSXMLDocument \t XMLString: options:" , "contents": "NSXMLDocument(XMLString:${1:String}, options:${2:Int})" },{ "trigger": "NSLocaleVariantCode \t String", "contents": "NSLocaleVariantCode" },{ "trigger": "NSCharacterSet.punctuationCharacterSet \t class NSCharacterSet -> NSCharacterSet" , "contents": "NSCharacterSet.punctuationCharacterSet(${1:})" },{ "trigger": "NSStreamNetworkServiceTypeVoIP \t String", "contents": "NSStreamNetworkServiceTypeVoIP" },{ "trigger": "NSTimer \t fireDate: interval: repeats: fire:" , "contents": "NSTimer(${1:NSDate}, interval:${2:NSTimeInterval}, repeats:${3:Bool}, fire:${4:NSTimer -> Void })" },{ "trigger": "NSHTTPCookieValue \t String", "contents": "NSHTTPCookieValue" },{ "trigger": "authenticationMethod \t String", "contents": "authenticationMethod" },{ "trigger": "NSXMLNode.commentWithStringValue \t class NSXMLNode -> AnyObject" , "contents": "NSXMLNode.commentWithStringValue(${1:String})" },{ "trigger": "rangeOfCharacterFromSet \t func NSString -> NSRange" , "contents": "rangeOfCharacterFromSet(${1:NSCharacterSet}, options:${2:NSStringCompareOptions}, range:${3:NSRange})" },{ "trigger": "HTTPCookieStorage \t NSHTTPCookieStorage", "contents": "HTTPCookieStorage" },{ "trigger": "decimalNumberByMultiplyingByPowerOf10 \t func NSDecimalNumber -> NSDecimalNumber" , "contents": "decimalNumberByMultiplyingByPowerOf10(${1:Int16}, withBehavior:${2:NSDecimalNumberBehaviors?})" },{ "trigger": "NSString \t bytesNoCopy: length: encoding: freeWhenDone:" , "contents": "NSString(bytesNoCopy:${1:UnsafeMutablePointer<Void>}, length:${2:Int}, encoding:${3:UInt}, freeWhenDone:${4:Bool})" },{ "trigger": "copyWithZone \t func NSNotification -> AnyObject" , "contents": "copyWithZone(${1:NSZone})" },{ "trigger": "NSUnionRange \t func unknown -> NSRange" , "contents": "NSUnionRange(${1:NSRange}, _:${2:NSRange})" },{ "trigger": "NSEnergyFormatterUnit \t NSEnergyFormatterUnit", "contents": "NSEnergyFormatterUnit" },{ "trigger": "NSLengthFormatter \t NSLengthFormatter", "contents": "NSLengthFormatter" },{ "trigger": "timeIntervalSinceNow \t NSTimeInterval", "contents": "timeIntervalSinceNow" },{ "trigger": "NSURLErrorCannotFindHost \t Int", "contents": "NSURLErrorCannotFindHost" },{ "trigger": "NSFileSystemSize \t String", "contents": "NSFileSystemSize" },{ "trigger": "NSMutableArray \t contentsOfURL:" , "contents": "NSMutableArray(contentsOfURL:${1:NSURL})" },{ "trigger": "NSPropertyListSerialization.propertyList \t class NSPropertyListSerialization -> Bool" , "contents": "NSPropertyListSerialization.propertyList(${1:AnyObject}, isValidForFormat:${2:NSPropertyListFormat})" },{ "trigger": "truncateFileAtOffset \t func NSFileHandle -> void" , "contents": "truncateFileAtOffset(${1:UInt64})" },{ "trigger": "NSCondition \t :" , "contents": "NSCondition(${1:})" },{ "trigger": "resourceSpecifier \t String", "contents": "resourceSpecifier" },{ "trigger": "NSDateIntervalFormatterStyle \t NSDateIntervalFormatterStyle", "contents": "NSDateIntervalFormatterStyle" },{ "trigger": "setProperty \t func NSStream -> Bool" , "contents": "setProperty(${1:AnyObject?}, forKey:${2:String})" },{ "trigger": "NSString.defaultCStringEncoding \t class NSString -> UInt" , "contents": "NSString.defaultCStringEncoding(${1:})" },{ "trigger": "middleName \t String", "contents": "middleName" },{ "trigger": "dataUsingEncoding \t func NSString -> NSData?" , "contents": "dataUsingEncoding(${1:UInt}, allowLossyConversion:${2:Bool})" },{ "trigger": "hasSuffix \t func String -> Bool" , "contents": "hasSuffix(${1:String})" },{ "trigger": "NSEdgeInsets \t top: left: bottom: right:" , "contents": "NSEdgeInsets(${1:CGFloat}, left:${2:CGFloat}, bottom:${3:CGFloat}, right:${4:CGFloat})" },{ "trigger": "NSOperatingSystemVersion \t NSOperatingSystemVersion", "contents": "NSOperatingSystemVersion" },{ "trigger": "NSPersonNameComponentMiddleName \t String", "contents": "NSPersonNameComponentMiddleName" },{ "trigger": "NSSet \t set: copyItems:" , "contents": "NSSet(${1:Set<NSObject>}, copyItems:${2:Bool})" },{ "trigger": "NSIndexSet.supportsSecureCoding \t static NSIndexSet -> Bool" , "contents": "NSIndexSet.supportsSecureCoding(${1:})" },{ "trigger": "NSFileManagerItemReplacementOptions \t NSFileManagerItemReplacementOptions", "contents": "NSFileManagerItemReplacementOptions" },{ "trigger": "NSHTTPCookieStorage \t :" , "contents": "NSHTTPCookieStorage(${1:})" },{ "trigger": "isDateInWeekend \t func NSCalendar -> Bool" , "contents": "isDateInWeekend(${1:NSDate})" },{ "trigger": "NSNull \t :" , "contents": "NSNull(${1:})" },{ "trigger": "deleteCharactersInRange \t func NSMutableString -> void" , "contents": "deleteCharactersInRange(${1:NSRange})" },{ "trigger": "allowedUnits \t NSCalendarUnit", "contents": "allowedUnits" },{ "trigger": "percentSymbol \t String", "contents": "percentSymbol" },{ "trigger": "NSTask \t NSTask", "contents": "NSTask" },{ "trigger": "abbreviation \t String", "contents": "abbreviation" },{ "trigger": "containsString \t func String -> Bool" , "contents": "containsString(${1:String})" },{ "trigger": "NSEqualRects \t func unknown -> Bool" , "contents": "NSEqualRects(${1:NSRect}, _:${2:NSRect})" },{ "trigger": "componentsSeparatedByCharactersInSet \t func NSString -> [String]" , "contents": "componentsSeparatedByCharactersInSet(${1:NSCharacterSet})" },{ "trigger": "NSDateInterval \t start: interval:" , "contents": "NSDateInterval(${1:NSDate}, interval:${2:NSTimeInterval})" },{ "trigger": "sharedFrameworksPath \t String", "contents": "sharedFrameworksPath" },{ "trigger": "encodeWithCoder \t func NSURLProtectionSpace -> void" , "contents": "encodeWithCoder(${1:NSCoder})" },{ "trigger": "interval \t NSTimeInterval", "contents": "interval" },{ "trigger": "NSCharacterSet.URLPathAllowedCharacterSet \t class NSCharacterSet -> NSCharacterSet" , "contents": "NSCharacterSet.URLPathAllowedCharacterSet(${1:})" },{ "trigger": "CGPoint \t :" , "contents": "CGPoint(${1:})" },{ "trigger": "NSNotificationCoalescing \t rawValue:" , "contents": "NSNotificationCoalescing(${1:UInt})" },{ "trigger": "includesActualByteCount \t Bool", "contents": "includesActualByteCount" },{ "trigger": "startLoading \t func NSURLProtocol -> void" , "contents": "startLoading(${1:})" },{ "trigger": "removeObjectsInRange \t func NSMutableArray -> void" , "contents": "removeObjectsInRange(${1:NSRange})" },{ "trigger": "decomposedStringWithCanonicalMapping \t String", "contents": "decomposedStringWithCanonicalMapping" },{ "trigger": "NSURLRequest.supportsSecureCoding \t static NSURLRequest -> Bool" , "contents": "NSURLRequest.supportsSecureCoding(${1:})" },{ "trigger": "indexWithOptions \t func NSIndexSet -> Bool" , "contents": "indexWithOptions(${1:NSEnumerationOptions}, passingTest:${2:Int}, UnsafeMutablePointer<ObjCBool>:${3:})" },{ "trigger": "sessionOnly \t Bool", "contents": "sessionOnly" },{ "trigger": "NSPort \t NSPort", "contents": "NSPort" },{ "trigger": "fileSystemRepresentation \t UnsafePointer", "contents": "fileSystemRepresentation" },{ "trigger": "NSURLAuthenticationChallenge \t coder:" , "contents": "NSURLAuthenticationChallenge(coder:${1:NSCoder})" },{ "trigger": "copyWithZone \t func NSIndexPath -> AnyObject" , "contents": "copyWithZone(${1:NSZone})" },{ "trigger": "NSProgress \t parent: userInfo:" , "contents": "NSProgress(parent:${1:NSProgress?}, userInfo:${2:[NSObject })" },{ "trigger": "NSDirectoryEnumerationOptions \t rawValue:" , "contents": "NSDirectoryEnumerationOptions(${1:UInt})" },{ "trigger": "unknown \t unicodeScalarLiteral:" , "contents": "unknown(unicodeScalarLiteral:${1:UnicodeScalar})" },{ "trigger": "NSURLComponents \t :" , "contents": "NSURLComponents(${1:})" },{ "trigger": "variable \t String", "contents": "variable" },{ "trigger": "lenient \t Bool", "contents": "lenient" },{ "trigger": "replacementObjectForKeyedArchiver \t func NSObject -> AnyObject?" , "contents": "replacementObjectForKeyedArchiver(${1:NSKeyedArchiver})" },{ "trigger": "charactersToBeSkipped \t NSCharacterSet", "contents": "charactersToBeSkipped" },{ "trigger": "volatileDomainForName \t func NSUserDefaults -> [String" , "contents": "volatileDomainForName(${1:String})" },{ "trigger": "removeChildAtIndex \t func NSXMLElement -> void" , "contents": "removeChildAtIndex(${1:Int})" },{ "trigger": "== \t func unknown -> Bool" , "contents": "==(${1:NSXMLNode.Index}, rhs:${2:NSXMLNode.Index})" },{ "trigger": "comment \t String", "contents": "comment" },{ "trigger": "NSNumberFormatterRoundingMode \t NSNumberFormatterRoundingMode", "contents": "NSNumberFormatterRoundingMode" },{ "trigger": "NSURLErrorBadURL \t Int", "contents": "NSURLErrorBadURL" },{ "trigger": "NSURLAuthenticationMethodNegotiate \t String", "contents": "NSURLAuthenticationMethodNegotiate" },{ "trigger": "rightExpression \t NSExpression", "contents": "rightExpression" },{ "trigger": "indexAtPosition \t func NSIndexPath -> Int" , "contents": "indexAtPosition(${1:Int})" },{ "trigger": "NSString \t string:" , "contents": "NSString(string:${1:String})" },{ "trigger": "NSURLProtocol.canonicalRequestForRequest \t class NSURLProtocol -> NSURLRequest" , "contents": "NSURLProtocol.canonicalRequestForRequest(${1:NSURLRequest})" },{ "trigger": "NSStreamSocketSecurityLevelKey \t String", "contents": "NSStreamSocketSecurityLevelKey" },{ "trigger": "_bridgeToObject \t func Bool -> NSNumber" , "contents": "_bridgeToObject(${1:})" },{ "trigger": "isExecutableError \t Bool", "contents": "isExecutableError" },{ "trigger": "appendAttributedString \t func NSMutableAttributedString -> void" , "contents": "appendAttributedString(${1:NSAttributedString})" },{ "trigger": "defaultDate \t NSDate", "contents": "defaultDate" },{ "trigger": "decodeBytesForKey \t func NSCoder -> UnsafePointer UInt8 " , "contents": "decodeBytesForKey(${1:String}, returnedLength:${2:UnsafeMutablePointer<Int>})" },{ "trigger": "encodeRect \t func NSCoder -> void" , "contents": "encodeRect(${1:NSRect})" },{ "trigger": "NSXMLElement \t name: stringValue:" , "contents": "NSXMLElement(${1:String}, stringValue:${2:String?})" },{ "trigger": "descriptionWithLocale \t func NSDecimalNumber -> String" , "contents": "descriptionWithLocale(${1:AnyObject?})" },{ "trigger": "options \t NSRegularExpressionOptions", "contents": "options" },{ "trigger": "NSURLProtectionSpace.supportsSecureCoding \t static NSURLProtectionSpace -> Bool" , "contents": "NSURLProtectionSpace.supportsSecureCoding(${1:})" },{ "trigger": "localizedRecoverySuggestion \t String", "contents": "localizedRecoverySuggestion" },{ "trigger": "NSPOSIXErrorDomain \t String", "contents": "NSPOSIXErrorDomain" },{ "trigger": "lowercaseStringWithLocale \t func NSString -> String" , "contents": "lowercaseStringWithLocale(${1:NSLocale?})" },{ "trigger": "NSDate \t timeIntervalSinceReferenceDate:" , "contents": "NSDate(timeIntervalSinceReferenceDate:${1:NSTimeInterval})" },{ "trigger": "NSURLSessionTask \t NSURLSessionTask", "contents": "NSURLSessionTask" },{ "trigger": "NSJSONSerialization.writeJSONObject \t class NSJSONSerialization -> Int" , "contents": "NSJSONSerialization.writeJSONObject(${1:AnyObject}, toStream:${2:NSOutputStream}, options:${3:NSJSONWritingOptions})" },{ "trigger": "invalidateAndCancel \t func NSURLSession -> void" , "contents": "invalidateAndCancel(${1:})" },{ "trigger": "state \t NSURLSessionTaskState", "contents": "state" },{ "trigger": "formIntersectionWithCharacterSet \t func NSMutableCharacterSet -> void" , "contents": "formIntersectionWithCharacterSet(${1:NSCharacterSet})" },{ "trigger": "NSTimeZone \t forSecondsFromGMT:" , "contents": "NSTimeZone(forSecondsFromGMT:${1:Int})" },{ "trigger": "NSSearchPathDirectory \t NSSearchPathDirectory", "contents": "NSSearchPathDirectory" },{ "trigger": "attribute \t func NSAttributedString -> AnyObject?" , "contents": "attribute(${1:String}, atIndex:${2:Int}, effectiveRange:${3:NSRangePointer})" },{ "trigger": "isDateInYesterday \t func NSCalendar -> Bool" , "contents": "isDateInYesterday(${1:NSDate})" },{ "trigger": "isEqualToHost \t func NSHost -> Bool" , "contents": "isEqualToHost(${1:NSHost})" },{ "trigger": "rotateByDegrees \t func NSAffineTransform -> void" , "contents": "rotateByDegrees(${1:CGFloat})" },{ "trigger": "NSHost.currentHost \t class NSHost -> NSHost" , "contents": "NSHost.currentHost(${1:})" },{ "trigger": "NSCachedURLResponse \t response: data:" , "contents": "NSCachedURLResponse(${1:NSURLResponse}, data:${2:NSData})" },{ "trigger": "hasMemberInPlane \t func NSCharacterSet -> Bool" , "contents": "hasMemberInPlane(${1:UInt8})" },{ "trigger": "waitForDataInBackgroundAndNotify \t func NSFileHandle -> void" , "contents": "waitForDataInBackgroundAndNotify(${1:})" },{ "trigger": "NSFileHandleReadCompletionNotification \t String", "contents": "NSFileHandleReadCompletionNotification" },{ "trigger": "NSURLSessionDownloadTaskResumeData \t String", "contents": "NSURLSessionDownloadTaskResumeData" },{ "trigger": "setChildren \t func NSXMLDTD -> void" , "contents": "setChildren(${1:[NSXMLNode]?})" },{ "trigger": "NSXMLDTD \t contentsOfURL: options:" , "contents": "NSXMLDTD(contentsOfURL:${1:NSURL}, options:${2:Int})" },{ "trigger": "copyWithZone \t func NSURLCredential -> AnyObject" , "contents": "copyWithZone(${1:NSZone})" },{ "trigger": "rangeOfUser \t NSRange", "contents": "rangeOfUser" },{ "trigger": "NSPropertyListMutabilityOptions \t NSPropertyListMutabilityOptions", "contents": "NSPropertyListMutabilityOptions" },{ "trigger": "replaceBytesInRange \t func NSMutableData -> void" , "contents": "replaceBytesInRange(${1:NSRange}, withBytes:${2:UnsafePointer<Void>})" },{ "trigger": "NSHTTPCookieStorage.sharedCookieStorageForGroupContainerIdentifier \t class NSHTTPCookieStorage -> NSHTTPCookieStorage" , "contents": "NSHTTPCookieStorage.sharedCookieStorageForGroupContainerIdentifier(${1:String})" },{ "trigger": "debugDescription \t String", "contents": "debugDescription" },{ "trigger": "NSURLErrorKey \t String", "contents": "NSURLErrorKey" },{ "trigger": "size \t CGSize", "contents": "size" },{ "trigger": "processIdentifier \t Int", "contents": "processIdentifier" },{ "trigger": "evaluateWithObject \t func NSPredicate -> Bool" , "contents": "evaluateWithObject(${1:AnyObject?}, substitutionVariables:${2:[String })" },{ "trigger": "destinationOfSymbolicLinkAtPath \t func NSFileManager -> String" , "contents": "destinationOfSymbolicLinkAtPath(${1:String})" },{ "trigger": "NSOperationQueue.mainQueue \t class NSOperationQueue -> NSOperationQueue" , "contents": "NSOperationQueue.mainQueue(${1:})" },{ "trigger": "objectsPassingTest \t func NSSet -> Bool" , "contents": "objectsPassingTest(${1:AnyObject}, UnsafeMutablePointer<ObjCBool>:${2:})" },{ "trigger": "encodeWithCoder \t func NSSortDescriptor -> void" , "contents": "encodeWithCoder(${1:NSCoder})" },{ "trigger": "URLByDeletingPathExtension \t NSURL", "contents": "URLByDeletingPathExtension" },{ "trigger": "NSURLErrorUnknown \t Int", "contents": "NSURLErrorUnknown" },{ "trigger": "NSURLErrorUserAuthenticationRequired \t Int", "contents": "NSURLErrorUserAuthenticationRequired" },{ "trigger": "HTTPShouldUsePipelining \t Bool", "contents": "HTTPShouldUsePipelining" },{ "trigger": "NSCalendarOptions \t rawValue:" , "contents": "NSCalendarOptions(${1:UInt})" },{ "trigger": "createDirectoryAtURL \t func NSFileManager -> void" , "contents": "createDirectoryAtURL(${1:NSURL}, withIntermediateDirectories:${2:Bool}, attributes:${3:[String })" },{ "trigger": "countOfIndexesInRange \t func NSIndexSet -> Int" , "contents": "countOfIndexesInRange(${1:NSRange})" },{ "trigger": "NSUserDefaults \t :" , "contents": "NSUserDefaults(${1:})" },{ "trigger": "currentMode \t String", "contents": "currentMode" },{ "trigger": "dateByAddingComponents \t func NSCalendar -> NSDate?" , "contents": "dateByAddingComponents(${1:NSDateComponents}, toDate:${2:NSDate}, options:${3:NSCalendarOptions})" },{ "trigger": "NSDateComponentsFormatterUnitsStyle \t NSDateComponentsFormatterUnitsStyle", "contents": "NSDateComponentsFormatterUnitsStyle" },{ "trigger": "NSXMLDocument \t data: options:" , "contents": "NSXMLDocument(${1:NSData}, options:${2:Int})" },{ "trigger": "decimalNumberByMultiplyingBy \t func NSDecimalNumber -> NSDecimalNumber" , "contents": "decimalNumberByMultiplyingBy(${1:NSDecimalNumber}, withBehavior:${2:NSDecimalNumberBehaviors?})" },{ "trigger": "NSCharacterSet.decomposableCharacterSet \t class NSCharacterSet -> NSCharacterSet" , "contents": "NSCharacterSet.decomposableCharacterSet(${1:})" },{ "trigger": "XMLString \t String", "contents": "XMLString" },{ "trigger": "indexesOfObjectsAtIndexes \t func Generator -> Bool" , "contents": "indexesOfObjectsAtIndexes(${1:NSIndexSet}, options:${2:NSEnumerationOptions}, passingTest:${3:AnyObject}, Int:${4:}, UnsafeMutablePointer<ObjCBool>:${5:})" },{ "trigger": "encodeWithCoder \t func NSURLResponse -> void" , "contents": "encodeWithCoder(${1:NSCoder})" },{ "trigger": "childAtIndex \t func NSXMLNode -> NSXMLNode?" , "contents": "childAtIndex(${1:Int})" },{ "trigger": "NSObject.classForKeyedUnarchiver \t class NSObject -> AnyClass" , "contents": "NSObject.classForKeyedUnarchiver(${1:})" },{ "trigger": "supportsSecureCoding \t func NSAttributedString -> Bool" , "contents": "supportsSecureCoding(${1:})" },{ "trigger": "NSURLRelationship \t NSURLRelationship", "contents": "NSURLRelationship" },{ "trigger": "NSMutableString \t string:" , "contents": "NSMutableString(string:${1:String})" },{ "trigger": "NSFileHandle \t coder:" , "contents": "NSFileHandle(${1:NSCoder})" },{ "trigger": "NSSocketPort \t NSSocketPort", "contents": "NSSocketPort" },{ "trigger": "lastPathComponent \t String", "contents": "lastPathComponent" },{ "trigger": "NSTask.launchedTaskWithLaunchPath \t class NSTask -> NSTask" , "contents": "NSTask.launchedTaskWithLaunchPath(${1:String}, arguments:${2:[String]})" },{ "trigger": "changeCurrentDirectoryPath \t func NSFileManager -> Bool" , "contents": "changeCurrentDirectoryPath(${1:String})" },{ "trigger": "lineNumber \t Int", "contents": "lineNumber" },{ "trigger": "NSURLErrorUserCancelledAuthentication \t Int", "contents": "NSURLErrorUserCancelledAuthentication" },{ "trigger": "attributesOfItemAtPath \t func NSFileManager -> [String" , "contents": "attributesOfItemAtPath(${1:String})" },{ "trigger": "attributeForName \t func NSXMLElement -> NSXMLNode?" , "contents": "attributeForName(${1:String})" },{ "trigger": "NSString.availableStringEncodings \t class NSString -> UnsafePointer UInt " , "contents": "NSString.availableStringEncodings(${1:})" },{ "trigger": "Generator \t contentsOfURL:" , "contents": "Generator(contentsOfURL:${1:NSURL})" },{ "trigger": "nilSymbol \t String", "contents": "nilSymbol" },{ "trigger": "roundingBehavior \t NSDecimalNumberHandler", "contents": "roundingBehavior" },{ "trigger": "NSURLErrorCannotConnectToHost \t Int", "contents": "NSURLErrorCannotConnectToHost" },{ "trigger": "scanHexLongLong \t func NSScanner -> UInt64?" , "contents": "scanHexLongLong(${1:})" },{ "trigger": "writeToURL \t func NSString -> void" , "contents": "writeToURL(${1:NSURL}, atomically:${2:Bool}, encoding:${3:UInt})" },{ "trigger": "percentEncodedFragment \t String", "contents": "percentEncodedFragment" },{ "trigger": "NSCompoundPredicate \t andPredicateWithSubpredicates:" , "contents": "NSCompoundPredicate(andPredicateWithSubpredicates:${1:[NSPredicate]})" },{ "trigger": "NSFileSystemFreeSize \t String", "contents": "NSFileSystemFreeSize" },{ "trigger": "addSuiteNamed \t func NSUserDefaults -> void" , "contents": "addSuiteNamed(${1:String})" },{ "trigger": "URLForKey \t func NSUserDefaults -> NSURL?" , "contents": "URLForKey(${1:String})" },{ "trigger": "encodeWithCoder \t func NSURLRequest -> void" , "contents": "encodeWithCoder(${1:NSCoder})" },{ "trigger": "decodeBoolForKey \t func NSCoder -> Bool" , "contents": "decodeBoolForKey(${1:String})" },{ "trigger": "resume \t func NSURLSessionTask -> void" , "contents": "resume(${1:})" },{ "trigger": "filteredOrderedSetUsingPredicate \t func NSOrderedSet -> NSOrderedSet" , "contents": "filteredOrderedSetUsingPredicate(${1:NSPredicate})" },{ "trigger": "bridge \t func Set -> NSSet" , "contents": "bridge(${1:})" },{ "trigger": "containsIndex \t func NSIndexSet -> Bool" , "contents": "containsIndex(${1:Int})" },{ "trigger": "downloadTaskWithURL \t func NSURLSession -> Void" , "contents": "downloadTaskWithURL(${1:NSURL}, completionHandler:${2:NSURL?}, NSURLResponse?:${3:}, NSError?:${4:})" },{ "trigger": "copyWithZone \t func NSURLRequest -> AnyObject" , "contents": "copyWithZone(${1:NSZone})" },{ "trigger": "NSXMLDocumentTidyXML \t Int", "contents": "NSXMLDocumentTidyXML" },{ "trigger": "isEqualToSet \t func NSSet -> Bool" , "contents": "isEqualToSet(${1:Set<NSObject>})" },{ "trigger": "cancelled \t Bool", "contents": "cancelled" },{ "trigger": "NSString \t format: locale: arguments:" , "contents": "NSString(${1:String}, locale:${2:AnyObject?}, arguments:${3:CVaListPointer})" },{ "trigger": "documentContentKind \t NSXMLDocumentContentKind", "contents": "documentContentKind" },{ "trigger": "NSURLErrorFailingURLPeerTrustErrorKey \t String", "contents": "NSURLErrorFailingURLPeerTrustErrorKey" },{ "trigger": "NSLocale \t NSLocale", "contents": "NSLocale" },{ "trigger": "NSXMLDTD.predefinedEntityDeclarationForName \t class NSXMLDTD -> NSXMLDTDNode?" , "contents": "NSXMLDTD.predefinedEntityDeclarationForName(${1:String})" },{ "trigger": "descriptionInStringsFileFormat \t String", "contents": "descriptionInStringsFileFormat" },{ "trigger": "numberFormatter \t NSNumberFormatter", "contents": "numberFormatter" },{ "trigger": "sendPort \t NSPort", "contents": "sendPort" },{ "trigger": "NSLocale \t localeIdentifier:" , "contents": "NSLocale(localeIdentifier:${1:String})" },{ "trigger": "NSStream \t :" , "contents": "NSStream(${1:})" },{ "trigger": "cancel \t func NSURLSessionTask -> void" , "contents": "cancel(${1:})" },{ "trigger": "NSThread.callStackSymbols \t class NSThread -> [String]" , "contents": "NSThread.callStackSymbols(${1:})" },{ "trigger": "locale \t NSLocale", "contents": "locale" },{ "trigger": "cancel \t func NSProgress -> void" , "contents": "cancel(${1:})" },{ "trigger": "CGFloat \t CGFloat", "contents": "CGFloat" },{ "trigger": "numberFromString \t func NSNumberFormatter -> NSNumber?" , "contents": "numberFromString(${1:String})" },{ "trigger": "NSDateInterval \t NSDateInterval", "contents": "NSDateInterval" },{ "trigger": "terminate \t func NSTask -> void" , "contents": "terminate(${1:})" },{ "trigger": "NSLocale.preferredLanguages \t class NSLocale -> [String]" , "contents": "NSLocale.preferredLanguages(${1:})" },{ "trigger": "sharedFrameworksURL \t NSURL", "contents": "sharedFrameworksURL" },{ "trigger": "NSURLResponse \t NSURLResponse", "contents": "NSURLResponse" },{ "trigger": "maximumSignificantDigits \t Int", "contents": "maximumSignificantDigits" },{ "trigger": "enumerateMatchesInString \t func NSRegularExpression -> Void" , "contents": "enumerateMatchesInString(${1:String}, options:${2:NSMatchingOptions}, range:${3:NSRange}, usingBlock:${4:NSTextCheckingResult?}, NSMatchingFlags:${5:}, UnsafeMutablePointer<ObjCBool>:${6:})" },{ "trigger": "statusCode \t Int", "contents": "statusCode" },{ "trigger": "NSInsetRect \t func unknown -> NSRect" , "contents": "NSInsetRect(${1:NSRect}, _:${2:CGFloat}, _:${3:CGFloat})" },{ "trigger": "setFloat \t func NSUserDefaults -> void" , "contents": "setFloat(${1:Float}, forKey:${2:String})" },{ "trigger": "host \t String", "contents": "host" },{ "trigger": "NSDecimalNumber \t bytes: objCType:" , "contents": "NSDecimalNumber(bytes:${1:UnsafePointer<Void>}, objCType:${2:UnsafePointer<Int8>})" },{ "trigger": "NSStreamSocketSecurityLevelNegotiatedSSL \t String", "contents": "NSStreamSocketSecurityLevelNegotiatedSSL" },{ "trigger": "NSPointInRect \t func unknown -> Bool" , "contents": "NSPointInRect(${1:NSPoint}, _:${2:NSRect})" },{ "trigger": "NSXMLElement \t kind: options:" , "contents": "NSXMLElement(${1:NSXMLNodeKind}, options:${2:Int})" },{ "trigger": "isEqual \t func NSObject -> Bool" , "contents": "isEqual(${1:AnyObject?})" },{ "trigger": "sharedSupportPath \t String", "contents": "sharedSupportPath" },{ "trigger": "NSStreamEvent \t rawValue:" , "contents": "NSStreamEvent(${1:UInt})" },{ "trigger": "captureStreams \t func NSURLSessionStreamTask -> void" , "contents": "captureStreams(${1:})" },{ "trigger": "compare \t func NSNumber -> NSComparisonResult" , "contents": "compare(${1:NSNumber})" },{ "trigger": "NSUUID \t NSUUID", "contents": "NSUUID" },{ "trigger": "completePathIntoString \t func NSString -> Int" , "contents": "completePathIntoString(inout:${1:NSString?}, caseSensitive:${2:Bool}, inout:${3:[NSString]}, filterTypes:${4:[String]?})" },{ "trigger": "Generator \t contentsOfFile:" , "contents": "Generator(contentsOfFile:${1:String})" },{ "trigger": "removeObjectIdenticalTo \t func NSMutableArray -> void" , "contents": "removeObjectIdenticalTo(${1:AnyObject})" },{ "trigger": "setValue \t func NSDateComponents -> void" , "contents": "setValue(${1:Int}, forComponent:${2:NSCalendarUnit})" },{ "trigger": "decodeObjectOfClasses \t func NSCoder -> AnyObject?" , "contents": "decodeObjectOfClasses(${1:[AnyClass]}, forKey:${2:String})" },{ "trigger": "NSLocaleCountryCode \t String", "contents": "NSLocaleCountryCode" },{ "trigger": "removeAllObjects \t func NSMutableSet -> void" , "contents": "removeAllObjects(${1:})" },{ "trigger": "mutableCopyWithZone \t func NSSet -> AnyObject" , "contents": "mutableCopyWithZone(${1:NSZone})" },{ "trigger": "setByAddingObjectsFromArray \t func NSSet -> Set NSObject " , "contents": "setByAddingObjectsFromArray(${1:[AnyObject]})" },{ "trigger": "writeToFile \t func NSString -> void" , "contents": "writeToFile(${1:String}, atomically:${2:Bool}, encoding:${3:UInt})" },{ "trigger": "removeObserver \t func NSNotificationCenter -> void" , "contents": "removeObserver(${1:AnyObject}, name:${2:String?}, object:${3:AnyObject?})" },{ "trigger": "NSURLErrorNetworkConnectionLost \t Int", "contents": "NSURLErrorNetworkConnectionLost" },{ "trigger": "encodeWithCoder \t func NSUUID -> void" , "contents": "encodeWithCoder(${1:NSCoder})" },{ "trigger": "NSXMLParserError \t NSXMLParserError", "contents": "NSXMLParserError" },{ "trigger": "objectIsForcedForKey \t func NSUserDefaults -> Bool" , "contents": "objectIsForcedForKey(${1:String}, inDomain:${2:String})" },{ "trigger": "NSDecimalNumber.notANumber \t class NSDecimalNumber -> NSDecimalNumber" , "contents": "NSDecimalNumber.notANumber(${1:})" },{ "trigger": "NSLocalizedRecoveryOptionsErrorKey \t String", "contents": "NSLocalizedRecoveryOptionsErrorKey" },{ "trigger": "NSNumber \t unsignedInteger:" , "contents": "NSNumber(unsignedInteger:${1:UInt})" },{ "trigger": "scanLongLong \t func NSScanner -> Bool" , "contents": "scanLongLong(${1:UnsafeMutablePointer<Int64>})" },{ "trigger": "recoveryAttempter \t AnyObject", "contents": "recoveryAttempter" },{ "trigger": "NSOperationQueueDefaultMaxConcurrentOperationCount \t Int", "contents": "NSOperationQueueDefaultMaxConcurrentOperationCount" },{ "trigger": "NSMutableSet \t :" , "contents": "NSMutableSet(${1:})" },{ "trigger": "NSCalendarOptions \t NSCalendarOptions", "contents": "NSCalendarOptions" },{ "trigger": "paragraphRangeForRange \t func NSString -> NSRange" , "contents": "paragraphRangeForRange(${1:NSRange})" },{ "trigger": "NSIntersectionRect \t func unknown -> NSRect" , "contents": "NSIntersectionRect(${1:NSRect}, _:${2:NSRect})" },{ "trigger": "absolutePath \t Bool", "contents": "absolutePath" },{ "trigger": "invalidate \t func NSPort -> void" , "contents": "invalidate(${1:})" },{ "trigger": "startIndex \t Index", "contents": "startIndex" },{ "trigger": "stringsByAppendingPaths \t func String -> [String]" , "contents": "stringsByAppendingPaths(${1:[String]})" },{ "trigger": "CGRect \t origin: size:" , "contents": "CGRect(${1:CGPoint}, size:${2:CGSize})" },{ "trigger": "NSFileHandle \t forWritingToURL:" , "contents": "NSFileHandle(forWritingToURL:${1:NSURL})" },{ "trigger": "perMillSymbol \t String", "contents": "perMillSymbol" },{ "trigger": "NSOperation \t :" , "contents": "NSOperation(${1:})" },{ "trigger": "removeObjectsAtIndexes \t func NSMutableOrderedSet -> void" , "contents": "removeObjectsAtIndexes(${1:NSIndexSet})" },{ "trigger": "removeIndexes \t func NSMutableIndexSet -> void" , "contents": "removeIndexes(${1:NSIndexSet})" },{ "trigger": "== \t func unknown -> Bool" , "contents": "==(${1:CGRect}, rhs:${2:CGRect})" },{ "trigger": "CGRect \t :" , "contents": "CGRect(${1:})" },{ "trigger": "Int._forceBridgeFromObject \t static Int -> void" , "contents": "Int._forceBridgeFromObject(${1:NSNumber}, inout:${2:Int?})" },{ "trigger": "NSCharacterSet.URLHostAllowedCharacterSet \t class NSCharacterSet -> NSCharacterSet" , "contents": "NSCharacterSet.URLHostAllowedCharacterSet(${1:})" },{ "trigger": "countOfBytesSent \t Int", "contents": "countOfBytesSent" },{ "trigger": "rangeOfQuery \t NSRange", "contents": "rangeOfQuery" },{ "trigger": "NSMatchingFlags \t rawValue:" , "contents": "NSMatchingFlags(${1:UInt})" },{ "trigger": "NSDate \t timeIntervalSinceNow:" , "contents": "NSDate(timeIntervalSinceNow:${1:NSTimeInterval})" },{ "trigger": "developmentLocalization \t String", "contents": "developmentLocalization" },{ "trigger": "date \t NSDate", "contents": "date" },{ "trigger": "decimalNumberByAdding \t func NSDecimalNumber -> NSDecimalNumber" , "contents": "decimalNumberByAdding(${1:NSDecimalNumber})" },{ "trigger": "- \t func unknown -> CGFloat" , "contents": "-(${1:CGFloat}, rhs:${2:CGFloat})" },{ "trigger": "NSLengthFormatterUnit \t NSLengthFormatterUnit", "contents": "NSLengthFormatterUnit" },{ "trigger": "NSNumberFormatter.localizedStringFromNumber \t class NSNumberFormatter -> String" , "contents": "NSNumberFormatter.localizedStringFromNumber(${1:NSNumber}, numberStyle:${2:NSNumberFormatterStyle})" },{ "trigger": "stopLoading \t func NSURLProtocol -> void" , "contents": "stopLoading(${1:})" },{ "trigger": "NSFilePathErrorKey \t String", "contents": "NSFilePathErrorKey" },{ "trigger": "data \t NSData", "contents": "data" },{ "trigger": "NSDateIntervalFormatter \t :" , "contents": "NSDateIntervalFormatter(${1:})" },{ "trigger": "NSDecimalNumber.zero \t class NSDecimalNumber -> NSDecimalNumber" , "contents": "NSDecimalNumber.zero(${1:})" },{ "trigger": "setVolatileDomain \t func NSUserDefaults -> void" , "contents": "setVolatileDomain(${1:[String }, forName:${2:String})" },{ "trigger": "allowedExternalEntityURLs \t Set", "contents": "allowedExternalEntityURLs" },{ "trigger": "CGPoint \t x: y:" , "contents": "CGPoint(${1:CGFloat}, y:${2:CGFloat})" },{ "trigger": "evictsObjectsWithDiscardedContent \t Bool", "contents": "evictsObjectsWithDiscardedContent" },{ "trigger": "encodeWithCoder \t func NSDateComponents -> void" , "contents": "encodeWithCoder(${1:NSCoder})" },{ "trigger": "sizeValue \t NSSize", "contents": "sizeValue" },{ "trigger": "bridge \t func NSSet -> Set NSObject " , "contents": "bridge(${1:})" },{ "trigger": "unlock \t func NSRecursiveLock -> void" , "contents": "unlock(${1:})" },{ "trigger": "NSIndexPath.supportsSecureCoding \t static NSIndexPath -> Bool" , "contents": "NSIndexPath.supportsSecureCoding(${1:})" },{ "trigger": "NSDateFormatterStyle \t NSDateFormatterStyle", "contents": "NSDateFormatterStyle" },{ "trigger": "sortUsingDescriptors \t func NSMutableOrderedSet -> void" , "contents": "sortUsingDescriptors(${1:[NSSortDescriptor]})" },{ "trigger": "NSMinY \t func unknown -> CGFloat" , "contents": "NSMinY(${1:NSRect})" },{ "trigger": "NSMassFormatter \t NSMassFormatter", "contents": "NSMassFormatter" },{ "trigger": "nextDateAfterDate \t func NSCalendar -> NSDate?" , "contents": "nextDateAfterDate(${1:NSDate}, matchingUnit:${2:NSCalendarUnit}, value:${3:Int}, options:${4:NSCalendarOptions})" },{ "trigger": "addChild \t func NSProgress -> void" , "contents": "addChild(${1:NSProgress}, withPendingUnitCount:${2:Int64})" },{ "trigger": "reversedOrderedSet \t NSOrderedSet", "contents": "reversedOrderedSet" },{ "trigger": "waitForDataInBackgroundAndNotifyForModes \t func NSFileHandle -> void" , "contents": "waitForDataInBackgroundAndNotifyForModes(${1:[String]?})" },{ "trigger": "NSDecimalNumberOverflowException \t String", "contents": "NSDecimalNumberOverflowException" },{ "trigger": "rangeValue \t NSRange", "contents": "rangeValue" },{ "trigger": "NSURLErrorServerCertificateUntrusted \t Int", "contents": "NSURLErrorServerCertificateUntrusted" },{ "trigger": "date \t func NSCalendar -> Bool" , "contents": "date(${1:NSDate}, matchesComponents:${2:NSDateComponents})" },{ "trigger": "`self` \t func NSObject -> Self" , "contents": "`self`(${1:})" },{ "trigger": "NSLocaleDecimalSeparator \t String", "contents": "NSLocaleDecimalSeparator" },{ "trigger": "copyWithZone \t func NSLocale -> AnyObject" , "contents": "copyWithZone(${1:NSZone})" },{ "trigger": "enumerateObjectsAtIndexes \t func NSOrderedSet -> Void" , "contents": "enumerateObjectsAtIndexes(${1:NSIndexSet}, options:${2:NSEnumerationOptions}, usingBlock:${3:AnyObject}, Int:${4:}, UnsafeMutablePointer<ObjCBool>:${5:})" },{ "trigger": "NSOrderedSet \t orderedSet: range: copyItems:" , "contents": "NSOrderedSet(orderedSet:${1:NSOrderedSet}, range:${2:NSRange}, copyItems:${3:Bool})" },{ "trigger": "NSPersonNameComponentDelimiter \t String", "contents": "NSPersonNameComponentDelimiter" },{ "trigger": "NSMutableArray \t NSMutableArray", "contents": "NSMutableArray" },{ "trigger": "writeToFile \t func Generator -> Bool" , "contents": "writeToFile(${1:String}, atomically:${2:Bool})" },{ "trigger": "NSKeyedUnarchiver.setClass \t class NSKeyedUnarchiver -> void" , "contents": "NSKeyedUnarchiver.setClass(${1:AnyClass?}, forClassName:${2:String})" },{ "trigger": "NSXMLNode.attributeWithName \t class NSXMLNode -> AnyObject" , "contents": "NSXMLNode.attributeWithName(${1:String}, stringValue:${2:String})" },{ "trigger": "NSDecimalNoScale \t Int", "contents": "NSDecimalNoScale" },{ "trigger": "removeObject \t func NSMutableArray -> void" , "contents": "removeObject(${1:AnyObject})" },{ "trigger": "NSURLSessionAuthChallengeDisposition \t NSURLSessionAuthChallengeDisposition", "contents": "NSURLSessionAuthChallengeDisposition" },{ "trigger": "y \t CGFloat", "contents": "y" },{ "trigger": "enumerateSubstringsInRange \t func NSString -> Void" , "contents": "enumerateSubstringsInRange(${1:NSRange}, options:${2:NSStringEnumerationOptions}, usingBlock:${3:String?}, NSRange:${4:}, NSRange:${5:}, UnsafeMutablePointer<ObjCBool>:${6:})" },{ "trigger": "regularExpression \t NSRegularExpression", "contents": "regularExpression" },{ "trigger": "fileSystemRepresentation \t func String -> [CChar]" , "contents": "fileSystemRepresentation(${1:})" },{ "trigger": "mutableCopyWithZone \t func NSCharacterSet -> AnyObject" , "contents": "mutableCopyWithZone(${1:NSZone})" },{ "trigger": "NSFileBusy \t String", "contents": "NSFileBusy" },{ "trigger": "NSFileHandle.fileHandleWithNullDevice \t class NSFileHandle -> NSFileHandle" , "contents": "NSFileHandle.fileHandleWithNullDevice(${1:})" },{ "trigger": "NSURLSessionTransferSizeUnknown \t Int", "contents": "NSURLSessionTransferSizeUnknown" },{ "trigger": "getFileSystemRepresentation \t func NSURL -> Bool" , "contents": "getFileSystemRepresentation(${1:UnsafeMutablePointer<Int8>}, maxLength:${2:Int})" },{ "trigger": "index \t Int", "contents": "index" },{ "trigger": "attributedStringForNotANumber \t NSAttributedString", "contents": "attributedStringForNotANumber" },{ "trigger": "queuePriority \t NSOperationQueuePriority", "contents": "queuePriority" },{ "trigger": "expressionValueWithObject \t func NSExpression -> AnyObject" , "contents": "expressionValueWithObject(${1:AnyObject?}, context:${2:NSMutableDictionary?})" },{ "trigger": "NSLocaleCalendarIdentifier \t String", "contents": "NSLocaleCalendarIdentifier" },{ "trigger": "hostName \t String", "contents": "hostName" },{ "trigger": "NSUUID \t :" , "contents": "NSUUID(${1:})" },{ "trigger": "NSData \t bytes: length:" , "contents": "NSData(${1:UnsafePointer<Void>}, length:${2:Int})" },{ "trigger": "unsignedCharValue \t UInt", "contents": "unsignedCharValue" },{ "trigger": "NSXMLDocument \t NSXMLDocument", "contents": "NSXMLDocument" },{ "trigger": "NSFileSystemFreeNodes \t String", "contents": "NSFileSystemFreeNodes" },{ "trigger": "indexInRange \t func NSIndexSet -> Bool" , "contents": "indexInRange(${1:NSRange}, options:${2:NSEnumerationOptions}, passingTest:${3:Int}, UnsafeMutablePointer<ObjCBool>:${4:})" },{ "trigger": "contentsAtPath \t func NSFileManager -> NSData?" , "contents": "contentsAtPath(${1:String})" },{ "trigger": "NSUserDefaults \t suiteName:" , "contents": "NSUserDefaults(suiteName:${1:String?})" },{ "trigger": "NSXMLNodeUseSingleQuotes \t Int", "contents": "NSXMLNodeUseSingleQuotes" },{ "trigger": "NSOffsetRect \t func unknown -> NSRect" , "contents": "NSOffsetRect(${1:NSRect}, _:${2:CGFloat}, _:${3:CGFloat})" },{ "trigger": "dataTaskWithRequest \t func NSURLSession -> NSURLSessionDataTask" , "contents": "dataTaskWithRequest(${1:NSURLRequest})" },{ "trigger": "NSURLCredentialStorageChangedNotification \t String", "contents": "NSURLCredentialStorageChangedNotification" },{ "trigger": "encodeSize \t func NSCoder -> void" , "contents": "encodeSize(${1:NSSize})" },{ "trigger": "Set._conditionallyBridgeFromObject \t static Set -> Bool" , "contents": "Set._conditionallyBridgeFromObject(${1:NSSet}, inout:${2:Set?})" },{ "trigger": "hashValue \t Int", "contents": "hashValue" },{ "trigger": "enumerateKeysAndObjectsUsingBlock \t func Generator -> Void" , "contents": "enumerateKeysAndObjectsUsingBlock(${1:NSObject}, AnyObject:${2:}, UnsafeMutablePointer<ObjCBool>:${3:})" },{ "trigger": "replaceMatchesInString \t func NSRegularExpression -> Int" , "contents": "replaceMatchesInString(${1:NSMutableString}, options:${2:NSMatchingOptions}, range:${3:NSRange}, withTemplate:${4:String})" },{ "trigger": "addObjectsFromArray \t func NSMutableOrderedSet -> void" , "contents": "addObjectsFromArray(${1:[AnyObject]})" },{ "trigger": "NSFileTypeCharacterSpecial \t String", "contents": "NSFileTypeCharacterSpecial" },{ "trigger": "NSString \t charactersNoCopy: length: freeWhenDone:" , "contents": "NSString(charactersNoCopy:${1:UnsafeMutablePointer<unichar>}, length:${2:Int}, freeWhenDone:${3:Bool})" },{ "trigger": "encodeDataObject \t func NSCoder -> void" , "contents": "encodeDataObject(${1:NSData})" },{ "trigger": "NSDecimalNumberDivideByZeroException \t String", "contents": "NSDecimalNumberDivideByZeroException" },{ "trigger": "cachedResponse \t NSCachedURLResponse", "contents": "cachedResponse" },{ "trigger": "URLForResource \t func NSBundle -> NSURL?" , "contents": "URLForResource(${1:String?}, withExtension:${2:String?})" },{ "trigger": "subpathsAtPath \t func NSFileManager -> [String]?" , "contents": "subpathsAtPath(${1:String})" },{ "trigger": "NSURLErrorInternationalRoamingOff \t Int", "contents": "NSURLErrorInternationalRoamingOff" },{ "trigger": "NSString.pathWithComponents \t static NSString -> String" , "contents": "NSString.pathWithComponents(${1:[String]})" },{ "trigger": "NSDecimalNumber \t booleanLiteral:" , "contents": "NSDecimalNumber(booleanLiteral:${1:Bool})" },{ "trigger": "NSURLCache \t memoryCapacity: diskCapacity: diskPath:" , "contents": "NSURLCache(${1:Int}, diskCapacity:${2:Int}, diskPath:${3:String?})" },{ "trigger": "NSStreamSOCKSProxyConfigurationKey \t String", "contents": "NSStreamSOCKSProxyConfigurationKey" },{ "trigger": "nameSuffix \t String", "contents": "nameSuffix" },{ "trigger": "daylightSavingTimeOffsetForDate \t func NSTimeZone -> NSTimeInterval" , "contents": "daylightSavingTimeOffsetForDate(${1:NSDate})" },{ "trigger": "NSNonLossyASCIIStringEncoding \t UInt", "contents": "NSNonLossyASCIIStringEncoding" },{ "trigger": "commentURL \t NSURL", "contents": "commentURL" },{ "trigger": "NSXMLDTDNode \t XMLString:" , "contents": "NSXMLDTDNode(XMLString:${1:String})" },{ "trigger": "URLRelativeToURL \t func NSURLComponents -> NSURL?" , "contents": "URLRelativeToURL(${1:NSURL?})" },{ "trigger": "NSValue \t edgeInsets:" , "contents": "NSValue(edgeInsets:${1:NSEdgeInsets})" },{ "trigger": "objectValue \t func NSNumberFormatter -> AnyObject?" , "contents": "objectValue(${1:String}, inout:${2:NSRange})" },{ "trigger": "reverseObjectEnumerator \t func NSOrderedSet -> NSEnumerator" , "contents": "reverseObjectEnumerator(${1:})" },{ "trigger": "Generator \t dictionaryLiteral: AnyObject...:" , "contents": "Generator(dictionaryLiteral:${1:NSObject}, AnyObject...:${2:})" },{ "trigger": "NSDirectoryEnumerationOptions \t NSDirectoryEnumerationOptions", "contents": "NSDirectoryEnumerationOptions" },{ "trigger": "setBool \t func NSUserDefaults -> void" , "contents": "setBool(${1:Bool}, forKey:${2:String})" },{ "trigger": "caseSensitive \t Bool", "contents": "caseSensitive" },{ "trigger": "currentDiskUsage \t Int", "contents": "currentDiskUsage" },{ "trigger": "postNotification \t func NSNotificationCenter -> void" , "contents": "postNotification(${1:NSNotification})" },{ "trigger": "readToEndOfFileInBackgroundAndNotifyForModes \t func NSFileHandle -> void" , "contents": "readToEndOfFileInBackgroundAndNotifyForModes(${1:[String]?})" },{ "trigger": "NSScanner \t NSScanner", "contents": "NSScanner" },{ "trigger": "load \t func NSBundle -> Bool" , "contents": "load(${1:})" },{ "trigger": "NSTimeZone.supportsSecureCoding \t static NSTimeZone -> Bool" , "contents": "NSTimeZone.supportsSecureCoding(${1:})" },{ "trigger": "NSFileManager.defaultManager \t class NSFileManager -> NSFileManager" , "contents": "NSFileManager.defaultManager(${1:})" },{ "trigger": "enumerateIndexesUsingBlock \t func NSIndexSet -> Void" , "contents": "enumerateIndexesUsingBlock(${1:Int}, UnsafeMutablePointer<ObjCBool>:${2:})" },{ "trigger": "unitStringFromJoules \t func NSEnergyFormatter -> String" , "contents": "unitStringFromJoules(${1:Double}, usedUnit:${2:UnsafeMutablePointer<NSEnergyFormatterUnit>})" },{ "trigger": "filterUsingPredicate \t func NSMutableSet -> void" , "contents": "filterUsingPredicate(${1:NSPredicate})" },{ "trigger": "NSEdgeInsets \t NSEdgeInsets", "contents": "NSEdgeInsets" },{ "trigger": "NSSet \t object:" , "contents": "NSSet(${1:AnyObject})" },{ "trigger": "removeObserver \t func NSNotificationCenter -> void" , "contents": "removeObserver(${1:AnyObject})" },{ "trigger": "unsignedLongValue \t UInt", "contents": "unsignedLongValue" },{ "trigger": "finished \t Bool", "contents": "finished" },{ "trigger": "unload \t func NSBundle -> Bool" , "contents": "unload(${1:})" },{ "trigger": "NSCalendarIdentifierIslamicUmmAlQura \t String", "contents": "NSCalendarIdentifierIslamicUmmAlQura" },{ "trigger": "PMSymbol \t String", "contents": "PMSymbol" },{ "trigger": "stringFromValue \t func NSMassFormatter -> String" , "contents": "stringFromValue(${1:Double}, unit:${2:NSMassFormatterUnit})" },{ "trigger": "NSURLSessionTaskState \t NSURLSessionTaskState", "contents": "NSURLSessionTaskState" },{ "trigger": "contentsOfDirectoryAtPath \t func NSFileManager -> [String]" , "contents": "contentsOfDirectoryAtPath(${1:String})" },{ "trigger": "NSIndexSet \t NSIndexSet", "contents": "NSIndexSet" },{ "trigger": "NSPersonNameComponentsFormatterOptions \t NSPersonNameComponentsFormatterOptions", "contents": "NSPersonNameComponentsFormatterOptions" },{ "trigger": "dateFromComponents \t func NSCalendar -> NSDate?" , "contents": "dateFromComponents(${1:NSDateComponents})" },{ "trigger": "insertObject \t func NSMutableArray -> void" , "contents": "insertObject(${1:AnyObject}, atIndex:${2:Int})" },{ "trigger": "NSByteCountFormatter \t :" , "contents": "NSByteCountFormatter(${1:})" },{ "trigger": "copyWithZone \t func NSNull -> AnyObject" , "contents": "copyWithZone(${1:NSZone})" },{ "trigger": "enumerateObjectsUsingBlock \t func NSOrderedSet -> Void" , "contents": "enumerateObjectsUsingBlock(${1:AnyObject}, Int:${2:}, UnsafeMutablePointer<ObjCBool>:${3:})" },{ "trigger": "defaultCredentialForProtectionSpace \t func NSURLCredentialStorage -> NSURLCredential?" , "contents": "defaultCredentialForProtectionSpace(${1:NSURLProtectionSpace})" },{ "trigger": "NSURLErrorDownloadDecodingFailedToComplete \t Int", "contents": "NSURLErrorDownloadDecodingFailedToComplete" },{ "trigger": "stringByAppendingPathExtension \t func String -> String?" , "contents": "stringByAppendingPathExtension(${1:String})" },{ "trigger": "NSURLAuthenticationMethodHTMLForm \t String", "contents": "NSURLAuthenticationMethodHTMLForm" },{ "trigger": "replaceObjectsInRange \t func NSMutableArray -> void" , "contents": "replaceObjectsInRange(${1:NSRange}, withObjectsFromArray:${2:[AnyObject]})" },{ "trigger": "encodeRect \t func NSCoder -> void" , "contents": "encodeRect(${1:NSRect}, forKey:${2:String})" },{ "trigger": "NSLocaleCollationIdentifier \t String", "contents": "NSLocaleCollationIdentifier" },{ "trigger": "NSURLComponents \t URL: resolvingAgainstBaseURL:" , "contents": "NSURLComponents(URL:${1:NSURL}, resolvingAgainstBaseURL:${2:Bool})" },{ "trigger": "NSXMLNode.elementWithName \t class NSXMLNode -> AnyObject" , "contents": "NSXMLNode.elementWithName(${1:String}, children:${2:[NSXMLNode]?}, attributes:${3:[NSXMLNode]?})" },{ "trigger": "NSProgressFileURLKey \t String", "contents": "NSProgressFileURLKey" },{ "trigger": "NSConditionLock \t :" , "contents": "NSConditionLock(${1:})" },{ "trigger": "NSURLCredential \t NSURLCredential", "contents": "NSURLCredential" },{ "trigger": "encodeWithCoder \t func NSDate -> void" , "contents": "encodeWithCoder(${1:NSCoder})" },{ "trigger": "NSMutableCharacterSet \t NSMutableCharacterSet", "contents": "NSMutableCharacterSet" },{ "trigger": "addIndex \t func NSMutableIndexSet -> void" , "contents": "addIndex(${1:Int})" },{ "trigger": "NSURLErrorCallIsActive \t Int", "contents": "NSURLErrorCallIsActive" },{ "trigger": "String \t format: arguments:" , "contents": "String(${1:String}, arguments:${2:[CVarArgType]})" },{ "trigger": "NSDecimalNumber.one \t class NSDecimalNumber -> NSDecimalNumber" , "contents": "NSDecimalNumber.one(${1:})" },{ "trigger": "encodeWithCoder \t func NSExpression -> void" , "contents": "encodeWithCoder(${1:NSCoder})" },{ "trigger": "memoryCapacity \t Int", "contents": "memoryCapacity" },{ "trigger": "processName \t String", "contents": "processName" },{ "trigger": "length \t Int", "contents": "length" },{ "trigger": "NSStream.getStreamsToHostWithName \t class NSStream -> void" , "contents": "NSStream.getStreamsToHostWithName(${1:String}, port:${2:Int}, inputStream:${3:AutoreleasingUnsafeMutablePointer<NSInputStream?>}, outputStream:${4:AutoreleasingUnsafeMutablePointer<NSOutputStream?>})" },{ "trigger": "addPort \t func NSRunLoop -> void" , "contents": "addPort(${1:NSPort}, forMode:${2:String})" },{ "trigger": "NSHelpAnchorErrorKey \t String", "contents": "NSHelpAnchorErrorKey" },{ "trigger": "NSError \t domain: code: userInfo:" , "contents": "NSError(${1:String}, code:${2:Int}, userInfo:${3:[String })" },{ "trigger": "decimalNumberBySubtracting \t func NSDecimalNumber -> NSDecimalNumber" , "contents": "decimalNumberBySubtracting(${1:NSDecimalNumber}, withBehavior:${2:NSDecimalNumberBehaviors?})" },{ "trigger": "NSDecimalNumberUnderflowException \t String", "contents": "NSDecimalNumberUnderflowException" },{ "trigger": "NSMassFormatter \t coder:" , "contents": "NSMassFormatter(${1:NSCoder})" },{ "trigger": "UInt._conditionallyBridgeFromObject \t static UInt -> Bool" , "contents": "UInt._conditionallyBridgeFromObject(${1:NSNumber}, inout:${2:UInt?})" },{ "trigger": "attributedStringForZero \t NSAttributedString", "contents": "attributedStringForZero" },{ "trigger": "NSCachedURLResponse \t response: data: userInfo: storagePolicy:" , "contents": "NSCachedURLResponse(${1:NSURLResponse}, data:${2:NSData}, userInfo:${3:[NSObject }, storagePolicy:${4:NSURLCacheStoragePolicy})" },{ "trigger": "NSXMLNode.DTDNodeWithXMLString \t class NSXMLNode -> AnyObject?" , "contents": "NSXMLNode.DTDNodeWithXMLString(${1:String})" },{ "trigger": "signal \t func NSCondition -> void" , "contents": "signal(${1:})" },{ "trigger": "encodeWithCoder \t func NSError -> void" , "contents": "encodeWithCoder(${1:NSCoder})" },{ "trigger": "copyItemAtURL \t func NSFileManager -> void" , "contents": "copyItemAtURL(${1:NSURL}, toURL:${2:NSURL})" },{ "trigger": "function \t String", "contents": "function" },{ "trigger": "getObjects \t func Generator -> void" , "contents": "getObjects(inout:${1:[AnyObject]}, inout:${2:[AnyObject]}, count:${3:Int})" },{ "trigger": "NSDecimalNumber \t string:" , "contents": "NSDecimalNumber(string:${1:String?})" },{ "trigger": "helpAnchor \t String", "contents": "helpAnchor" },{ "trigger": "formatWidth \t Int", "contents": "formatWidth" },{ "trigger": "isValidationError \t Bool", "contents": "isValidationError" },{ "trigger": "stringWithFileSystemRepresentation \t func NSFileManager -> String" , "contents": "stringWithFileSystemRepresentation(${1:UnsafePointer<Int8>}, length:${2:Int})" },{ "trigger": "getIndexes \t func NSIndexSet -> Int" , "contents": "getIndexes(${1:UnsafeMutablePointer<Int>}, maxCount:${2:Int}, inIndexRange:${3:NSRangePointer})" },{ "trigger": "NSURLCredential \t forTrust:" , "contents": "NSURLCredential(forTrust:${1:SecTrust})" },{ "trigger": "unitStyle \t NSFormattingUnitStyle", "contents": "unitStyle" },{ "trigger": "NSXMLNode \t NSXMLNode", "contents": "NSXMLNode" },{ "trigger": "NSXMLNode.localNameForName \t class NSXMLNode -> String" , "contents": "NSXMLNode.localNameForName(${1:String})" },{ "trigger": "NSSet \t coder:" , "contents": "NSSet(coder:${1:NSCoder})" },{ "trigger": "NSURLSessionConfiguration.ephemeralSessionConfiguration \t class NSURLSessionConfiguration -> NSURLSessionConfiguration" , "contents": "NSURLSessionConfiguration.ephemeralSessionConfiguration(${1:})" },{ "trigger": "NSPredicate \t value:" , "contents": "NSPredicate(${1:Bool})" },{ "trigger": "NSPredicate \t format: argumentArray:" , "contents": "NSPredicate(format:${1:String}, argumentArray:${2:[AnyObject]?})" },{ "trigger": "getCachedResponseForDataTask \t func NSURLCache -> Void" , "contents": "getCachedResponseForDataTask(${1:NSURLSessionDataTask}, completionHandler:${2:NSCachedURLResponse? -> Void})" },{ "trigger": "invertedSet \t NSCharacterSet", "contents": "invertedSet" },{ "trigger": "unionSet \t func NSMutableSet -> void" , "contents": "unionSet(${1:Set<NSObject>})" },{ "trigger": "NSFormatter \t NSFormatter", "contents": "NSFormatter" },{ "trigger": "rangeOfComposedCharacterSequencesForRange \t func NSString -> NSRange" , "contents": "rangeOfComposedCharacterSequencesForRange(${1:NSRange})" },{ "trigger": "dictionaryRepresentation \t func NSUserDefaults -> [String" , "contents": "dictionaryRepresentation(${1:})" },{ "trigger": "NSNotificationCenter.defaultCenter \t class NSNotificationCenter -> NSNotificationCenter" , "contents": "NSNotificationCenter.defaultCenter(${1:})" },{ "trigger": "NSXMLDocumentIncludeContentTypeDeclaration \t Int", "contents": "NSXMLDocumentIncludeContentTypeDeclaration" },{ "trigger": "gregorianStartDate \t NSDate", "contents": "gregorianStartDate" },{ "trigger": "NSAttributedStringEnumerationOptions \t rawValue:" , "contents": "NSAttributedStringEnumerationOptions(${1:UInt})" },{ "trigger": "UInt \t _:" , "contents": "UInt(_:${1:NSNumber})" },{ "trigger": "appendBytes \t func NSMutableData -> void" , "contents": "appendBytes(${1:UnsafePointer<Void>}, length:${2:Int})" },{ "trigger": "NSFilePosixPermissions \t String", "contents": "NSFilePosixPermissions" },{ "trigger": "NSQualityOfService \t NSQualityOfService", "contents": "NSQualityOfService" },{ "trigger": "NSFileHandleDataAvailableNotification \t String", "contents": "NSFileHandleDataAvailableNotification" },{ "trigger": "unitStringFromValue \t func NSLengthFormatter -> String" , "contents": "unitStringFromValue(${1:Double}, unit:${2:NSLengthFormatterUnit})" },{ "trigger": "mutableCopyWithZone \t func NSURLRequest -> AnyObject" , "contents": "mutableCopyWithZone(${1:NSZone})" },{ "trigger": "encodeWithCoder \t func NSValue -> void" , "contents": "encodeWithCoder(${1:NSCoder})" },{ "trigger": "nextDateAfterDate \t func NSCalendar -> NSDate?" , "contents": "nextDateAfterDate(${1:NSDate}, matchingHour:${2:Int}, minute:${3:Int}, second:${4:Int}, options:${5:NSCalendarOptions})" },{ "trigger": "dateStyle \t NSDateIntervalFormatterStyle", "contents": "dateStyle" },{ "trigger": "NSMutableDictionary \t contentsOfURL:" , "contents": "NSMutableDictionary(contentsOfURL:${1:NSURL})" },{ "trigger": "Double \t _:" , "contents": "Double(_:${1:CGFloat})" },{ "trigger": "isDateInToday \t func NSCalendar -> Bool" , "contents": "isDateInToday(${1:NSDate})" },{ "trigger": "compare \t func NSIndexPath -> NSComparisonResult" , "contents": "compare(${1:NSIndexPath})" },{ "trigger": "msgid \t UInt", "contents": "msgid" },{ "trigger": "NSStringFromSize \t func unknown -> String" , "contents": "NSStringFromSize(${1:NSSize})" },{ "trigger": "NSCalendarIdentifierIslamicCivil \t String", "contents": "NSCalendarIdentifierIslamicCivil" },{ "trigger": "NSDecimalIsNotANumber \t func unknown -> Bool" , "contents": "NSDecimalIsNotANumber(${1:UnsafePointer<NSDecimal>})" },{ "trigger": "mutableCopy \t func NSMutableCopying -> AnyObject" , "contents": "mutableCopy(${1:})" },{ "trigger": "NSURLErrorDataNotAllowed \t Int", "contents": "NSURLErrorDataNotAllowed" },{ "trigger": "scanDouble \t func NSScanner -> Bool" , "contents": "scanDouble(${1:UnsafeMutablePointer<Double>})" },{ "trigger": "NSHTTPCookieCommentURL \t String", "contents": "NSHTTPCookieCommentURL" },{ "trigger": "Int._conditionallyBridgeFromObject \t static Int -> Bool" , "contents": "Int._conditionallyBridgeFromObject(${1:NSNumber}, inout:${2:Int?})" },{ "trigger": "NSLocaleExemplarCharacterSet \t String", "contents": "NSLocaleExemplarCharacterSet" },{ "trigger": "getEra \t func NSCalendar -> void" , "contents": "getEra(${1:UnsafeMutablePointer<Int>}, year:${2:UnsafeMutablePointer<Int>}, month:${3:UnsafeMutablePointer<Int>}, day:${4:UnsafeMutablePointer<Int>}, fromDate:${5:NSDate})" },{ "trigger": "NSHost \t NSHost", "contents": "NSHost" },{ "trigger": "Bool \t _:" , "contents": "Bool(_:${1:NSNumber})" },{ "trigger": "NSHost \t name:" , "contents": "NSHost(${1:String?})" },{ "trigger": "NSFileType \t String", "contents": "NSFileType" },{ "trigger": "NSXMLDTDNode \t NSXMLDTDNode", "contents": "NSXMLDTDNode" },{ "trigger": "NSURLErrorUnsupportedURL \t Int", "contents": "NSURLErrorUnsupportedURL" },{ "trigger": "user \t String", "contents": "user" },{ "trigger": "NSString \t format: _:" , "contents": "NSString(${1:NSString}, _:${2:CVarArgType...})" },{ "trigger": "addExecutionBlock \t func NSBlockOperation -> Void" , "contents": "addExecutionBlock(${1: -> Void})" },{ "trigger": "NSRegularExpressionOptions \t rawValue:" , "contents": "NSRegularExpressionOptions(${1:UInt})" },{ "trigger": "writeToURL \t func Generator -> Bool" , "contents": "writeToURL(${1:NSURL}, atomically:${2:Bool})" },{ "trigger": "decodeRect \t func NSCoder -> NSRect" , "contents": "decodeRect(${1:})" },{ "trigger": "timeInterval \t NSTimeInterval", "contents": "timeInterval" },{ "trigger": "copyWithZone \t func NSURLQueryItem -> AnyObject" , "contents": "copyWithZone(${1:NSZone})" },{ "trigger": "launch \t func NSTask -> void" , "contents": "launch(${1:})" },{ "trigger": "executableURL \t NSURL", "contents": "executableURL" },{ "trigger": "scanInt \t func NSScanner -> Bool" , "contents": "scanInt(${1:UnsafeMutablePointer<Int32>})" },{ "trigger": "NSLock \t NSLock", "contents": "NSLock" },{ "trigger": "encodeArrayOfObjCType \t func NSCoder -> void" , "contents": "encodeArrayOfObjCType(${1:UnsafePointer<Int8>}, count:${2:Int}, at:${3:UnsafePointer<Void>})" },{ "trigger": "NSLocationInRange \t func unknown -> Bool" , "contents": "NSLocationInRange(${1:Int}, _:${2:NSRange})" },{ "trigger": "finishDecoding \t func NSKeyedUnarchiver -> void" , "contents": "finishDecoding(${1:})" },{ "trigger": "setDefaultCredential \t func NSURLCredentialStorage -> void" , "contents": "setDefaultCredential(${1:NSURLCredential}, forProtectionSpace:${2:NSURLProtectionSpace}, task:${3:NSURLSessionTask})" },{ "trigger": "NSCurrentLocaleDidChangeNotification \t String", "contents": "NSCurrentLocaleDidChangeNotification" },{ "trigger": "characterAtIndex \t func NSString -> unichar" , "contents": "characterAtIndex(${1:Int})" },{ "trigger": "getFileSystemRepresentation \t func NSString -> Bool" , "contents": "getFileSystemRepresentation(${1:UnsafeMutablePointer<Int8>}, maxLength:${2:Int})" },{ "trigger": "resume \t func NSTask -> Bool" , "contents": "resume(${1:})" },{ "trigger": "NSFileHandleConnectionAcceptedNotification \t String", "contents": "NSFileHandleConnectionAcceptedNotification" },{ "trigger": "getObjects \t func Generator -> void" , "contents": "getObjects(inout:${1:[AnyObject]}, range:${2:NSRange})" },{ "trigger": "NSValue \t point:" , "contents": "NSValue(${1:NSPoint})" },{ "trigger": "decimalNumberByDividingBy \t func NSDecimalNumber -> NSDecimalNumber" , "contents": "decimalNumberByDividingBy(${1:NSDecimalNumber}, withBehavior:${2:NSDecimalNumberBehaviors?})" },{ "trigger": "NSFileOwnerAccountName \t String", "contents": "NSFileOwnerAccountName" },{ "trigger": "copyWithZone \t func NSAttributedString -> AnyObject" , "contents": "copyWithZone(${1:NSZone})" },{ "trigger": "NSProgressThroughputKey \t String", "contents": "NSProgressThroughputKey" },{ "trigger": "builtInPlugInsPath \t String", "contents": "builtInPlugInsPath" },{ "trigger": "NSXMLNodePreserveAll \t Int", "contents": "NSXMLNodePreserveAll" },{ "trigger": "Double \t _:" , "contents": "Double(_:${1:NSNumber})" },{ "trigger": "NSURLAuthenticationChallenge \t protectionSpace: proposedCredential: previousFailureCount: failureResponse: error:" , "contents": "NSURLAuthenticationChallenge(protectionSpace:${1:NSURLProtectionSpace}, proposedCredential:${2:NSURLCredential?}, previousFailureCount:${3:Int}, failureResponse:${4:NSURLResponse?}, error:${5:NSError?})" },{ "trigger": "description \t String", "contents": "description" },{ "trigger": "readDataToEndOfFile \t func NSFileHandle -> NSData" , "contents": "readDataToEndOfFile(${1:})" },{ "trigger": "name \t String", "contents": "name" },{ "trigger": "constantValue \t AnyObject", "contents": "constantValue" },{ "trigger": "NSFileTypeSymbolicLink \t String", "contents": "NSFileTypeSymbolicLink" },{ "trigger": "NSString \t bytes: length: encoding:" , "contents": "NSString(${1:UnsafePointer<Void>}, length:${2:Int}, encoding:${3:UInt})" },{ "trigger": "encodeConditionalObject \t func NSCoder -> void" , "contents": "encodeConditionalObject(${1:AnyObject?})" },{ "trigger": "moveItemAtURL \t func NSFileManager -> void" , "contents": "moveItemAtURL(${1:NSURL}, toURL:${2:NSURL})" },{ "trigger": "downloadTaskWithURL \t func NSURLSession -> NSURLSessionDownloadTask" , "contents": "downloadTaskWithURL(${1:NSURL})" },{ "trigger": "dataForKey \t func NSUserDefaults -> NSData?" , "contents": "dataForKey(${1:String})" },{ "trigger": "enqueueNotification \t func NSNotificationQueue -> void" , "contents": "enqueueNotification(${1:NSNotification}, postingStyle:${2:NSPostingStyle})" },{ "trigger": "NSUUID \t UUIDBytes:" , "contents": "NSUUID(UUIDBytes:${1:UnsafePointer<UInt8>})" },{ "trigger": "copyWithZone \t func NSPersonNameComponents -> AnyObject" , "contents": "copyWithZone(${1:NSZone})" },{ "trigger": "asynchronous \t Bool", "contents": "asynchronous" },{ "trigger": "NSNumberFormatter \t NSNumberFormatter", "contents": "NSNumberFormatter" },{ "trigger": "localizedCompare \t func NSString -> NSComparisonResult" , "contents": "localizedCompare(${1:String})" },{ "trigger": "NSNumber \t floatLiteral:" , "contents": "NSNumber(floatLiteral:${1:Double})" },{ "trigger": "plusSign \t String", "contents": "plusSign" },{ "trigger": "twoDigitStartDate \t NSDate", "contents": "twoDigitStartDate" },{ "trigger": "cancelAllOperations \t func NSOperationQueue -> void" , "contents": "cancelAllOperations(${1:})" },{ "trigger": "NSCharacterSet.symbolCharacterSet \t class NSCharacterSet -> NSCharacterSet" , "contents": "NSCharacterSet.symbolCharacterSet(${1:})" },{ "trigger": "code \t Int", "contents": "code" },{ "trigger": "NSEqualPoints \t func unknown -> Bool" , "contents": "NSEqualPoints(${1:NSPoint}, _:${2:NSPoint})" },{ "trigger": "addIndexes \t func NSMutableIndexSet -> void" , "contents": "addIndexes(${1:NSIndexSet})" },{ "trigger": "paused \t Bool", "contents": "paused" },{ "trigger": "NSPropertyListSerialization \t NSPropertyListSerialization", "contents": "NSPropertyListSerialization" },{ "trigger": "NSStringFromClass \t func unknown -> String" , "contents": "NSStringFromClass(${1:AnyClass})" },{ "trigger": "invert \t func NSMutableCharacterSet -> void" , "contents": "invert(${1:})" },{ "trigger": "dequeueNotificationsMatching \t func NSNotificationQueue -> void" , "contents": "dequeueNotificationsMatching(${1:NSNotification}, coalesceMask:${2:NSNotificationCoalescing})" },{ "trigger": "setAttributedString \t func NSMutableAttributedString -> void" , "contents": "setAttributedString(${1:NSAttributedString})" },{ "trigger": "allowEvaluation \t func NSPredicate -> void" , "contents": "allowEvaluation(${1:})" },{ "trigger": "NSConditionLock \t condition:" , "contents": "NSConditionLock(${1:Int})" },{ "trigger": "supportsSecureCoding \t func NSURLCredential -> Bool" , "contents": "supportsSecureCoding(${1:})" },{ "trigger": "pointValue \t NSPoint", "contents": "pointValue" },{ "trigger": "UInt._forceBridgeFromObject \t static UInt -> void" , "contents": "UInt._forceBridgeFromObject(${1:NSNumber}, inout:${2:UInt?})" },{ "trigger": "NSSet.supportsSecureCoding \t static NSSet -> Bool" , "contents": "NSSet.supportsSecureCoding(${1:})" },{ "trigger": "indeterminate \t Bool", "contents": "indeterminate" },{ "trigger": "nickname \t String", "contents": "nickname" },{ "trigger": "predicateFormat \t String", "contents": "predicateFormat" },{ "trigger": "invert \t func NSAffineTransform -> void" , "contents": "invert(${1:})" },{ "trigger": "NSThread.isMultiThreaded \t class NSThread -> Bool" , "contents": "NSThread.isMultiThreaded(${1:})" },{ "trigger": "NSHTTPCookie.cookiesWithResponseHeaderFields \t class NSHTTPCookie -> [NSHTTPCookie]" , "contents": "NSHTTPCookie.cookiesWithResponseHeaderFields(${1:[String }, forURL:${2:NSURL})" },{ "trigger": "descriptionWithLocale \t func NSOrderedSet -> String" , "contents": "descriptionWithLocale(${1:AnyObject?})" },{ "trigger": "NSFileHandleOperationException \t String", "contents": "NSFileHandleOperationException" },{ "trigger": "NSHTTPCookieName \t String", "contents": "NSHTTPCookieName" },{ "trigger": "deleteCharactersInRange \t func NSMutableAttributedString -> void" , "contents": "deleteCharactersInRange(${1:NSRange})" },{ "trigger": "lineRangeForRange \t func NSString -> NSRange" , "contents": "lineRangeForRange(${1:NSRange})" },{ "trigger": "NSMutableOrderedSet \t capacity:" , "contents": "NSMutableOrderedSet(capacity:${1:Int})" },{ "trigger": "NSEdgeInsets \t :" , "contents": "NSEdgeInsets(${1:})" },{ "trigger": "NSURLResponse \t URL: MIMEType: expectedContentLength: textEncodingName:" , "contents": "NSURLResponse(${1:NSURL}, MIMEType:${2:String?}, expectedContentLength:${3:Int}, textEncodingName:${4:String?})" },{ "trigger": "NSLocaleLanguageCode \t String", "contents": "NSLocaleLanguageCode" },{ "trigger": "NSThread \t NSThread", "contents": "NSThread" },{ "trigger": "NSCharacterSet.letterCharacterSet \t class NSCharacterSet -> NSCharacterSet" , "contents": "NSCharacterSet.letterCharacterSet(${1:})" },{ "trigger": "objectValue \t func NSDateFormatter -> AnyObject?" , "contents": "objectValue(${1:String}, range:${2:UnsafeMutablePointer<NSRange>})" },{ "trigger": "indexPathByRemovingLastIndex \t func NSIndexPath -> NSIndexPath" , "contents": "indexPathByRemovingLastIndex(${1:})" },{ "trigger": "NSTextCheckingResult \t :" , "contents": "NSTextCheckingResult(${1:})" },{ "trigger": "scanCharactersFromSet \t func NSScanner -> String?" , "contents": "scanCharactersFromSet(${1:NSCharacterSet})" },{ "trigger": "version \t String", "contents": "version" },{ "trigger": "unitsStyle \t NSDateComponentsFormatterUnitsStyle", "contents": "unitsStyle" },{ "trigger": "NSXMLElement \t NSXMLElement", "contents": "NSXMLElement" },{ "trigger": "numberOfMatchesInString \t func NSRegularExpression -> Int" , "contents": "numberOfMatchesInString(${1:String}, options:${2:NSMatchingOptions}, range:${3:NSRange})" },{ "trigger": "descriptionWithLocale \t func Generator -> String" , "contents": "descriptionWithLocale(${1:AnyObject?})" },{ "trigger": "stringByPaddingToLength \t func NSString -> String" , "contents": "stringByPaddingToLength(${1:Int}, withString:${2:String}, startingAtIndex:${3:Int})" },{ "trigger": "NSCache \t NSCache", "contents": "NSCache" },{ "trigger": "==T: \t func unknown -> Bool" , "contents": "==T:(${1:T}, rhs:${2:T})" },{ "trigger": "NSNotificationCenter \t :" , "contents": "NSNotificationCenter(${1:})" },{ "trigger": "zeroSymbol \t String", "contents": "zeroSymbol" },{ "trigger": "NSPersonNameComponentsFormatter \t NSPersonNameComponentsFormatter", "contents": "NSPersonNameComponentsFormatter" },{ "trigger": "NSLocalizedFailureReasonErrorKey \t String", "contents": "NSLocalizedFailureReasonErrorKey" },{ "trigger": "NSTimeZone.defaultTimeZone \t class NSTimeZone -> NSTimeZone" , "contents": "NSTimeZone.defaultTimeZone(${1:})" },{ "trigger": "NSHTTPURLResponse.localizedStringForStatusCode \t class NSHTTPURLResponse -> String" , "contents": "NSHTTPURLResponse.localizedStringForStatusCode(${1:Int})" },{ "trigger": "getUUIDBytes \t func NSUUID -> void" , "contents": "getUUIDBytes(${1:UnsafeMutablePointer<UInt8>})" },{ "trigger": "filterUsingPredicate \t func NSMutableOrderedSet -> void" , "contents": "filterUsingPredicate(${1:NSPredicate})" },{ "trigger": "setChildren \t func NSXMLDocument -> void" , "contents": "setChildren(${1:[NSXMLNode]?})" },{ "trigger": "encodeWithCoder \t func NSAttributedString -> void" , "contents": "encodeWithCoder(${1:NSCoder})" },{ "trigger": "collapsesLargestUnit \t Bool", "contents": "collapsesLargestUnit" },{ "trigger": "NSNull \t NSNull", "contents": "NSNull" },{ "trigger": "partialStringValidationEnabled \t Bool", "contents": "partialStringValidationEnabled" },{ "trigger": "resourcePath \t String", "contents": "resourcePath" },{ "trigger": "enumerateObjectsWithOptions \t func NSOrderedSet -> Void" , "contents": "enumerateObjectsWithOptions(${1:NSEnumerationOptions}, usingBlock:${2:AnyObject}, Int:${3:}, UnsafeMutablePointer<ObjCBool>:${4:})" },{ "trigger": "NSLocale.availableLocaleIdentifiers \t class NSLocale -> [String]" , "contents": "NSLocale.availableLocaleIdentifiers(${1:})" },{ "trigger": "setDefaultCredential \t func NSURLCredentialStorage -> void" , "contents": "setDefaultCredential(${1:NSURLCredential}, forProtectionSpace:${2:NSURLProtectionSpace})" },{ "trigger": "NSUUID.supportsSecureCoding \t static NSUUID -> Bool" , "contents": "NSUUID.supportsSecureCoding(${1:})" },{ "trigger": "parse \t func NSXMLParser -> Bool" , "contents": "parse(${1:})" },{ "trigger": "stringByDeletingLastPathComponent \t String", "contents": "stringByDeletingLastPathComponent" },{ "trigger": "NSError \t NSError", "contents": "NSError" },{ "trigger": "NSMakePoint \t func unknown -> NSPoint" , "contents": "NSMakePoint(${1:CGFloat}, _:${2:CGFloat})" },{ "trigger": "NSError.setUserInfoValueProviderForDomain \t class NSError -> AnyObject??" , "contents": "NSError.setUserInfoValueProviderForDomain(${1:String}, provider:${2:NSError}, String:${3:})" },{ "trigger": "NSEdgeInsetsMake \t func unknown -> NSEdgeInsets" , "contents": "NSEdgeInsetsMake(${1:CGFloat}, _:${2:CGFloat}, _:${3:CGFloat}, _:${4:CGFloat})" },{ "trigger": "NSURLAuthenticationMethodDefault \t String", "contents": "NSURLAuthenticationMethodDefault" },{ "trigger": "replaceChildAtIndex \t func NSXMLDTD -> void" , "contents": "replaceChildAtIndex(${1:Int}, withNode:${2:NSXMLNode})" },{ "trigger": "NSXMLNodePreserveCharacterReferences \t Int", "contents": "NSXMLNodePreserveCharacterReferences" },{ "trigger": "NSCalendarUnit \t NSCalendarUnit", "contents": "NSCalendarUnit" },{ "trigger": "earlierDate \t func NSDate -> NSDate" , "contents": "earlierDate(${1:NSDate})" },{ "trigger": "NSDecimalNumberExactnessException \t String", "contents": "NSDecimalNumberExactnessException" },{ "trigger": "encodeWithCoder \t func NSFileHandle -> void" , "contents": "encodeWithCoder(${1:NSCoder})" },{ "trigger": "attributedStringForNil \t NSAttributedString", "contents": "attributedStringForNil" },{ "trigger": "getBytes \t func NSData -> void" , "contents": "getBytes(${1:UnsafeMutablePointer<Void>}, length:${2:Int})" },{ "trigger": "stringByReplacingOccurrencesOfString \t func NSString -> String" , "contents": "stringByReplacingOccurrencesOfString(${1:String}, withString:${2:String}, options:${3:NSStringCompareOptions}, range:${4:NSRange})" },{ "trigger": "unsignedIntValue \t UInt", "contents": "unsignedIntValue" },{ "trigger": "loadAndReturnError \t func NSBundle -> void" , "contents": "loadAndReturnError(${1:})" },{ "trigger": "- \t func unknown -> CGFloat" , "contents": "-(${1:CGFloat})" },{ "trigger": "NSThread.detachNewThread \t class NSThread -> Void" , "contents": "NSThread.detachNewThread(${1:Void -> Void})" },{ "trigger": "NSSocketPort \t remoteWithProtocolFamily: socketType: `protocol`: address:" , "contents": "NSSocketPort(remoteWithProtocolFamily:${1:Int32}, socketType:${2:Int32}, `protocol`:${3:Int32}, address:${4:NSData})" },{ "trigger": "rangeOfPort \t NSRange", "contents": "rangeOfPort" },{ "trigger": "previousNode \t NSXMLNode", "contents": "previousNode" },{ "trigger": "NSXMLNode \t kind: options:" , "contents": "NSXMLNode(${1:NSXMLNodeKind}, options:${2:Int})" },{ "trigger": "String \t _:" , "contents": "String(_:${1:Int})" },{ "trigger": "enumerateDatesStartingAfterDate \t func NSCalendar -> Void" , "contents": "enumerateDatesStartingAfterDate(${1:NSDate}, matchingComponents:${2:NSDateComponents}, options:${3:NSCalendarOptions}, usingBlock:${4:NSDate?}, Bool:${5:}, UnsafeMutablePointer<ObjCBool>:${6:})" },{ "trigger": "localizedStandardCompare \t func String -> NSComparisonResult" , "contents": "localizedStandardCompare(${1:String})" },{ "trigger": "localizedStandardRangeOfString \t func String -> Range Index ?" , "contents": "localizedStandardRangeOfString(${1:String})" },{ "trigger": "NSCharacterSet \t bitmapRepresentation:" , "contents": "NSCharacterSet(bitmapRepresentation:${1:NSData})" },{ "trigger": "getBytes \t func NSString -> Bool" , "contents": "getBytes(${1:UnsafeMutablePointer<Void>}, maxLength:${2:Int}, usedLength:${3:UnsafeMutablePointer<Int>}, encoding:${4:UInt}, options:${5:NSStringEncodingConversionOptions}, range:${6:NSRange}, remainingRange:${7:NSRangePointer})" },{ "trigger": "NSURLSessionResponseDisposition \t NSURLSessionResponseDisposition", "contents": "NSURLSessionResponseDisposition" },{ "trigger": "NSURLRequestNetworkServiceType \t NSURLRequestNetworkServiceType", "contents": "NSURLRequestNetworkServiceType" },{ "trigger": "NSPredicateOperatorType \t NSPredicateOperatorType", "contents": "NSPredicateOperatorType" },{ "trigger": "interrupt \t func NSTask -> void" , "contents": "interrupt(${1:})" },{ "trigger": "NSDecimalNumber.maximumDecimalNumber \t class NSDecimalNumber -> NSDecimalNumber" , "contents": "NSDecimalNumber.maximumDecimalNumber(${1:})" },{ "trigger": "resume \t func NSProgress -> void" , "contents": "resume(${1:})" },{ "trigger": "rangeOfCharacterFromSet \t func NSString -> NSRange" , "contents": "rangeOfCharacterFromSet(${1:NSCharacterSet}, options:${2:NSStringCompareOptions})" },{ "trigger": "NSEnumerator \t NSEnumerator", "contents": "NSEnumerator" },{ "trigger": "NSPersonNameComponentsFormatterStyle \t NSPersonNameComponentsFormatterStyle", "contents": "NSPersonNameComponentsFormatterStyle" },{ "trigger": "NSURLProtocol.requestIsCacheEquivalent \t class NSURLProtocol -> Bool" , "contents": "NSURLProtocol.requestIsCacheEquivalent(${1:NSURLRequest}, toRequest:${2:NSURLRequest})" },{ "trigger": "NSDateFormatter.dateFormatFromTemplate \t class NSDateFormatter -> String?" , "contents": "NSDateFormatter.dateFormatFromTemplate(${1:String}, options:${2:Int}, locale:${3:NSLocale?})" },{ "trigger": "contentsEqualAtPath \t func NSFileManager -> Bool" , "contents": "contentsEqualAtPath(${1:String}, andPath:${2:String})" },{ "trigger": "URL \t NSURL", "contents": "URL" },{ "trigger": "namePrefix \t String", "contents": "namePrefix" },{ "trigger": "NSTimeZoneNameStyle \t NSTimeZoneNameStyle", "contents": "NSTimeZoneNameStyle" },{ "trigger": "uploadTaskWithRequest \t func NSURLSession -> NSURLSessionUploadTask" , "contents": "uploadTaskWithRequest(${1:NSURLRequest}, fromData:${2:NSData})" },{ "trigger": "style \t NSPersonNameComponentsFormatterStyle", "contents": "style" },{ "trigger": "includesCount \t Bool", "contents": "includesCount" },{ "trigger": "fileHandleForReading \t NSFileHandle", "contents": "fileHandleForReading" },{ "trigger": "unlock \t func NSLock -> void" , "contents": "unlock(${1:})" },{ "trigger": "NSTextCheckingResult.regularExpressionCheckingResultWithRanges \t class NSTextCheckingResult -> NSTextCheckingResult" , "contents": "NSTextCheckingResult.regularExpressionCheckingResultWithRanges(${1:NSRangePointer}, count:${2:Int}, regularExpression:${3:NSRegularExpression})" },{ "trigger": "runMode \t func NSRunLoop -> Bool" , "contents": "runMode(${1:String}, beforeDate:${2:NSDate})" },{ "trigger": "Generator \t Generator", "contents": "Generator" },{ "trigger": "annotatedStringFromPersonNameComponents \t func NSPersonNameComponentsFormatter -> NSAttributedString" , "contents": "annotatedStringFromPersonNameComponents(${1:NSPersonNameComponents})" },{ "trigger": "NSCompoundPredicate \t orPredicateWithSubpredicates:" , "contents": "NSCompoundPredicate(orPredicateWithSubpredicates:${1:[NSPredicate]})" },{ "trigger": "NSNull.supportsSecureCoding \t static NSNull -> Bool" , "contents": "NSNull.supportsSecureCoding(${1:})" },{ "trigger": "NSRunLoop.currentRunLoop \t class NSRunLoop -> NSRunLoop" , "contents": "NSRunLoop.currentRunLoop(${1:})" },{ "trigger": "NSXMLNodeLoadExternalEntitiesNever \t Int", "contents": "NSXMLNodeLoadExternalEntitiesNever" },{ "trigger": "setString \t func NSMutableString -> void" , "contents": "setString(${1:String})" },{ "trigger": "writeData \t func NSFileHandle -> void" , "contents": "writeData(${1:NSData})" },{ "trigger": "isDaylightSavingTimeForDate \t func NSTimeZone -> Bool" , "contents": "isDaylightSavingTimeForDate(${1:NSDate})" },{ "trigger": "localizedCaseInsensitiveCompare \t func NSString -> NSComparisonResult" , "contents": "localizedCaseInsensitiveCompare(${1:String})" },{ "trigger": "NSPropertyListSerialization.dataWithPropertyList \t class NSPropertyListSerialization -> NSData" , "contents": "NSPropertyListSerialization.dataWithPropertyList(${1:AnyObject}, format:${2:NSPropertyListFormat}, options:${3:NSPropertyListWriteOptions})" },{ "trigger": "roundingMode \t func NSDecimalNumberHandler -> NSRoundingMode" , "contents": "roundingMode(${1:})" },{ "trigger": "calendar \t NSCalendar", "contents": "calendar" },{ "trigger": "NSMutableDictionary \t contentsOfFile:" , "contents": "NSMutableDictionary(contentsOfFile:${1:String})" },{ "trigger": "replaceObjectAtIndex \t func NSMutableOrderedSet -> void" , "contents": "replaceObjectAtIndex(${1:Int}, withObject:${2:AnyObject})" },{ "trigger": "kind \t String", "contents": "kind" },{ "trigger": "standardOutput \t AnyObject", "contents": "standardOutput" },{ "trigger": "component \t func NSCalendar -> Int" , "contents": "component(${1:NSCalendarUnit}, fromDate:${2:NSDate})" },{ "trigger": "copyWithZone \t func NSPort -> AnyObject" , "contents": "copyWithZone(${1:NSZone})" },{ "trigger": "NSXMLDocumentContentKind \t NSXMLDocumentContentKind", "contents": "NSXMLDocumentContentKind" },{ "trigger": "NSLocale.ISOCountryCodes \t class NSLocale -> [String]" , "contents": "NSLocale.ISOCountryCodes(${1:})" },{ "trigger": "NSHTTPCookieAcceptPolicy \t NSHTTPCookieAcceptPolicy", "contents": "NSHTTPCookieAcceptPolicy" },{ "trigger": "NSURLErrorRedirectToNonExistentLocation \t Int", "contents": "NSURLErrorRedirectToNonExistentLocation" },{ "trigger": "NSXMLDocument.replacementClassForClass \t class NSXMLDocument -> AnyClass" , "contents": "NSXMLDocument.replacementClassForClass(${1:AnyClass})" },{ "trigger": "NSXMLDTDNodeKind \t NSXMLDTDNodeKind", "contents": "NSXMLDTDNodeKind" },{ "trigger": "storeCachedResponse \t func NSURLCache -> void" , "contents": "storeCachedResponse(${1:NSCachedURLResponse}, forRequest:${2:NSURLRequest})" },{ "trigger": "NSMachErrorDomain \t String", "contents": "NSMachErrorDomain" },{ "trigger": "removeObjectForKey \t func NSUserDefaults -> void" , "contents": "removeObjectForKey(${1:String})" },{ "trigger": "NSXMLDocumentXInclude \t Int", "contents": "NSXMLDocumentXInclude" },{ "trigger": "UserClass.supportsSecureCoding \t class UserClass -> Bool" , "contents": "UserClass.supportsSecureCoding(${1:})" },{ "trigger": "removeAllCachedResponses \t func NSURLCache -> void" , "contents": "removeAllCachedResponses(${1:})" },{ "trigger": "copyWithZone \t func NSCharacterSet -> AnyObject" , "contents": "copyWithZone(${1:NSZone})" },{ "trigger": "NSDecimalNumber \t string: locale:" , "contents": "NSDecimalNumber(string:${1:String?}, locale:${2:AnyObject?})" },{ "trigger": "Generator \t dictionary: copyItems:" , "contents": "Generator(${1:[NSObject }, copyItems:${2:Bool})" },{ "trigger": "pathForResource \t func NSBundle -> String?" , "contents": "pathForResource(${1:String?}, ofType:${2:String?}, inDirectory:${3:String?}, forLocalization:${4:String?})" },{ "trigger": "Float._conditionallyBridgeFromObject \t static Float -> Bool" , "contents": "Float._conditionallyBridgeFromObject(${1:NSNumber}, inout:${2:Float?})" },{ "trigger": "NSURL \t string: relativeToURL:" , "contents": "NSURL(string:${1:String}, relativeToURL:${2:NSURL?})" },{ "trigger": "HTTPShouldSetCookies \t Bool", "contents": "HTTPShouldSetCookies" },{ "trigger": "copyWithZone \t func NSCalendar -> AnyObject" , "contents": "copyWithZone(${1:NSZone})" },{ "trigger": "indexOfObjectAtIndexes \t func Generator -> Bool" , "contents": "indexOfObjectAtIndexes(${1:NSIndexSet}, options:${2:NSEnumerationOptions}, passingTest:${3:AnyObject}, Int:${4:}, UnsafeMutablePointer<ObjCBool>:${5:})" },{ "trigger": "paddingCharacter \t String", "contents": "paddingCharacter" },{ "trigger": "NSCalendarIdentifierBuddhist \t String", "contents": "NSCalendarIdentifierBuddhist" },{ "trigger": "fileExistsAtPath \t func NSFileManager -> Bool" , "contents": "fileExistsAtPath(${1:String})" },{ "trigger": "stringByDeletingPathExtension \t String", "contents": "stringByDeletingPathExtension" },{ "trigger": "NSHomeDirectoryForUser \t func unknown -> String?" , "contents": "NSHomeDirectoryForUser(${1:String?})" },{ "trigger": "createFileAtPath \t func NSFileManager -> Bool" , "contents": "createFileAtPath(${1:String}, contents:${2:NSData?}, attributes:${3:[String })" },{ "trigger": "decodeValueOfObjCType \t func NSCoder -> void" , "contents": "decodeValueOfObjCType(${1:UnsafePointer<Int8>}, at:${2:UnsafeMutablePointer<Void>})" },{ "trigger": "NSStreamSOCKSErrorDomain \t String", "contents": "NSStreamSOCKSErrorDomain" },{ "trigger": "port \t NSNumber", "contents": "port" },{ "trigger": "localizedUppercaseString \t String", "contents": "localizedUppercaseString" },{ "trigger": "NSKeyedArchiver.setClassName \t class NSKeyedArchiver -> void" , "contents": "NSKeyedArchiver.setClassName(${1:String?}, forClass:${2:AnyClass})" },{ "trigger": "createSymbolicLinkAtPath \t func NSFileManager -> void" , "contents": "createSymbolicLinkAtPath(${1:String}, withDestinationPath:${2:String})" },{ "trigger": "NSIndexPath \t :" , "contents": "NSIndexPath(${1:})" },{ "trigger": "broadcast \t func NSCondition -> void" , "contents": "broadcast(${1:})" },{ "trigger": "negativePrefix \t String", "contents": "negativePrefix" },{ "trigger": "getCharacters \t func NSString -> void" , "contents": "getCharacters(${1:UnsafeMutablePointer<unichar>}, range:${2:NSRange})" },{ "trigger": "secondaryGroupingSize \t Int", "contents": "secondaryGroupingSize" },{ "trigger": "NSShiftJISStringEncoding \t UInt", "contents": "NSShiftJISStringEncoding" },{ "trigger": "NSKeyedUnarchiver \t forReadingWithData:" , "contents": "NSKeyedUnarchiver(forReadingWithData:${1:NSData})" },{ "trigger": "condition \t Int", "contents": "condition" },{ "trigger": "generatesDecimalNumbers \t Bool", "contents": "generatesDecimalNumbers" },{ "trigger": "NSObject \t NSObject", "contents": "NSObject" },{ "trigger": "NSCachedURLResponse \t NSCachedURLResponse", "contents": "NSCachedURLResponse" },{ "trigger": "systemID \t String", "contents": "systemID" },{ "trigger": "normalizeAdjacentTextNodesPreservingCDATA \t func NSXMLElement -> void" , "contents": "normalizeAdjacentTextNodesPreservingCDATA(${1:Bool})" },{ "trigger": "decodeTopLevelObjectOfClasses \t func NSCoder -> AnyObject?" , "contents": "decodeTopLevelObjectOfClasses(${1:[AnyClass]}, forKey:${2:String})" },{ "trigger": "dateFromString \t func NSDateFormatter -> NSDate?" , "contents": "dateFromString(${1:String})" },{ "trigger": "NSLocaleIdentifier \t String", "contents": "NSLocaleIdentifier" },{ "trigger": "NSDecimalSubtract \t func unknown -> NSCalculationError" , "contents": "NSDecimalSubtract(${1:UnsafeMutablePointer<NSDecimal>}, _:${2:UnsafePointer<NSDecimal>}, _:${3:UnsafePointer<NSDecimal>}, _:${4:NSRoundingMode})" },{ "trigger": "NSHTTPCookieStorage \t NSHTTPCookieStorage", "contents": "NSHTTPCookieStorage" },{ "trigger": "unlockWithCondition \t func NSConditionLock -> void" , "contents": "unlockWithCondition(${1:Int})" },{ "trigger": "NSNumber \t integerLiteral:" , "contents": "NSNumber(integerLiteral:${1:Int})" },{ "trigger": "encodeFloat \t func NSCoder -> void" , "contents": "encodeFloat(${1:Float}, forKey:${2:String})" },{ "trigger": "rangeOfPath \t NSRange", "contents": "rangeOfPath" },{ "trigger": "fileHandleForWriting \t NSFileHandle", "contents": "fileHandleForWriting" },{ "trigger": "copyWithZone \t func NSSet -> AnyObject" , "contents": "copyWithZone(${1:NSZone})" },{ "trigger": "substringToIndex \t func String -> String" , "contents": "substringToIndex(${1:Index})" },{ "trigger": "percentEncodedPassword \t String", "contents": "percentEncodedPassword" },{ "trigger": "replaceOccurrencesOfString \t func NSMutableString -> Int" , "contents": "replaceOccurrencesOfString(${1:String}, withString:${2:String}, options:${3:NSStringCompareOptions}, range:${4:NSRange})" },{ "trigger": "smallestEncoding \t UInt", "contents": "smallestEncoding" },{ "trigger": "NSData \t contentsOfFile: options:" , "contents": "NSData(contentsOfFile:${1:String}, options:${2:NSDataReadingOptions})" },{ "trigger": "NSFileHandle.supportsSecureCoding \t static NSFileHandle -> Bool" , "contents": "NSFileHandle.supportsSecureCoding(${1:})" },{ "trigger": "getValue \t func NSValue -> void" , "contents": "getValue(${1:UnsafeMutablePointer<Void>})" },{ "trigger": "bridge \t func NSArray -> Array AnyObject " , "contents": "bridge(${1:})" },{ "trigger": "supportsSecureCoding \t func NSURL -> Bool" , "contents": "supportsSecureCoding(${1:})" },{ "trigger": "leftExpression \t NSExpression", "contents": "leftExpression" },{ "trigger": "collection \t AnyObject", "contents": "collection" },{ "trigger": "HTTPOnly \t Bool", "contents": "HTTPOnly" },{ "trigger": "forPersonMassUse \t Bool", "contents": "forPersonMassUse" },{ "trigger": "replacementStringForResult \t func NSRegularExpression -> String" , "contents": "replacementStringForResult(${1:NSTextCheckingResult}, inString:${2:String}, offset:${3:Int}, template:${4:String})" },{ "trigger": "baseURL \t NSURL", "contents": "baseURL" },{ "trigger": "NSXMLNodePreserveCDATA \t Int", "contents": "NSXMLNodePreserveCDATA" },{ "trigger": "TLSMinimumSupportedProtocol \t SSLProtocol", "contents": "TLSMinimumSupportedProtocol" },{ "trigger": "addChild \t func NSXMLElement -> void" , "contents": "addChild(${1:NSXMLNode})" },{ "trigger": "encodeWithCoder \t func Generator -> void" , "contents": "encodeWithCoder(${1:NSCoder})" },{ "trigger": "storagePolicy \t NSURLCacheStoragePolicy", "contents": "storagePolicy" },{ "trigger": "stringValue \t String", "contents": "stringValue" },{ "trigger": "string \t String", "contents": "string" },{ "trigger": "URI \t String", "contents": "URI" },{ "trigger": "NSOutputStream.outputStreamToMemory \t class NSOutputStream -> Self" , "contents": "NSOutputStream.outputStreamToMemory(${1:})" },{ "trigger": "NSXMLNodeLoadExternalEntitiesSameOriginOnly \t Int", "contents": "NSXMLNodeLoadExternalEntitiesSameOriginOnly" },{ "trigger": "enumerateKeysAndObjectsWithOptions \t func Generator -> Void" , "contents": "enumerateKeysAndObjectsWithOptions(${1:NSEnumerationOptions}, usingBlock:${2:NSObject}, AnyObject:${3:}, UnsafeMutablePointer<ObjCBool>:${4:})" },{ "trigger": "NSEnumerationOptions \t NSEnumerationOptions", "contents": "NSEnumerationOptions" },{ "trigger": "applyTransform \t func NSMutableString -> Bool" , "contents": "applyTransform(${1:String}, reverse:${2:Bool}, range:${3:NSRange}, updatedRange:${4:NSRangePointer})" },{ "trigger": "range \t NSRange", "contents": "range" },{ "trigger": "requiresSecureCoding \t Bool", "contents": "requiresSecureCoding" },{ "trigger": "allowsNonnumericFormatting \t Bool", "contents": "allowsNonnumericFormatting" },{ "trigger": "NSValue \t size:" , "contents": "NSValue(${1:NSSize})" },{ "trigger": "NSOrderedSet \t array: range: copyItems:" , "contents": "NSOrderedSet(array:${1:[AnyObject]}, range:${2:NSRange}, copyItems:${3:Bool})" },{ "trigger": "NSCharacterSet.URLFragmentAllowedCharacterSet \t class NSCharacterSet -> NSCharacterSet" , "contents": "NSCharacterSet.URLFragmentAllowedCharacterSet(${1:})" },{ "trigger": "removeCachedResponseForDataTask \t func NSURLCache -> void" , "contents": "removeCachedResponseForDataTask(${1:NSURLSessionDataTask})" },{ "trigger": "URLCredentialStorage \t NSURLCredentialStorage", "contents": "URLCredentialStorage" },{ "trigger": "processorCount \t Int", "contents": "processorCount" },{ "trigger": "NSXMLParser \t NSXMLParser", "contents": "NSXMLParser" },{ "trigger": "NSLocale.characterDirectionForLanguage \t class NSLocale -> NSLocaleLanguageDirection" , "contents": "NSLocale.characterDirectionForLanguage(${1:String})" },{ "trigger": "timeIntervalSinceDate \t func NSDate -> NSTimeInterval" , "contents": "timeIntervalSinceDate(${1:NSDate})" },{ "trigger": "NSSocketPort \t remoteWithTCPPort: host:" , "contents": "NSSocketPort(remoteWithTCPPort:${1:UInt16}, host:${2:String?})" },{ "trigger": "NSComparisonResult \t NSComparisonResult", "contents": "NSComparisonResult" },{ "trigger": "NSTask \t :" , "contents": "NSTask(${1:})" },{ "trigger": "UserClass \t coder:" , "contents": "UserClass(coder:${1:NSCoder})" },{ "trigger": "decodeTopLevelObject \t func NSCoder -> AnyObject?" , "contents": "decodeTopLevelObject(${1:})" },{ "trigger": "nextDaylightSavingTimeTransitionAfterDate \t func NSTimeZone -> NSDate?" , "contents": "nextDaylightSavingTimeTransitionAfterDate(${1:NSDate})" },{ "trigger": "hasPassword \t Bool", "contents": "hasPassword" },{ "trigger": "insertObjects \t func NSMutableArray -> void" , "contents": "insertObjects(${1:[AnyObject]}, atIndexes:${2:NSIndexSet})" },{ "trigger": "NSMutableArray \t objects: count:" , "contents": "NSMutableArray(${1:UnsafePointer<AnyObject?>}, count:${2:Int})" },{ "trigger": "NSLocale.localeIdentifierFromWindowsLocaleCode \t class NSLocale -> String?" , "contents": "NSLocale.localeIdentifierFromWindowsLocaleCode(${1:UInt32})" },{ "trigger": "sendBeforeDate \t func NSPortMessage -> Bool" , "contents": "sendBeforeDate(${1:NSDate})" },{ "trigger": "NSData \t contentsOfURL:" , "contents": "NSData(contentsOfURL:${1:NSURL})" },{ "trigger": "currentRequest \t NSURLRequest", "contents": "currentRequest" },{ "trigger": "closeWrite \t func NSURLSessionStreamTask -> void" , "contents": "closeWrite(${1:})" },{ "trigger": "NSGlobalDomain \t String", "contents": "NSGlobalDomain" },{ "trigger": "namespaceForPrefix \t func NSXMLElement -> NSXMLNode?" , "contents": "namespaceForPrefix(${1:String})" },{ "trigger": "setClassName \t func NSKeyedArchiver -> void" , "contents": "setClassName(${1:String?}, forClass:${2:AnyClass})" },{ "trigger": "NSThread \t _:" , "contents": "NSThread(${1:Void -> Void})" },{ "trigger": "URLByAppendingPathComponent \t func NSURL -> NSURL?" , "contents": "URLByAppendingPathComponent(${1:String}, isDirectory:${2:Bool})" },{ "trigger": "indexPathByAddingIndex \t func NSIndexPath -> NSIndexPath" , "contents": "indexPathByAddingIndex(${1:Int})" },{ "trigger": "propertyList \t func String -> AnyObject" , "contents": "propertyList(${1:})" },{ "trigger": "NSLocalizedRecoverySuggestionErrorKey \t String", "contents": "NSLocalizedRecoverySuggestionErrorKey" },{ "trigger": "NSURL \t fileURLWithPath:" , "contents": "NSURL(fileURLWithPath:${1:String})" },{ "trigger": "NSOrderedSet \t orderedSet: copyItems:" , "contents": "NSOrderedSet(orderedSet:${1:NSOrderedSet}, copyItems:${2:Bool})" },{ "trigger": "NSByteCountFormatterUnits \t NSByteCountFormatterUnits", "contents": "NSByteCountFormatterUnits" },{ "trigger": "encodeBycopyObject \t func NSCoder -> void" , "contents": "encodeBycopyObject(${1:AnyObject?})" },{ "trigger": "NSURLSessionTaskPriorityLow \t Float", "contents": "NSURLSessionTaskPriorityLow" },{ "trigger": "decodeObjectForKey \t func NSCoder -> AnyObject?" , "contents": "decodeObjectForKey(${1:String})" },{ "trigger": "scheduleInRunLoop \t func NSPort -> void" , "contents": "scheduleInRunLoop(${1:NSRunLoop}, forMode:${2:String})" },{ "trigger": "containsObject \t func Generator -> Bool" , "contents": "containsObject(${1:AnyObject})" },{ "trigger": "enumerateAttribute \t func NSAttributedString -> Void" , "contents": "enumerateAttribute(${1:String}, inRange:${2:NSRange}, options:${3:NSAttributedStringEnumerationOptions}, usingBlock:${4:AnyObject?}, NSRange:${5:}, UnsafeMutablePointer<ObjCBool>:${6:})" },{ "trigger": "NSHTTPCookie \t properties:" , "contents": "NSHTTPCookie(${1:[String })" },{ "trigger": "caseInsensitiveCompare \t func NSString -> NSComparisonResult" , "contents": "caseInsensitiveCompare(${1:String})" },{ "trigger": "NSDecimalString \t func unknown -> String" , "contents": "NSDecimalString(${1:UnsafePointer<NSDecimal>}, _:${2:AnyObject?})" },{ "trigger": "NSDictionary.sharedKeySetForKeys \t class NSDictionary -> AnyObject" , "contents": "NSDictionary.sharedKeySetForKeys(${1:[NSCopying]})" },{ "trigger": "NSStreamEvent \t NSStreamEvent", "contents": "NSStreamEvent" },{ "trigger": "NSURLErrorServerCertificateHasBadDate \t Int", "contents": "NSURLErrorServerCertificateHasBadDate" },{ "trigger": "NSNumber \t char:" , "contents": "NSNumber(char:${1:Int8})" },{ "trigger": "NSURLAuthenticationChallenge \t NSURLAuthenticationChallenge", "contents": "NSURLAuthenticationChallenge" },{ "trigger": "CGPoint \t CGPoint", "contents": "CGPoint" },{ "trigger": "attributeForLocalName \t func NSXMLElement -> NSXMLNode?" , "contents": "attributeForLocalName(${1:String}, URI:${2:String?})" },{ "trigger": "copyWithZone \t func NSURLProtectionSpace -> AnyObject" , "contents": "copyWithZone(${1:NSZone})" },{ "trigger": "mutableBytes \t UnsafeMutablePointer", "contents": "mutableBytes" },{ "trigger": "isEqualToTimeZone \t func NSTimeZone -> Bool" , "contents": "isEqualToTimeZone(${1:NSTimeZone})" },{ "trigger": "NSUserDefaultsDidChangeNotification \t String", "contents": "NSUserDefaultsDidChangeNotification" },{ "trigger": "indexLessThanOrEqualToIndex \t func NSIndexSet -> Int" , "contents": "indexLessThanOrEqualToIndex(${1:Int})" },{ "trigger": "NSOSStatusErrorDomain \t String", "contents": "NSOSStatusErrorDomain" },{ "trigger": "NSMutableData \t :" , "contents": "NSMutableData(${1:})" },{ "trigger": "NSSortDescriptor \t key: ascending: comparator:" , "contents": "NSSortDescriptor(${1:String?}, ascending:${2:Bool}, comparator:${3:NSComparator})" },{ "trigger": "compare \t func NSString -> NSComparisonResult" , "contents": "compare(${1:String})" },{ "trigger": "NSLocaleMeasurementSystem \t String", "contents": "NSLocaleMeasurementSystem" },{ "trigger": "customPlaygroundQuickLook \t func NSNumber -> PlaygroundQuickLook" , "contents": "customPlaygroundQuickLook(${1:})" },{ "trigger": "NSCachedURLResponse \t coder:" , "contents": "NSCachedURLResponse(coder:${1:NSCoder})" },{ "trigger": "firstObjectCommonWithArray \t func Generator -> AnyObject?" , "contents": "firstObjectCommonWithArray(${1:[AnyObject]})" },{ "trigger": "generate \t func NSEnumerator -> Generator" , "contents": "generate(${1:})" },{ "trigger": "pathExtension \t String", "contents": "pathExtension" },{ "trigger": "reverseObjectEnumerator \t func Generator -> NSEnumerator" , "contents": "reverseObjectEnumerator(${1:})" },{ "trigger": "Double._forceBridgeFromObject \t static Double -> void" , "contents": "Double._forceBridgeFromObject(${1:NSNumber}, inout:${2:Double?})" },{ "trigger": "copyWithZone \t func NSIndexSet -> AnyObject" , "contents": "copyWithZone(${1:NSZone})" },{ "trigger": "URLByDeletingLastPathComponent \t NSURL", "contents": "URLByDeletingLastPathComponent" },{ "trigger": "supportsSecureCoding \t func NSCalendar -> Bool" , "contents": "supportsSecureCoding(${1:})" },{ "trigger": "_bridgeToObject \t func Array -> NSArray" , "contents": "_bridgeToObject(${1:})" },{ "trigger": "removeObjectForKey \t func NSMutableDictionary -> void" , "contents": "removeObjectForKey(${1:AnyObject})" },{ "trigger": "NSLocale.commonISOCurrencyCodes \t class NSLocale -> [String]" , "contents": "NSLocale.commonISOCurrencyCodes(${1:})" },{ "trigger": "integerValue \t Int", "contents": "integerValue" },{ "trigger": "NSMessagePort \t NSMessagePort", "contents": "NSMessagePort" },{ "trigger": "decodeDataObject \t func NSCoder -> NSData?" , "contents": "decodeDataObject(${1:})" },{ "trigger": "capitalizedStringWithLocale \t func String -> String" , "contents": "capitalizedStringWithLocale(${1:NSLocale?})" },{ "trigger": "encodeRootObject \t func NSCoder -> void" , "contents": "encodeRootObject(${1:AnyObject})" },{ "trigger": "readInBackgroundAndNotifyForModes \t func NSFileHandle -> void" , "contents": "readInBackgroundAndNotifyForModes(${1:[String]?})" },{ "trigger": "NSCalendar.autoupdatingCurrentCalendar \t class NSCalendar -> NSCalendar" , "contents": "NSCalendar.autoupdatingCurrentCalendar(${1:})" },{ "trigger": "NSHTTPURLResponse \t coder:" , "contents": "NSHTTPURLResponse(coder:${1:NSCoder})" },{ "trigger": "readToEndOfFileInBackgroundAndNotify \t func NSFileHandle -> void" , "contents": "readToEndOfFileInBackgroundAndNotify(${1:})" },{ "trigger": "NSXMLElement \t name:" , "contents": "NSXMLElement(${1:String})" },{ "trigger": "NSXMLNode.prefixForName \t class NSXMLNode -> String?" , "contents": "NSXMLNode.prefixForName(${1:String})" },{ "trigger": "NSURLRequest \t URL:" , "contents": "NSURLRequest(${1:NSURL})" },{ "trigger": "NSURLCredential \t trust:" , "contents": "NSURLCredential(${1:SecTrust})" },{ "trigger": "localizedStandardContainsString \t func String -> Bool" , "contents": "localizedStandardContainsString(${1:String})" },{ "trigger": "indexOfObject \t func NSOrderedSet -> Int" , "contents": "indexOfObject(${1:AnyObject})" },{ "trigger": "hour \t Int", "contents": "hour" },{ "trigger": "NSXMLNode.predefinedNamespaceForPrefix \t class NSXMLNode -> NSXMLNode?" , "contents": "NSXMLNode.predefinedNamespaceForPrefix(${1:String})" },{ "trigger": "totalCostLimit \t Int", "contents": "totalCostLimit" },{ "trigger": "NSOutputStream \t URL: append:" , "contents": "NSOutputStream(URL:${1:NSURL}, append:${2:Bool})" },{ "trigger": "edgeInsetsValue \t NSEdgeInsets", "contents": "edgeInsetsValue" },{ "trigger": "acceptConnectionInBackgroundAndNotify \t func NSFileHandle -> void" , "contents": "acceptConnectionInBackgroundAndNotify(${1:})" },{ "trigger": "objectsAtIndexes \t func NSOrderedSet -> [AnyObject]" , "contents": "objectsAtIndexes(${1:NSIndexSet})" },{ "trigger": "NSXMLNodePreserveEntities \t Int", "contents": "NSXMLNodePreserveEntities" },{ "trigger": "objectByApplyingXSLT \t func NSXMLDocument -> AnyObject" , "contents": "objectByApplyingXSLT(${1:NSData}, arguments:${2:[String })" },{ "trigger": "NSHTTPCookieExpires \t String", "contents": "NSHTTPCookieExpires" },{ "trigger": "encodeWithCoder \t func NSPredicate -> void" , "contents": "encodeWithCoder(${1:NSCoder})" },{ "trigger": "NSLocaleAlternateQuotationBeginDelimiterKey \t String", "contents": "NSLocaleAlternateQuotationBeginDelimiterKey" },{ "trigger": "NSPortMessage \t sendPort: receivePort: components:" , "contents": "NSPortMessage(${1:NSPort?}, receivePort:${2:NSPort?}, components:${3:[AnyObject]?})" },{ "trigger": "filteredArrayUsingPredicate \t func NSArray -> [AnyObject]" , "contents": "filteredArrayUsingPredicate(${1:NSPredicate})" },{ "trigger": "scanHexInt \t func NSScanner -> Bool" , "contents": "scanHexInt(${1:UnsafeMutablePointer<UInt32>})" },{ "trigger": "valueForHTTPHeaderField \t func NSURLRequest -> String?" , "contents": "valueForHTTPHeaderField(${1:String})" },{ "trigger": "NSString \t NSString", "contents": "NSString" },{ "trigger": "copyWithZone \t func NSURLComponents -> AnyObject" , "contents": "copyWithZone(${1:NSZone})" },{ "trigger": "standardInput \t AnyObject", "contents": "standardInput" },{ "trigger": "NSTimeZone.timeZoneDataVersion \t class NSTimeZone -> String" , "contents": "NSTimeZone.timeZoneDataVersion(${1:})" },{ "trigger": "NSDateFormatter.localizedStringFromDate \t class NSDateFormatter -> String" , "contents": "NSDateFormatter.localizedStringFromDate(${1:NSDate}, dateStyle:${2:NSDateFormatterStyle}, timeStyle:${3:NSDateFormatterStyle})" },{ "trigger": "NSURLComponents \t string:" , "contents": "NSURLComponents(string:${1:String})" },{ "trigger": "copyWithZone \t func NSTimeZone -> AnyObject" , "contents": "copyWithZone(${1:NSZone})" },{ "trigger": "NSMutableOrderedSet \t NSMutableOrderedSet", "contents": "NSMutableOrderedSet" },{ "trigger": "NSPortDidBecomeInvalidNotification \t String", "contents": "NSPortDidBecomeInvalidNotification" },{ "trigger": "localizedAdditionalDescription \t String", "contents": "localizedAdditionalDescription" },{ "trigger": "run \t func NSRunLoop -> void" , "contents": "run(${1:})" },{ "trigger": "copyWithZone \t func NSURLSessionConfiguration -> AnyObject" , "contents": "copyWithZone(${1:NSZone})" },{ "trigger": "NSMutableSet \t capacity:" , "contents": "NSMutableSet(capacity:${1:Int})" },{ "trigger": "resultByAdjustingRangesWithOffset \t func NSTextCheckingResult -> NSTextCheckingResult" , "contents": "resultByAdjustingRangesWithOffset(${1:Int})" },{ "trigger": "NSFileHFSTypeCode \t String", "contents": "NSFileHFSTypeCode" },{ "trigger": "NSHTTPCookieOriginURL \t String", "contents": "NSHTTPCookieOriginURL" },{ "trigger": "NSLocaleScriptCode \t String", "contents": "NSLocaleScriptCode" },{ "trigger": "launchPath \t String", "contents": "launchPath" },{ "trigger": "MIMEType \t String", "contents": "MIMEType" },{ "trigger": "address \t String", "contents": "address" },{ "trigger": "NSMutableString \t characters: length:" , "contents": "NSMutableString(${1:UnsafePointer<unichar>}, length:${2:Int})" },{ "trigger": "requestCachePolicy \t NSURLRequestCachePolicy", "contents": "requestCachePolicy" },{ "trigger": "NSProgressFileOperationKindDownloading \t String", "contents": "NSProgressFileOperationKindDownloading" },{ "trigger": "NSTimeZone.systemTimeZone \t class NSTimeZone -> NSTimeZone" , "contents": "NSTimeZone.systemTimeZone(${1:})" },{ "trigger": "Float._forceBridgeFromObject \t static Float -> void" , "contents": "Float._forceBridgeFromObject(${1:NSNumber}, inout:${2:Float?})" },{ "trigger": "localizedStandardCompare \t func NSString -> NSComparisonResult" , "contents": "localizedStandardCompare(${1:String})" },{ "trigger": "NSThread.sleepUntilDate \t class NSThread -> void" , "contents": "NSThread.sleepUntilDate(${1:NSDate})" },{ "trigger": "isSubsetOfSet \t func NSOrderedSet -> Bool" , "contents": "isSubsetOfSet(${1:Set<NSObject>})" },{ "trigger": "decodePropertyList \t func NSCoder -> AnyObject?" , "contents": "decodePropertyList(${1:})" },{ "trigger": "NSThread.sleepForTimeInterval \t class NSThread -> void" , "contents": "NSThread.sleepForTimeInterval(${1:NSTimeInterval})" },{ "trigger": "enumerateObjectsAtIndexes \t func Generator -> Void" , "contents": "enumerateObjectsAtIndexes(${1:NSIndexSet}, options:${2:NSEnumerationOptions}, usingBlock:${3:AnyObject}, Int:${4:}, UnsafeMutablePointer<ObjCBool>:${5:})" },{ "trigger": "taskIdentifier \t Int", "contents": "taskIdentifier" },{ "trigger": "minimumDaysInFirstWeek \t Int", "contents": "minimumDaysInFirstWeek" },{ "trigger": "NSURLErrorBadServerResponse \t Int", "contents": "NSURLErrorBadServerResponse" },{ "trigger": "alwaysShowsDecimalSeparator \t Bool", "contents": "alwaysShowsDecimalSeparator" },{ "trigger": "decodeSizeForKey \t func NSCoder -> NSSize" , "contents": "decodeSizeForKey(${1:String})" },{ "trigger": "NSPersonNameComponentGivenName \t String", "contents": "NSPersonNameComponentGivenName" },{ "trigger": "cancel \t func NSOperation -> void" , "contents": "cancel(${1:})" },{ "trigger": "pathExtension \t :", "contents": "pathExtension" },{ "trigger": "numberOfCaptureGroups \t Int", "contents": "numberOfCaptureGroups" },{ "trigger": "lockBeforeDate \t func NSConditionLock -> Bool" , "contents": "lockBeforeDate(${1:NSDate})" },{ "trigger": "NSAttributedString \t coder:" , "contents": "NSAttributedString(coder:${1:NSCoder})" },{ "trigger": "stringByApplyingTransform \t func NSString -> String?" , "contents": "stringByApplyingTransform(${1:String}, reverse:${2:Bool})" },{ "trigger": "Array._conditionallyBridgeFromObject \t static Array -> Bool" , "contents": "Array._conditionallyBridgeFromObject(${1:NSArray}, inout:${2:Array?})" },{ "trigger": "NSXMLNodePrettyPrint \t Int", "contents": "NSXMLNodePrettyPrint" },{ "trigger": "NSURLSessionConfiguration.backgroundSessionConfigurationWithIdentifier \t class NSURLSessionConfiguration -> NSURLSessionConfiguration" , "contents": "NSURLSessionConfiguration.backgroundSessionConfigurationWithIdentifier(${1:String})" },{ "trigger": "NSJSONSerialization.dataWithJSONObject \t class NSJSONSerialization -> NSData" , "contents": "NSJSONSerialization.dataWithJSONObject(${1:AnyObject}, options:${2:NSJSONWritingOptions})" },{ "trigger": "stringByAbbreviatingWithTildeInPath \t String", "contents": "stringByAbbreviatingWithTildeInPath" },{ "trigger": "encodeWithCoder \t func NSLocale -> void" , "contents": "encodeWithCoder(${1:NSCoder})" },{ "trigger": "NSScanner \t string:" , "contents": "NSScanner(${1:String})" },{ "trigger": "NSMatchingOptions \t rawValue:" , "contents": "NSMatchingOptions(${1:UInt})" },{ "trigger": "NSHTTPCookie \t NSHTTPCookie", "contents": "NSHTTPCookie" },{ "trigger": "localizedStringForKey \t func NSBundle -> String" , "contents": "localizedStringForKey(${1:String}, value:${2:String?}, table:${3:String?})" },{ "trigger": "forFoodEnergyUse \t Bool", "contents": "forFoodEnergyUse" },{ "trigger": "increaseLengthBy \t func NSMutableData -> void" , "contents": "increaseLengthBy(${1:Int})" },{ "trigger": "NSStreamSocketSSLErrorDomain \t String", "contents": "NSStreamSocketSSLErrorDomain" },{ "trigger": "NSFileHandle \t NSFileHandle", "contents": "NSFileHandle" },{ "trigger": "NSXMLParserErrorDomain \t String", "contents": "NSXMLParserErrorDomain" },{ "trigger": "scanInteger \t func NSScanner -> Bool" , "contents": "scanInteger(${1:UnsafeMutablePointer<Int>})" },{ "trigger": "Generator \t array:" , "contents": "Generator(${1:[AnyObject]})" },{ "trigger": "supportsSecureCoding \t func NSURLResponse -> Bool" , "contents": "supportsSecureCoding(${1:})" },{ "trigger": "NSMutableDictionary \t capacity:" , "contents": "NSMutableDictionary(capacity:${1:Int})" },{ "trigger": "keysSortedByValueUsingComparator \t func Generator -> [AnyObject]" , "contents": "keysSortedByValueUsingComparator(${1:NSComparator})" },{ "trigger": "NSNumber \t double:" , "contents": "NSNumber(double:${1:Double})" },{ "trigger": "descriptionWithLocale \t func NSDate -> String" , "contents": "descriptionWithLocale(${1:AnyObject?})" },{ "trigger": "insertChild \t func NSXMLElement -> void" , "contents": "insertChild(${1:NSXMLNode}, atIndex:${2:Int})" },{ "trigger": "supportsSecureCoding \t func NSCachedURLResponse -> Bool" , "contents": "supportsSecureCoding(${1:})" },{ "trigger": "trueExpression \t NSExpression", "contents": "trueExpression" },{ "trigger": "rootElement \t func NSXMLDocument -> NSXMLElement?" , "contents": "rootElement(${1:})" },{ "trigger": "NSURLProtocol.unregisterClass \t class NSURLProtocol -> void" , "contents": "NSURLProtocol.unregisterClass(${1:AnyClass})" },{ "trigger": "enumeratorAtPath \t func NSFileManager -> NSDirectoryEnumerator?" , "contents": "enumeratorAtPath(${1:String})" },{ "trigger": "NSCharacterSet.whitespaceCharacterSet \t class NSCharacterSet -> NSCharacterSet" , "contents": "NSCharacterSet.whitespaceCharacterSet(${1:})" },{ "trigger": "rangeOfUnit \t func NSCalendar -> NSRange" , "contents": "rangeOfUnit(${1:NSCalendarUnit}, inUnit:${2:NSCalendarUnit}, forDate:${3:NSDate})" },{ "trigger": "currentMemoryUsage \t Int", "contents": "currentMemoryUsage" },{ "trigger": "NSURLErrorServerCertificateNotYetValid \t Int", "contents": "NSURLErrorServerCertificateNotYetValid" },{ "trigger": "NSXMLDTD \t data: options:" , "contents": "NSXMLDTD(${1:NSData}, options:${2:Int})" },{ "trigger": "scanUnsignedLongLong \t func NSScanner -> UInt64?" , "contents": "scanUnsignedLongLong(${1:})" },{ "trigger": "setValue \t func NSMutableURLRequest -> void" , "contents": "setValue(${1:String?}, forHTTPHeaderField:${2:String})" },{ "trigger": "addIndexesInRange \t func NSMutableIndexSet -> void" , "contents": "addIndexesInRange(${1:NSRange})" },{ "trigger": "NSDataReadingOptions \t rawValue:" , "contents": "NSDataReadingOptions(${1:UInt})" },{ "trigger": "URLForDirectory \t func NSFileManager -> NSURL" , "contents": "URLForDirectory(${1:NSSearchPathDirectory}, inDomain:${2:NSSearchPathDomainMask}, appropriateForURL:${3:NSURL?}, create:${4:Bool})" },{ "trigger": "scanHexFloat \t func NSScanner -> Float?" , "contents": "scanHexFloat(${1:})" },{ "trigger": "copyWithZone \t func NSString -> AnyObject" , "contents": "copyWithZone(${1:NSZone})" },{ "trigger": "offsetInFile \t UInt", "contents": "offsetInFile" },{ "trigger": "principalClass \t AnyClass", "contents": "principalClass" },{ "trigger": "encodeWithCoder \t func NSCharacterSet -> void" , "contents": "encodeWithCoder(${1:NSCoder})" },{ "trigger": "NSDirectoryEnumerator \t NSDirectoryEnumerator", "contents": "NSDirectoryEnumerator" },{ "trigger": "NSOperationQueue \t NSOperationQueue", "contents": "NSOperationQueue" },{ "trigger": "supportsSecureCoding \t func NSPersonNameComponents -> Bool" , "contents": "supportsSecureCoding(${1:})" },{ "trigger": "hasDirectoryPath \t Bool", "contents": "hasDirectoryPath" },{ "trigger": "external \t Bool", "contents": "external" },{ "trigger": "NSPipe \t NSPipe", "contents": "NSPipe" },{ "trigger": "scanDouble \t func NSScanner -> Double?" , "contents": "scanDouble(${1:})" },{ "trigger": "NSPredicate \t block: [String:" , "contents": "NSPredicate(${1:AnyObject}, [String:${2:AnyObject]? -> Bool})" },{ "trigger": "NSPropertyListFormat \t NSPropertyListFormat", "contents": "NSPropertyListFormat" },{ "trigger": "NSURLErrorTimedOut \t Int", "contents": "NSURLErrorTimedOut" },{ "trigger": "NSIndexPath \t NSIndexPath", "contents": "NSIndexPath" },{ "trigger": "NSBundle.pathsForResourcesOfType \t class NSBundle -> [String]" , "contents": "NSBundle.pathsForResourcesOfType(${1:String?}, inDirectory:${2:String})" },{ "trigger": "fileExistsAtPath \t func NSFileManager -> Bool" , "contents": "fileExistsAtPath(${1:String}, isDirectory:${2:UnsafeMutablePointer<ObjCBool>})" },{ "trigger": "comparisonPredicateModifier \t NSComparisonPredicateModifier", "contents": "comparisonPredicateModifier" },{ "trigger": "NSLocale.canonicalLanguageIdentifierFromString \t class NSLocale -> String" , "contents": "NSLocale.canonicalLanguageIdentifierFromString(${1:String})" },{ "trigger": "scanHexDouble \t func NSScanner -> Bool" , "contents": "scanHexDouble(${1:UnsafeMutablePointer<Double>})" },{ "trigger": "NSSet \t objects: count:" , "contents": "NSSet(${1:UnsafePointer<AnyObject?>}, count:${2:Int})" },{ "trigger": "NSDate.distantFuture \t class NSDate -> NSDate" , "contents": "NSDate.distantFuture(${1:})" },{ "trigger": "NSProgressFileOperationKindDecompressingAfterDownloading \t String", "contents": "NSProgressFileOperationKindDecompressingAfterDownloading" },{ "trigger": "NSBundle.URLsForResourcesWithExtension \t class NSBundle -> [NSURL]?" , "contents": "NSBundle.URLsForResourcesWithExtension(${1:String?}, subdirectory:${2:String?}, inBundleWithURL:${3:NSURL})" },{ "trigger": "replaceCharactersInRange \t func NSMutableAttributedString -> void" , "contents": "replaceCharactersInRange(${1:NSRange}, withString:${2:String})" },{ "trigger": "compoundPredicateType \t NSCompoundPredicateType", "contents": "compoundPredicateType" },{ "trigger": "NSStringFromRange \t func unknown -> String" , "contents": "NSStringFromRange(${1:NSRange})" },{ "trigger": "NSSet \t set:" , "contents": "NSSet(${1:Set<NSObject>})" },{ "trigger": "fire \t func NSTimer -> void" , "contents": "fire(${1:})" },{ "trigger": "NSLocaleQuotationEndDelimiterKey \t String", "contents": "NSLocaleQuotationEndDelimiterKey" },{ "trigger": "enumerateIndexesInRange \t func NSIndexSet -> Void" , "contents": "enumerateIndexesInRange(${1:NSRange}, options:${2:NSEnumerationOptions}, usingBlock:${3:Int}, UnsafeMutablePointer<ObjCBool>:${4:})" },{ "trigger": "tolerance \t NSTimeInterval", "contents": "tolerance" },{ "trigger": "unitStringFromValue \t func NSEnergyFormatter -> String" , "contents": "unitStringFromValue(${1:Double}, unit:${2:NSEnergyFormatterUnit})" },{ "trigger": "NSURLErrorCannotParseResponse \t Int", "contents": "NSURLErrorCannotParseResponse" },{ "trigger": "boolValue \t Bool", "contents": "boolValue" },{ "trigger": "percentEncodedUser \t String", "contents": "percentEncodedUser" },{ "trigger": "indexOfObject \t func NSOrderedSet -> Int" , "contents": "indexOfObject(${1:AnyObject}, inSortedRange:${2:NSRange}, options:${3:NSBinarySearchingOptions}, usingComparator:${4:NSComparator})" },{ "trigger": "currencyDecimalSeparator \t String", "contents": "currencyDecimalSeparator" },{ "trigger": "forPersonHeightUse \t Bool", "contents": "forPersonHeightUse" },{ "trigger": "compare \t func NSString -> NSComparisonResult" , "contents": "compare(${1:String}, options:${2:NSStringCompareOptions}, range:${3:NSRange})" },{ "trigger": "predecessor \t func NSXMLNode -> Index" , "contents": "predecessor(${1:})" },{ "trigger": "NSURLProtectionSpaceFTPProxy \t String", "contents": "NSURLProtectionSpaceFTPProxy" },{ "trigger": "descriptionWithLocale \t func NSSet -> String" , "contents": "descriptionWithLocale(${1:AnyObject?})" },{ "trigger": "next \t func NSEnumerator -> AnyObject?" , "contents": "next(${1:})" },{ "trigger": "NSURLErrorRequestBodyStreamExhausted \t Int", "contents": "NSURLErrorRequestBodyStreamExhausted" },{ "trigger": "NSFileSystemNodes \t String", "contents": "NSFileSystemNodes" },{ "trigger": "acceptConnectionInBackgroundAndNotifyForModes \t func NSFileHandle -> void" , "contents": "acceptConnectionInBackgroundAndNotifyForModes(${1:[String]?})" },{ "trigger": "removeAllObjects \t func NSMutableOrderedSet -> void" , "contents": "removeAllObjects(${1:})" },{ "trigger": "isPropertyListError \t Bool", "contents": "isPropertyListError" },{ "trigger": "transformStruct \t NSAffineTransformStruct", "contents": "transformStruct" },{ "trigger": "replaceObjectAtIndex \t func NSMutableArray -> void" , "contents": "replaceObjectAtIndex(${1:Int}, withObject:${2:AnyObject})" },{ "trigger": "appendString \t func NSMutableString -> void" , "contents": "appendString(${1:String})" },{ "trigger": "NSCocoaError \t NSCocoaError", "contents": "NSCocoaError" },{ "trigger": "pathForAuxiliaryExecutable \t func NSBundle -> String?" , "contents": "pathForAuxiliaryExecutable(${1:String})" },{ "trigger": "NSDecimalNumber \t NSDecimalNumber", "contents": "NSDecimalNumber" },{ "trigger": "decodeTopLevelObjectForKey \t func NSCoder -> AnyObject?" , "contents": "decodeTopLevelObjectForKey(${1:String})" },{ "trigger": "NSIsEmptyRect \t func unknown -> Bool" , "contents": "NSIsEmptyRect(${1:NSRect})" },{ "trigger": "allowsKeyedCoding \t Bool", "contents": "allowsKeyedCoding" },{ "trigger": "NSData \t coder:" , "contents": "NSData(coder:${1:NSCoder})" },{ "trigger": "NSDate \t timeInterval: sinceDate:" , "contents": "NSDate(timeInterval:${1:NSTimeInterval}, sinceDate:${2:NSDate})" },{ "trigger": "encodeWithCoder \t func NSFormatter -> void" , "contents": "encodeWithCoder(${1:NSCoder})" },{ "trigger": "objectForInfoDictionaryKey \t func NSBundle -> Any?" , "contents": "objectForInfoDictionaryKey(${1:String})" },{ "trigger": "NSNumber \t unsignedLong:" , "contents": "NSNumber(unsignedLong:${1:UInt})" },{ "trigger": "decimalValue \t NSDecimal", "contents": "decimalValue" },{ "trigger": "removeItemAtPath \t func NSFileManager -> void" , "contents": "removeItemAtPath(${1:String})" },{ "trigger": "URLByResolvingSymlinksInPath \t NSURL", "contents": "URLByResolvingSymlinksInPath" },{ "trigger": "NSStringEncodingConversionOptions \t rawValue:" , "contents": "NSStringEncodingConversionOptions(${1:UInt})" },{ "trigger": "identity \t SecIdentity", "contents": "identity" },{ "trigger": "isUserActivityError \t Bool", "contents": "isUserActivityError" },{ "trigger": "resourceIsReachable \t func NSURL -> Bool" , "contents": "resourceIsReachable(${1:})" },{ "trigger": "descriptionWithLocale \t func Generator -> String" , "contents": "descriptionWithLocale(${1:AnyObject?}, indent:${2:Int})" },{ "trigger": "NSURL \t fileURLWithPath: relativeToURL:" , "contents": "NSURL(fileURLWithPath:${1:String}, relativeToURL:${2:NSURL?})" },{ "trigger": "NSDateComponentsFormatter \t :" , "contents": "NSDateComponentsFormatter(${1:})" },{ "trigger": "reversedSortDescriptor \t AnyObject", "contents": "reversedSortDescriptor" },{ "trigger": "NSDecimalPower \t func unknown -> NSCalculationError" , "contents": "NSDecimalPower(${1:UnsafeMutablePointer<NSDecimal>}, _:${2:UnsafePointer<NSDecimal>}, _:${3:Int}, _:${4:NSRoundingMode})" },{ "trigger": "NSFileHandle \t forReadingFromURL:" , "contents": "NSFileHandle(forReadingFromURL:${1:NSURL})" },{ "trigger": "NSDecimalCompare \t func unknown -> NSComparisonResult" , "contents": "NSDecimalCompare(${1:UnsafePointer<NSDecimal>}, _:${2:UnsafePointer<NSDecimal>})" },{ "trigger": "notationName \t String", "contents": "notationName" },{ "trigger": "NSHTTPCookieManagerCookiesChangedNotification \t String", "contents": "NSHTTPCookieManagerCookiesChangedNotification" },{ "trigger": "NSCalculationError \t NSCalculationError", "contents": "NSCalculationError" },{ "trigger": "isValidDateInCalendar \t func NSDateComponents -> Bool" , "contents": "isValidDateInCalendar(${1:NSCalendar})" },{ "trigger": "NSCharacterSet.whitespaceAndNewlineCharacterSet \t class NSCharacterSet -> NSCharacterSet" , "contents": "NSCharacterSet.whitespaceAndNewlineCharacterSet(${1:})" },{ "trigger": "deleteCookie \t func NSHTTPCookieStorage -> void" , "contents": "deleteCookie(${1:NSHTTPCookie})" },{ "trigger": "NSNotificationCoalescing \t NSNotificationCoalescing", "contents": "NSNotificationCoalescing" },{ "trigger": "sortedArrayHint \t NSData", "contents": "sortedArrayHint" },{ "trigger": "timeZone \t NSTimeZone", "contents": "timeZone" },{ "trigger": "NSFormatter \t :" , "contents": "NSFormatter(${1:})" },{ "trigger": "NSString.localizedNameOfStringEncoding \t class NSString -> String" , "contents": "NSString.localizedNameOfStringEncoding(${1:UInt})" },{ "trigger": "NSString \t data: encoding:" , "contents": "NSString(${1:NSData}, encoding:${2:UInt})" },{ "trigger": "NSRectToCGRect \t func unknown -> CGRect" , "contents": "NSRectToCGRect(${1:NSRect})" },{ "trigger": "NSPortMessage \t NSPortMessage", "contents": "NSPortMessage" },{ "trigger": "indexOfObject \t func Generator -> Int" , "contents": "indexOfObject(${1:AnyObject}, inRange:${2:NSRange})" },{ "trigger": "sortedArrayUsingDescriptors \t func NSArray -> [AnyObject]" , "contents": "sortedArrayUsingDescriptors(${1:[NSSortDescriptor]})" },{ "trigger": "NSOutputStream \t NSOutputStream", "contents": "NSOutputStream" },{ "trigger": "compare \t func NSString -> NSComparisonResult" , "contents": "compare(${1:String}, options:${2:NSStringCompareOptions})" },{ "trigger": "decimalNumberByMultiplyingBy \t func NSDecimalNumber -> NSDecimalNumber" , "contents": "decimalNumberByMultiplyingBy(${1:NSDecimalNumber})" },{ "trigger": "NSEnergyFormatter \t coder:" , "contents": "NSEnergyFormatter(${1:NSCoder})" },{ "trigger": "width \t CGFloat", "contents": "width" },{ "trigger": "NSMutableString \t stringLiteral:" , "contents": "NSMutableString(stringLiteral:${1:StaticString})" },{ "trigger": "NSThread.currentThread \t static NSThread -> NSThread" , "contents": "NSThread.currentThread(${1:})" },{ "trigger": "NSURLErrorNotConnectedToInternet \t Int", "contents": "NSURLErrorNotConnectedToInternet" },{ "trigger": "NSXMLDTD \t NSXMLDTD", "contents": "NSXMLDTD" },{ "trigger": "NSHTTPCookieStorage.sharedHTTPCookieStorage \t class NSHTTPCookieStorage -> NSHTTPCookieStorage" , "contents": "NSHTTPCookieStorage.sharedHTTPCookieStorage(${1:})" },{ "trigger": "bundleIdentifier \t String", "contents": "bundleIdentifier" },{ "trigger": "lockWhenCondition \t func NSConditionLock -> void" , "contents": "lockWhenCondition(${1:Int})" },{ "trigger": "NSFileHandle \t forUpdatingURL:" , "contents": "NSFileHandle(forUpdatingURL:${1:NSURL})" },{ "trigger": "countOfBytesReceived \t Int", "contents": "countOfBytesReceived" },{ "trigger": "XMLDataWithOptions \t func NSXMLDocument -> NSData" , "contents": "XMLDataWithOptions(${1:Int})" },{ "trigger": "objectForKey \t func NSLocale -> AnyObject?" , "contents": "objectForKey(${1:String})" },{ "trigger": "NSURLErrorCannotWriteToFile \t Int", "contents": "NSURLErrorCannotWriteToFile" },{ "trigger": "NSDateFormatter \t coder:" , "contents": "NSDateFormatter(${1:NSCoder})" },{ "trigger": "bridge \t func Array -> NSArray" , "contents": "bridge(${1:})" },{ "trigger": "Set._forceBridgeFromObject \t static Set -> void" , "contents": "Set._forceBridgeFromObject(${1:NSSet}, inout:${2:Set?})" },{ "trigger": "stringByReplacingOccurrencesOfString \t func NSString -> String" , "contents": "stringByReplacingOccurrencesOfString(${1:String}, withString:${2:String})" },{ "trigger": "usesSignificantDigits \t Bool", "contents": "usesSignificantDigits" },{ "trigger": "NSLocaleCurrencyCode \t String", "contents": "NSLocaleCurrencyCode" },{ "trigger": "NSAttributedString \t attributedString:" , "contents": "NSAttributedString(attributedString:${1:NSAttributedString})" },{ "trigger": "removeCredential \t func NSURLCredentialStorage -> void" , "contents": "removeCredential(${1:NSURLCredential}, forProtectionSpace:${2:NSURLProtectionSpace}, options:${3:[String })" },{ "trigger": "NSXMLNode.documentWithRootElement \t class NSXMLNode -> AnyObject" , "contents": "NSXMLNode.documentWithRootElement(${1:NSXMLElement})" },{ "trigger": "NSMutableSet \t coder:" , "contents": "NSMutableSet(${1:NSCoder})" },{ "trigger": "NSWidth \t func unknown -> CGFloat" , "contents": "NSWidth(${1:NSRect})" },{ "trigger": "contentsOfDirectoryAtURL \t func NSFileManager -> [NSURL]" , "contents": "contentsOfDirectoryAtURL(${1:NSURL}, includingPropertiesForKeys:${2:[String]?}, options:${3:NSDirectoryEnumerationOptions})" },{ "trigger": "runUntilDate \t func NSRunLoop -> void" , "contents": "runUntilDate(${1:NSDate})" },{ "trigger": "shiftIndexesStartingAtIndex \t func NSMutableIndexSet -> void" , "contents": "shiftIndexesStartingAtIndex(${1:Int}, by:${2:Int})" },{ "trigger": "rangeOfString \t func NSString -> NSRange" , "contents": "rangeOfString(${1:String}, options:${2:NSStringCompareOptions})" },{ "trigger": "dataRepresentation \t NSData", "contents": "dataRepresentation" },{ "trigger": "containsIndexes \t func NSIndexSet -> Bool" , "contents": "containsIndexes(${1:NSIndexSet})" },{ "trigger": "removeIndex \t func NSMutableIndexSet -> void" , "contents": "removeIndex(${1:Int})" },{ "trigger": "negativeInfinitySymbol \t String", "contents": "negativeInfinitySymbol" },{ "trigger": "_bridgeToObject \t func String -> NSString" , "contents": "_bridgeToObject(${1:})" },{ "trigger": "NSFileHandle \t fileDescriptor:" , "contents": "NSFileHandle(fileDescriptor:${1:Int32})" },{ "trigger": "replaceObjectsAtIndexes \t func NSMutableArray -> void" , "contents": "replaceObjectsAtIndexes(${1:NSIndexSet}, withObjects:${2:[AnyObject]})" },{ "trigger": "getBuffer \t func NSInputStream -> Bool" , "contents": "getBuffer(${1:UnsafeMutablePointer<UnsafeMutablePointer<UInt8>>}, length:${2:UnsafeMutablePointer<Int>})" },{ "trigger": "encodeWithCoder \t func NSTimeZone -> void" , "contents": "encodeWithCoder(${1:NSCoder})" },{ "trigger": "NSURLErrorCannotDecodeContentData \t Int", "contents": "NSURLErrorCannotDecodeContentData" },{ "trigger": "paragraphRangeForRange \t func String -> Range Index " , "contents": "paragraphRangeForRange(${1:Range<Index>})" },{ "trigger": "isXPCConnectionError \t Bool", "contents": "isXPCConnectionError" },{ "trigger": "NSFileHandle \t forReadingAtPath:" , "contents": "NSFileHandle(forReadingAtPath:${1:String})" },{ "trigger": "NSBundle.mainBundle \t class NSBundle -> NSBundle" , "contents": "NSBundle.mainBundle(${1:})" },{ "trigger": "NSMakeRange \t func unknown -> NSRange" , "contents": "NSMakeRange(${1:Int}, _:${2:Int})" },{ "trigger": "maximum \t NSNumber", "contents": "maximum" },{ "trigger": "hasPrefix \t func NSString -> Bool" , "contents": "hasPrefix(${1:String})" },{ "trigger": "NSURLErrorCannotRemoveFile \t Int", "contents": "NSURLErrorCannotRemoveFile" },{ "trigger": "addObserverForName \t func NSNotificationCenter -> Void" , "contents": "addObserverForName(${1:String?}, object:${2:AnyObject?}, queue:${3:NSOperationQueue?}, usingBlock:${4:NSNotification -> Void})" },{ "trigger": "NSNumber \t int:" , "contents": "NSNumber(int:${1:Int32})" },{ "trigger": "NSDate.distantPast \t class NSDate -> NSDate" , "contents": "NSDate.distantPast(${1:})" },{ "trigger": "NSURLErrorFailingURLStringErrorKey \t String", "contents": "NSURLErrorFailingURLStringErrorKey" },{ "trigger": "intersectsOrderedSet \t func NSOrderedSet -> Bool" , "contents": "intersectsOrderedSet(${1:NSOrderedSet})" },{ "trigger": "attribute \t func NSAttributedString -> AnyObject?" , "contents": "attribute(${1:String}, atIndex:${2:Int}, longestEffectiveRange:${3:NSRangePointer}, inRange:${4:NSRange})" },{ "trigger": "keysOfEntriesPassingTest \t func Generator -> Bool" , "contents": "keysOfEntriesPassingTest(${1:AnyObject}, AnyObject:${2:}, UnsafeMutablePointer<ObjCBool>:${3:})" },{ "trigger": "localizedCapitalizedString \t String", "contents": "localizedCapitalizedString" },{ "trigger": "NSString \t contentsOfURL: encoding:" , "contents": "NSString(contentsOfURL:${1:NSURL}, encoding:${2:UInt})" },{ "trigger": "NSRectEdge \t rectEdge:" , "contents": "NSRectEdge(${1:CGRectEdge})" },{ "trigger": "absoluteString \t String", "contents": "absoluteString" },{ "trigger": "sortedArrayUsingDescriptors \t func NSOrderedSet -> [AnyObject]" , "contents": "sortedArrayUsingDescriptors(${1:[NSSortDescriptor]})" },{ "trigger": "_bridgeToObject \t func Set -> NSSet" , "contents": "_bridgeToObject(${1:})" },{ "trigger": "moveItemAtPath \t func NSFileManager -> void" , "contents": "moveItemAtPath(${1:String}, toPath:${2:String})" },{ "trigger": "NSURLProtectionSpaceHTTPSProxy \t String", "contents": "NSURLProtectionSpaceHTTPSProxy" },{ "trigger": "rangeOfUnit \t func NSCalendar -> NSDateInterval?" , "contents": "rangeOfUnit(${1:NSCalendarUnit}, forDate:${2:NSDate})" },{ "trigger": "NSData \t base64EncodedString: options:" , "contents": "NSData(base64EncodedString:${1:String}, options:${2:NSDataBase64DecodingOptions})" },{ "trigger": "encodeWithCoder \t func NSData -> void" , "contents": "encodeWithCoder(${1:NSCoder})" },{ "trigger": "lock \t func NSConditionLock -> void" , "contents": "lock(${1:})" },{ "trigger": "encodeWithCoder \t func NSNull -> void" , "contents": "encodeWithCoder(${1:NSCoder})" },{ "trigger": "NSUnderlyingErrorKey \t String", "contents": "NSUnderlyingErrorKey" },{ "trigger": "HTTPMaximumConnectionsPerHost \t Int", "contents": "HTTPMaximumConnectionsPerHost" },{ "trigger": "NSURL \t string:" , "contents": "NSURL(string:${1:String})" },{ "trigger": "NSDecimalNumberHandler \t roundingMode: scale: raiseOnExactness: raiseOnOverflow: raiseOnUnderflow: raiseOnDivideByZero:" , "contents": "NSDecimalNumberHandler(${1:NSRoundingMode}, scale:${2:Int16}, raiseOnExactness:${3:Bool}, raiseOnOverflow:${4:Bool}, raiseOnUnderflow:${5:Bool}, raiseOnDivideByZero:${6:Bool})" },{ "trigger": "NSXMLNodePreserveDTD \t Int", "contents": "NSXMLNodePreserveDTD" },{ "trigger": "writeToFile \t func NSData -> Bool" , "contents": "writeToFile(${1:String}, atomically:${2:Bool})" },{ "trigger": "NSXMLNode \t kind:" , "contents": "NSXMLNode(${1:NSXMLNodeKind})" },{ "trigger": "NSBundle.preferredLocalizationsFromArray \t class NSBundle -> [String]" , "contents": "NSBundle.preferredLocalizationsFromArray(${1:[String]})" },{ "trigger": "NSData \t bytesNoCopy: length: freeWhenDone:" , "contents": "NSData(bytesNoCopy:${1:UnsafeMutablePointer<Void>}, length:${2:Int}, freeWhenDone:${3:Bool})" },{ "trigger": "NSURLSessionConfiguration.defaultSessionConfiguration \t class NSURLSessionConfiguration -> NSURLSessionConfiguration" , "contents": "NSURLSessionConfiguration.defaultSessionConfiguration(${1:})" },{ "trigger": "operationCount \t Int", "contents": "operationCount" },{ "trigger": "localizedDescription \t String", "contents": "localizedDescription" },{ "trigger": "copyWithZone \t func NSExpression -> AnyObject" , "contents": "copyWithZone(${1:NSZone})" },{ "trigger": "NSURLErrorFileDoesNotExist \t Int", "contents": "NSURLErrorFileDoesNotExist" },{ "trigger": "NSCalendarIdentifierRepublicOfChina \t String", "contents": "NSCalendarIdentifierRepublicOfChina" },{ "trigger": "stringByAppendingString \t func NSString -> String" , "contents": "stringByAppendingString(${1:String})" },{ "trigger": "positivePrefix \t String", "contents": "positivePrefix" },{ "trigger": "currencyCode \t String", "contents": "currencyCode" },{ "trigger": "lastIndex \t Int", "contents": "lastIndex" },{ "trigger": "NSLocale.ISOCurrencyCodes \t class NSLocale -> [String]" , "contents": "NSLocale.ISOCurrencyCodes(${1:})" },{ "trigger": "NSConditionLock \t NSConditionLock", "contents": "NSConditionLock" },{ "trigger": "NSCountedSet \t coder:" , "contents": "NSCountedSet(${1:NSCoder})" },{ "trigger": "rangeOfString \t func NSString -> NSRange" , "contents": "rangeOfString(${1:String}, options:${2:NSStringCompareOptions}, range:${3:NSRange})" },{ "trigger": "invalidate \t func NSTimer -> void" , "contents": "invalidate(${1:})" },{ "trigger": "allowsCellularAccess \t Bool", "contents": "allowsCellularAccess" },{ "trigger": "unknown \t _bridgedNSError:" , "contents": "unknown(${1:NSError})" },{ "trigger": "NSRange \t _:" , "contents": "NSRange(_:${1:Range<Int>})" },{ "trigger": "lock \t func NSLock -> void" , "contents": "lock(${1:})" },{ "trigger": "elementsForName \t func NSXMLElement -> [NSXMLElement]" , "contents": "elementsForName(${1:String})" },{ "trigger": "setAttributesAsDictionary \t func NSXMLElement -> void" , "contents": "setAttributesAsDictionary(${1:[NSObject })" },{ "trigger": "rootDocument \t NSXMLDocument", "contents": "rootDocument" },{ "trigger": "weekday \t Int", "contents": "weekday" },{ "trigger": "copyWithZone \t func NSDate -> AnyObject" , "contents": "copyWithZone(${1:NSZone})" },{ "trigger": "NSFileSize \t String", "contents": "NSFileSize" },{ "trigger": "copyItemAtPath \t func NSFileManager -> void" , "contents": "copyItemAtPath(${1:String}, toPath:${2:String})" },{ "trigger": "NSDecimalNumber \t decimal:" , "contents": "NSDecimalNumber(decimal:${1:NSDecimal})" },{ "trigger": "NSOrderedSet \t orderedSet:" , "contents": "NSOrderedSet(orderedSet:${1:NSOrderedSet})" },{ "trigger": "query \t String", "contents": "query" },{ "trigger": "childCount \t Int", "contents": "childCount" },{ "trigger": "sortedArrayUsingDescriptors \t func NSSet -> [AnyObject]" , "contents": "sortedArrayUsingDescriptors(${1:[NSSortDescriptor]})" },{ "trigger": "String \t format: locale: _:" , "contents": "String(${1:String}, locale:${2:NSLocale?}, _:${3:CVarArgType...})" },{ "trigger": "firstObject \t AnyObject", "contents": "firstObject" },{ "trigger": "replaceChildAtIndex \t func NSXMLDocument -> void" , "contents": "replaceChildAtIndex(${1:Int}, withNode:${2:NSXMLNode})" },{ "trigger": "encodePropertyList \t func NSCoder -> void" , "contents": "encodePropertyList(${1:AnyObject})" },{ "trigger": "stringArrayForKey \t func NSUserDefaults -> [String]?" , "contents": "stringArrayForKey(${1:String})" },{ "trigger": "usesGroupingSeparator \t Bool", "contents": "usesGroupingSeparator" },{ "trigger": "publicID \t String", "contents": "publicID" },{ "trigger": "dataTaskWithRequest \t func NSURLSession -> Void" , "contents": "dataTaskWithRequest(${1:NSURLRequest}, completionHandler:${2:NSData?}, NSURLResponse?:${3:}, NSError?:${4:})" },{ "trigger": "NSCalendar.currentCalendar \t class NSCalendar -> NSCalendar" , "contents": "NSCalendar.currentCalendar(${1:})" },{ "trigger": "Dictionary._forceBridgeFromObject \t static Dictionary -> void" , "contents": "Dictionary._forceBridgeFromObject(${1:NSDictionary}, inout:${2:Dictionary?})" },{ "trigger": "NSZeroRect \t NSRect", "contents": "NSZeroRect" },{ "trigger": "NSTimeZone.setAbbreviationDictionary \t class NSTimeZone -> void" , "contents": "NSTimeZone.setAbbreviationDictionary(${1:[String })" },{ "trigger": "indexOfObject \t func Generator -> Int" , "contents": "indexOfObject(${1:AnyObject})" },{ "trigger": "NSRecursiveLock \t :" , "contents": "NSRecursiveLock(${1:})" },{ "trigger": "objectForKey \t func Generator -> AnyObject?" , "contents": "objectForKey(${1:AnyObject})" },{ "trigger": "copyWithZone \t func NSAffineTransform -> AnyObject" , "contents": "copyWithZone(${1:NSZone})" },{ "trigger": "count \t Int", "contents": "count" },{ "trigger": "zeroFormattingBehavior \t NSDateComponentsFormatterZeroFormattingBehavior", "contents": "zeroFormattingBehavior" },{ "trigger": "top \t CGFloat", "contents": "top" },{ "trigger": "NSRectFromCGRect \t func unknown -> NSRect" , "contents": "NSRectFromCGRect(${1:CGRect})" },{ "trigger": "currencyGroupingSeparator \t String", "contents": "currencyGroupingSeparator" },{ "trigger": "NSData \t bytesNoCopy: length:" , "contents": "NSData(bytesNoCopy:${1:UnsafeMutablePointer<Void>}, length:${2:Int})" },{ "trigger": "NSMutableDictionary \t NSMutableDictionary", "contents": "NSMutableDictionary" },{ "trigger": "getObjects \t func NSOrderedSet -> void" , "contents": "getObjects(inout:${1:[AnyObject]}, range:${2:NSRange})" },{ "trigger": "NSOrderedSet \t set: copyItems:" , "contents": "NSOrderedSet(${1:Set<NSObject>}, copyItems:${2:Bool})" },{ "trigger": "XMLStringWithOptions \t func NSXMLNode -> String" , "contents": "XMLStringWithOptions(${1:Int})" },{ "trigger": "NSString \t contentsOfFile: usedEncoding:" , "contents": "NSString(contentsOfFile:${1:String}, usedEncoding:${2:UnsafeMutablePointer<UInt>})" },{ "trigger": "supportsSecureCoding \t func NSURLAuthenticationChallenge -> Bool" , "contents": "supportsSecureCoding(${1:})" },{ "trigger": "protectionSpace \t NSURLProtectionSpace", "contents": "protectionSpace" },{ "trigger": "keysSortedByValueWithOptions \t func Generator -> [AnyObject]" , "contents": "keysSortedByValueWithOptions(${1:NSSortOptions}, usingComparator:${2:NSComparator})" },{ "trigger": "sortUsingFunction \t func NSMutableArray -> Int," , "contents": "sortUsingFunction(compare:${1:@conventionc AnyObject}, AnyObject:${2:}, UnsafeMutablePointer<Void>:${3:}, context:${4:UnsafeMutablePointer<Void>})" },{ "trigger": "includesUnit \t Bool", "contents": "includesUnit" },{ "trigger": "NSOperation \t NSOperation", "contents": "NSOperation" },{ "trigger": "NSDecimalAdd \t func unknown -> NSCalculationError" , "contents": "NSDecimalAdd(${1:UnsafeMutablePointer<NSDecimal>}, _:${2:UnsafePointer<NSDecimal>}, _:${3:UnsafePointer<NSDecimal>}, _:${4:NSRoundingMode})" },{ "trigger": "NSDateFormatter \t :" , "contents": "NSDateFormatter(${1:})" },{ "trigger": "currentDirectoryPath \t String", "contents": "currentDirectoryPath" },{ "trigger": "removeAllObjects \t func NSCache -> void" , "contents": "removeAllObjects(${1:})" },{ "trigger": "groupingSeparator \t String", "contents": "groupingSeparator" },{ "trigger": "scanUpToString \t func NSScanner -> String?" , "contents": "scanUpToString(${1:String})" },{ "trigger": "intersectsSet \t func NSSet -> Bool" , "contents": "intersectsSet(${1:Set<NSObject>})" },{ "trigger": "NSIndexPath \t coder:" , "contents": "NSIndexPath(coder:${1:NSCoder})" },{ "trigger": "seekToFileOffset \t func NSFileHandle -> void" , "contents": "seekToFileOffset(${1:UInt64})" },{ "trigger": "sendBeforeDate \t func NSPort -> Bool" , "contents": "sendBeforeDate(${1:NSDate}, msgid:${2:Int}, components:${3:NSMutableArray?}, from:${4:NSPort?}, reserved:${5:Int})" },{ "trigger": "cStringUsingEncoding \t func NSString -> UnsafePointer Int8 " , "contents": "cStringUsingEncoding(${1:UInt})" },{ "trigger": "predicateOperatorType \t NSPredicateOperatorType", "contents": "predicateOperatorType" },{ "trigger": "NSSearchPathDomainMask \t NSSearchPathDomainMask", "contents": "NSSearchPathDomainMask" },{ "trigger": "NSAttributedStringEnumerationOptions \t NSAttributedStringEnumerationOptions", "contents": "NSAttributedStringEnumerationOptions" },{ "trigger": "NSProgressFileOperationKindKey \t String", "contents": "NSProgressFileOperationKindKey" },{ "trigger": "NSURLSessionUploadTask \t NSURLSessionUploadTask", "contents": "NSURLSessionUploadTask" },{ "trigger": "NSData.supportsSecureCoding \t static NSData -> Bool" , "contents": "NSData.supportsSecureCoding(${1:})" },{ "trigger": "NSSortOptions \t NSSortOptions", "contents": "NSSortOptions" },{ "trigger": "classNameForClass \t func NSKeyedArchiver -> String?" , "contents": "classNameForClass(${1:AnyClass})" },{ "trigger": "NSFileModificationDate \t String", "contents": "NSFileModificationDate" },{ "trigger": "NSPersonNameComponentKey \t String", "contents": "NSPersonNameComponentKey" },{ "trigger": "NSStreamSOCKSProxyPasswordKey \t String", "contents": "NSStreamSOCKSProxyPasswordKey" },{ "trigger": "localizedName \t func NSTimeZone -> String?" , "contents": "localizedName(${1:NSTimeZoneNameStyle}, locale:${2:NSLocale?})" },{ "trigger": "removeFromRunLoop \t func NSPort -> void" , "contents": "removeFromRunLoop(${1:NSRunLoop}, forMode:${2:String})" },{ "trigger": "NSSet \t array:" , "contents": "NSSet(${1:[AnyObject]})" },{ "trigger": "scanHexLongLong \t func NSScanner -> Bool" , "contents": "scanHexLongLong(${1:UnsafeMutablePointer<UInt64>})" },{ "trigger": "NSURL \t absoluteURLWithDataRepresentation: relativeToURL:" , "contents": "NSURL(absoluteURLWithDataRepresentation:${1:NSData}, relativeToURL:${2:NSURL?})" },{ "trigger": "successor \t func NSXMLNode -> Index" , "contents": "successor(${1:})" },{ "trigger": "NSNumber \t short:" , "contents": "NSNumber(short:${1:Int16})" },{ "trigger": "nanosecond \t Int", "contents": "nanosecond" },{ "trigger": "pausable \t Bool", "contents": "pausable" },{ "trigger": "NSLocaleUsesMetricSystem \t String", "contents": "NSLocaleUsesMetricSystem" },{ "trigger": "sessionDescription \t String", "contents": "sessionDescription" },{ "trigger": "valueForComponent \t func NSDateComponents -> Int" , "contents": "valueForComponent(${1:NSCalendarUnit})" },{ "trigger": "readDataOfLength \t func NSFileHandle -> NSData" , "contents": "readDataOfLength(${1:Int})" },{ "trigger": "NSDateIntervalFormatter \t NSDateIntervalFormatter", "contents": "NSDateIntervalFormatter" },{ "trigger": "removeCachedResponsesSinceDate \t func NSURLCache -> void" , "contents": "removeCachedResponsesSinceDate(${1:NSDate})" },{ "trigger": "kind \t NSXMLNodeKind", "contents": "kind" },{ "trigger": "stringFromByteCount \t func NSByteCountFormatter -> String" , "contents": "stringFromByteCount(${1:Int64})" },{ "trigger": "quarter \t Int", "contents": "quarter" },{ "trigger": "NSStreamNetworkServiceTypeBackground \t String", "contents": "NSStreamNetworkServiceTypeBackground" },{ "trigger": "indexOfObjectIdenticalTo \t func Generator -> Int" , "contents": "indexOfObjectIdenticalTo(${1:AnyObject}, inRange:${2:NSRange})" },{ "trigger": "copyWithZone \t func NSSortDescriptor -> AnyObject" , "contents": "copyWithZone(${1:NSZone})" },{ "trigger": "shouldResolveExternalEntities \t Bool", "contents": "shouldResolveExternalEntities" },{ "trigger": "moveObjectsAtIndexes \t func NSMutableOrderedSet -> void" , "contents": "moveObjectsAtIndexes(${1:NSIndexSet}, toIndex:${2:Int})" },{ "trigger": "decodeArrayOfObjCType \t func NSCoder -> void" , "contents": "decodeArrayOfObjCType(${1:UnsafePointer<Int8>}, count:${2:Int}, at:${3:UnsafeMutablePointer<Void>})" },{ "trigger": "getCredentialsForProtectionSpace \t func NSURLCredentialStorage -> Void" , "contents": "getCredentialsForProtectionSpace(${1:NSURLProtectionSpace}, task:${2:NSURLSessionTask}, completionHandler:${3:[String })" },{ "trigger": "removeObjectsInArray \t func NSMutableOrderedSet -> void" , "contents": "removeObjectsInArray(${1:[AnyObject]})" },{ "trigger": "NSTaskDidTerminateNotification \t String", "contents": "NSTaskDidTerminateNotification" },{ "trigger": "NSNotification \t name: object:" , "contents": "NSNotification(name:${1:String}, object:${2:AnyObject?})" },{ "trigger": "NSKeyedUnarchiver.classForClassName \t class NSKeyedUnarchiver -> AnyClass?" , "contents": "NSKeyedUnarchiver.classForClassName(${1:String})" },{ "trigger": "NSIndexSet \t indexSet:" , "contents": "NSIndexSet(${1:NSIndexSet})" },{ "trigger": "NSAffineTransform \t :" , "contents": "NSAffineTransform(${1:})" },{ "trigger": "bridge \t func String -> NSString" , "contents": "bridge(${1:})" },{ "trigger": "NSRegularExpression \t NSRegularExpression", "contents": "NSRegularExpression" },{ "trigger": "addChild \t func NSXMLDocument -> void" , "contents": "addChild(${1:NSXMLNode})" },{ "trigger": "NSNotificationQueue.defaultQueue \t class NSNotificationQueue -> NSNotificationQueue" , "contents": "NSNotificationQueue.defaultQueue(${1:})" },{ "trigger": "decodeFloatForKey \t func NSCoder -> Float" , "contents": "decodeFloatForKey(${1:String})" },{ "trigger": "NSSearchPathDomainMask \t rawValue:" , "contents": "NSSearchPathDomainMask(${1:UInt})" },{ "trigger": "indexOfObjectAtIndexes \t func NSOrderedSet -> Bool" , "contents": "indexOfObjectAtIndexes(${1:NSIndexSet}, options:${2:NSEnumerationOptions}, passingTest:${3:AnyObject}, Int:${4:}, UnsafeMutablePointer<ObjCBool>:${5:})" },{ "trigger": "removePort \t func NSRunLoop -> void" , "contents": "removePort(${1:NSPort}, forMode:${2:String})" },{ "trigger": "readDataOfMinLength \t func NSURLSessionStreamTask -> Void" , "contents": "readDataOfMinLength(${1:Int}, maxLength:${2:Int}, timeout:${3:NSTimeInterval}, completionHandler:${4:NSData?}, Bool:${5:}, NSError?:${6:})" },{ "trigger": "NSDecimalNumber \t coder:" , "contents": "NSDecimalNumber(coder:${1:NSCoder})" },{ "trigger": "NSPointFromString \t func unknown -> NSPoint" , "contents": "NSPointFromString(${1:String})" },{ "trigger": "NSString \t stringLiteral:" , "contents": "NSString(stringLiteral:${1:StaticString})" },{ "trigger": "encodeBool \t func NSCoder -> void" , "contents": "encodeBool(${1:Bool}, forKey:${2:String})" },{ "trigger": "lowercaseStringWithLocale \t func String -> String" , "contents": "lowercaseStringWithLocale(${1:NSLocale?})" },{ "trigger": "protocolFamily \t Int", "contents": "protocolFamily" },{ "trigger": "cookiesForURL \t func NSHTTPCookieStorage -> [NSHTTPCookie]?" , "contents": "cookiesForURL(${1:NSURL})" },{ "trigger": "numberOfRanges \t Int", "contents": "numberOfRanges" },{ "trigger": "phonetic \t Bool", "contents": "phonetic" },{ "trigger": "_bridgeToObject \t func Int -> NSNumber" , "contents": "_bridgeToObject(${1:})" },{ "trigger": "completedUnitCount \t Int", "contents": "completedUnitCount" },{ "trigger": "NSURLComponents \t NSURLComponents", "contents": "NSURLComponents" },{ "trigger": "NSStringCompareOptions \t NSStringCompareOptions", "contents": "NSStringCompareOptions" },{ "trigger": "decimalNumberByRaisingToPower \t func NSDecimalNumber -> NSDecimalNumber" , "contents": "decimalNumberByRaisingToPower(${1:Int})" },{ "trigger": "NSSocketPort \t protocolFamily: socketType: `protocol`: address:" , "contents": "NSSocketPort(protocolFamily:${1:Int32}, socketType:${2:Int32}, `protocol`:${3:Int32}, address:${4:NSData})" },{ "trigger": "subdataWithRange \t func NSData -> NSData" , "contents": "subdataWithRange(${1:NSRange})" },{ "trigger": "isOperatingSystemAtLeastVersion \t func NSProcessInfo -> Bool" , "contents": "isOperatingSystemAtLeastVersion(${1:NSOperatingSystemVersion})" },{ "trigger": "shouldProcessNamespaces \t Bool", "contents": "shouldProcessNamespaces" },{ "trigger": "isEqualToData \t func NSData -> Bool" , "contents": "isEqualToData(${1:NSData})" },{ "trigger": "enumerateRangesInRange \t func NSIndexSet -> Void" , "contents": "enumerateRangesInRange(${1:NSRange}, options:${2:NSEnumerationOptions}, usingBlock:${3:NSRange}, UnsafeMutablePointer<ObjCBool>:${4:})" },{ "trigger": "setPersistentDomain \t func NSUserDefaults -> void" , "contents": "setPersistentDomain(${1:[String }, forName:${2:String})" },{ "trigger": "NSStreamFileCurrentOffsetKey \t String", "contents": "NSStreamFileCurrentOffsetKey" },{ "trigger": "removeCharactersInRange \t func NSMutableCharacterSet -> void" , "contents": "removeCharactersInRange(${1:NSRange})" },{ "trigger": "NSMutableArray \t capacity:" , "contents": "NSMutableArray(capacity:${1:Int})" },{ "trigger": "NSMaxRange \t func unknown -> Int" , "contents": "NSMaxRange(${1:NSRange})" },{ "trigger": "NSPersonNameComponentNickname \t String", "contents": "NSPersonNameComponentNickname" },{ "trigger": "NSIndexPath \t index:" , "contents": "NSIndexPath(${1:Int})" },{ "trigger": "Generator \t objects: count:" , "contents": "Generator(${1:UnsafePointer<AnyObject?>}, count:${2:Int})" },{ "trigger": "NSCharacterSet.newlineCharacterSet \t class NSCharacterSet -> NSCharacterSet" , "contents": "NSCharacterSet.newlineCharacterSet(${1:})" },{ "trigger": "maxConcurrentOperationCount \t Int", "contents": "maxConcurrentOperationCount" },{ "trigger": "NSNumber \t booleanLiteral:" , "contents": "NSNumber(booleanLiteral:${1:Bool})" },{ "trigger": "allowEvaluation \t func NSExpression -> void" , "contents": "allowEvaluation(${1:})" },{ "trigger": "NSFileManager \t NSFileManager", "contents": "NSFileManager" },{ "trigger": "NSDataReadingOptions \t NSDataReadingOptions", "contents": "NSDataReadingOptions" },{ "trigger": "set \t Set", "contents": "set" },{ "trigger": "NSTemporaryDirectory \t func unknown -> String" , "contents": "NSTemporaryDirectory(${1:})" },{ "trigger": "zeroPadsFractionDigits \t Bool", "contents": "zeroPadsFractionDigits" },{ "trigger": "scanUnsignedLongLong \t func NSScanner -> Bool" , "contents": "scanUnsignedLongLong(${1:UnsafeMutablePointer<UInt64>})" },{ "trigger": "rawValue \t UInt", "contents": "rawValue" },{ "trigger": "NSDate \t :" , "contents": "NSDate(${1:})" },{ "trigger": "NSURLErrorNoPermissionsToReadFile \t Int", "contents": "NSURLErrorNoPermissionsToReadFile" },{ "trigger": "leapMonth \t Bool", "contents": "leapMonth" },{ "trigger": "NSHTTPCookieComment \t String", "contents": "NSHTTPCookieComment" },{ "trigger": "mutableCopyWithZone \t func NSString -> AnyObject" , "contents": "mutableCopyWithZone(${1:NSZone})" },{ "trigger": "scanLocation \t Int", "contents": "scanLocation" },{ "trigger": "NSStreamNetworkServiceTypeVoice \t String", "contents": "NSStreamNetworkServiceTypeVoice" },{ "trigger": "NSMutableData \t capacity:" , "contents": "NSMutableData(${1:Int})" },{ "trigger": "NSXMLNodeIsCDATA \t Int", "contents": "NSXMLNodeIsCDATA" },{ "trigger": "NSSocketPort \t :" , "contents": "NSSocketPort(${1:})" },{ "trigger": "rangeOfCharacterFromSet \t func NSString -> NSRange" , "contents": "rangeOfCharacterFromSet(${1:NSCharacterSet})" },{ "trigger": "setObject \t func NSCache -> void" , "contents": "setObject(${1:AnyObject}, forKey:${2:AnyObject}, cost:${3:Int})" },{ "trigger": "stringFromValue \t func NSLengthFormatter -> String" , "contents": "stringFromValue(${1:Double}, unit:${2:NSLengthFormatterUnit})" },{ "trigger": "previousFailureCount \t Int", "contents": "previousFailureCount" },{ "trigger": "NSKeyedUnarchiver.unarchiveObjectWithData \t class NSKeyedUnarchiver -> AnyObject?" , "contents": "NSKeyedUnarchiver.unarchiveObjectWithData(${1:NSData})" },{ "trigger": "uppercaseString \t String", "contents": "uppercaseString" },{ "trigger": "cookieAcceptPolicy \t NSHTTPCookieAcceptPolicy", "contents": "cookieAcceptPolicy" },{ "trigger": "NSOrderedSet \t NSOrderedSet", "contents": "NSOrderedSet" },{ "trigger": "minusSet \t func NSMutableOrderedSet -> void" , "contents": "minusSet(${1:Set<NSObject>})" },{ "trigger": "getEra \t func NSCalendar -> void" , "contents": "getEra(${1:UnsafeMutablePointer<Int>}, yearForWeekOfYear:${2:UnsafeMutablePointer<Int>}, weekOfYear:${3:UnsafeMutablePointer<Int>}, weekday:${4:UnsafeMutablePointer<Int>}, fromDate:${5:NSDate})" },{ "trigger": "NSProgress.discreteProgressWithTotalUnitCount \t class NSProgress -> NSProgress" , "contents": "NSProgress.discreteProgressWithTotalUnitCount(${1:Int64})" },{ "trigger": "copyWithZone \t func NSURLResponse -> AnyObject" , "contents": "copyWithZone(${1:NSZone})" },{ "trigger": "addObject \t func NSMutableArray -> void" , "contents": "addObject(${1:AnyObject})" },{ "trigger": "validDate \t Bool", "contents": "validDate" },{ "trigger": "NSJSONWritingOptions \t rawValue:" , "contents": "NSJSONWritingOptions(${1:UInt})" },{ "trigger": "URLsForResourcesWithExtension \t func NSBundle -> [NSURL]?" , "contents": "URLsForResourcesWithExtension(${1:String?}, subdirectory:${2:String?})" },{ "trigger": "comparator \t NSComparator", "contents": "comparator" },{ "trigger": "enumerateAttributesInRange \t func NSAttributedString -> Void" , "contents": "enumerateAttributesInRange(${1:NSRange}, options:${2:NSAttributedStringEnumerationOptions}, usingBlock:${3:[String }, NSRange:${4:}, UnsafeMutablePointer<ObjCBool>:${5:})" },{ "trigger": "NSMutableString \t NSMutableString", "contents": "NSMutableString" },{ "trigger": "columnNumber \t Int", "contents": "columnNumber" },{ "trigger": "NSCountedSet \t array:" , "contents": "NSCountedSet(${1:[AnyObject]})" },{ "trigger": "lengthOfBytesUsingEncoding \t func String -> Int" , "contents": "lengthOfBytesUsingEncoding(${1:NSStringEncoding})" },{ "trigger": "NSStringEnumerationOptions \t rawValue:" , "contents": "NSStringEnumerationOptions(${1:UInt})" },{ "trigger": "encodeBytes \t func NSCoder -> void" , "contents": "encodeBytes(${1:UnsafePointer<UInt8>}, length:${2:Int}, forKey:${3:String})" },{ "trigger": "NSCalendarIdentifierGregorian \t String", "contents": "NSCalendarIdentifierGregorian" },{ "trigger": "setArray \t func NSMutableArray -> void" , "contents": "setArray(${1:[AnyObject]})" },{ "trigger": "loaded \t Bool", "contents": "loaded" },{ "trigger": "NSValue.supportsSecureCoding \t class NSValue -> Bool" , "contents": "NSValue.supportsSecureCoding(${1:})" },{ "trigger": "objectEnumerator \t func NSSet -> NSEnumerator" , "contents": "objectEnumerator(${1:})" },{ "trigger": "minusOrderedSet \t func NSMutableOrderedSet -> void" , "contents": "minusOrderedSet(${1:NSOrderedSet})" },{ "trigger": "NSHTTPCookieSecure \t String", "contents": "NSHTTPCookieSecure" },{ "trigger": "_encodePropertyList \t func NSKeyedArchiver -> void" , "contents": "_encodePropertyList(${1:AnyObject}, forKey:${2:String? = nil})" },{ "trigger": "NSLocale.systemLocale \t class NSLocale -> NSLocale" , "contents": "NSLocale.systemLocale(${1:})" },{ "trigger": "sortedArrayUsingComparator \t func Generator -> [AnyObject]" , "contents": "sortedArrayUsingComparator(${1:NSComparator})" },{ "trigger": "NSLocaleAlternateQuotationEndDelimiterKey \t String", "contents": "NSLocaleAlternateQuotationEndDelimiterKey" },{ "trigger": "stringByReplacingMatchesInString \t func NSRegularExpression -> String" , "contents": "stringByReplacingMatchesInString(${1:String}, options:${2:NSMatchingOptions}, range:${3:NSRange}, withTemplate:${4:String})" },{ "trigger": "NSAffineTransform.supportsSecureCoding \t static NSAffineTransform -> Bool" , "contents": "NSAffineTransform.supportsSecureCoding(${1:})" },{ "trigger": "NSDecimalMultiply \t func unknown -> NSCalculationError" , "contents": "NSDecimalMultiply(${1:UnsafeMutablePointer<NSDecimal>}, _:${2:UnsafePointer<NSDecimal>}, _:${3:UnsafePointer<NSDecimal>}, _:${4:NSRoundingMode})" },{ "trigger": "NSString.supportsSecureCoding \t static NSString -> Bool" , "contents": "NSString.supportsSecureCoding(${1:})" },{ "trigger": "NSTimeZone \t name: data:" , "contents": "NSTimeZone(name:${1:String}, data:${2:NSData?})" },{ "trigger": "relativePath \t String", "contents": "relativePath" },{ "trigger": "getAllTasksWithCompletionHandler \t func NSURLSession -> Void" , "contents": "getAllTasksWithCompletionHandler(${1:[NSURLSessionTask] -> Void})" },{ "trigger": "left \t CGFloat", "contents": "left" },{ "trigger": "NSFileSystemNumber \t String", "contents": "NSFileSystemNumber" },{ "trigger": "String.defaultCStringEncoding \t static String -> NSStringEncoding" , "contents": "String.defaultCStringEncoding(${1:})" },{ "trigger": "NSDecimalNumberHandler \t NSDecimalNumberHandler", "contents": "NSDecimalNumberHandler" },{ "trigger": "NSHTTPCookiePath \t String", "contents": "NSHTTPCookiePath" },{ "trigger": "decodeIntegerForKey \t func NSCoder -> Int" , "contents": "decodeIntegerForKey(${1:String})" },{ "trigger": "sortedArrayWithOptions \t func Generator -> [AnyObject]" , "contents": "sortedArrayWithOptions(${1:NSSortOptions}, usingComparator:${2:NSComparator})" },{ "trigger": "scheduleInRunLoop \t func NSStream -> void" , "contents": "scheduleInRunLoop(${1:NSRunLoop}, forMode:${2:String})" },{ "trigger": "encodeWithCoder \t func NSAffineTransform -> void" , "contents": "encodeWithCoder(${1:NSCoder})" },{ "trigger": "copyWithZone \t func NSData -> AnyObject" , "contents": "copyWithZone(${1:NSZone})" },{ "trigger": "bridge \t func NSString -> String" , "contents": "bridge(${1:})" },{ "trigger": "ascending \t Bool", "contents": "ascending" },{ "trigger": "NSCompoundPredicate \t notPredicateWithSubpredicate:" , "contents": "NSCompoundPredicate(notPredicateWithSubpredicate:${1:NSPredicate})" },{ "trigger": "origin \t CGPoint", "contents": "origin" },{ "trigger": "NSProgressKindFile \t String", "contents": "NSProgressKindFile" },{ "trigger": "NSURLProtectionSpaceHTTP \t String", "contents": "NSURLProtectionSpaceHTTP" },{ "trigger": "NSURLErrorCannotMoveFile \t Int", "contents": "NSURLErrorCannotMoveFile" },{ "trigger": "NSDecimalNumber \t floatLiteral:" , "contents": "NSDecimalNumber(floatLiteral:${1:Double})" },{ "trigger": "displayNameAtPath \t func NSFileManager -> String" , "contents": "displayNameAtPath(${1:String})" },{ "trigger": "setDictionary \t func NSMutableDictionary -> void" , "contents": "setDictionary(${1:[NSObject })" },{ "trigger": "DTD \t NSXMLDTD", "contents": "DTD" },{ "trigger": "NSJSONReadingOptions \t rawValue:" , "contents": "NSJSONReadingOptions(${1:UInt})" },{ "trigger": "NSProgress.currentProgress \t class NSProgress -> NSProgress?" , "contents": "NSProgress.currentProgress(${1:})" },{ "trigger": "indexGreaterThanIndex \t func NSIndexSet -> Int" , "contents": "indexGreaterThanIndex(${1:Int})" },{ "trigger": "NSString \t contentsOfURL: usedEncoding:" , "contents": "NSString(contentsOfURL:${1:NSURL}, usedEncoding:${2:UnsafeMutablePointer<UInt>})" },{ "trigger": "value \t String", "contents": "value" },{ "trigger": "NSData \t data:" , "contents": "NSData(${1:NSData})" },{ "trigger": "availableData \t NSData", "contents": "availableData" },{ "trigger": "NSDecimalNumber.minimumDecimalNumber \t class NSDecimalNumber -> NSDecimalNumber" , "contents": "NSDecimalNumber.minimumDecimalNumber(${1:})" },{ "trigger": "objectValue \t func NSFormatter -> AnyObject?" , "contents": "objectValue(${1:String})" },{ "trigger": "decodePointForKey \t func NSCoder -> NSPoint" , "contents": "decodePointForKey(${1:String})" },{ "trigger": "encodePropertyList \t func NSKeyedArchiver -> void" , "contents": "encodePropertyList(${1:AnyObject}, forKey:${2:String})" },{ "trigger": "NSOutputStream \t toBuffer: capacity:" , "contents": "NSOutputStream(toBuffer:${1:UnsafeMutablePointer<UInt8>}, capacity:${2:Int})" },{ "trigger": "standardizedURL \t NSURL", "contents": "standardizedURL" },{ "trigger": "setCredential \t func NSURLCredentialStorage -> void" , "contents": "setCredential(${1:NSURLCredential}, forProtectionSpace:${2:NSURLProtectionSpace})" },{ "trigger": "NSCalendarIdentifierIndian \t String", "contents": "NSCalendarIdentifierIndian" },{ "trigger": "UUIDString \t String", "contents": "UUIDString" },{ "trigger": "Index \t Index", "contents": "Index" },{ "trigger": "containsObject \t func NSSet -> Bool" , "contents": "containsObject(${1:AnyObject})" },{ "trigger": "NSURL \t dataRepresentation: relativeToURL:" , "contents": "NSURL(dataRepresentation:${1:NSData}, relativeToURL:${2:NSURL?})" },{ "trigger": "localizesFormat \t Bool", "contents": "localizesFormat" },{ "trigger": "thousandSeparator \t String", "contents": "thousandSeparator" },{ "trigger": "detach \t func NSXMLNode -> void" , "contents": "detach(${1:})" },{ "trigger": "enumerateByteRangesUsingBlock \t func NSData -> Void" , "contents": "enumerateByteRangesUsingBlock(${1:UnsafePointer<Void>}, NSRange:${2:}, UnsafeMutablePointer<Bool>:${3:})" },{ "trigger": "CGSize \t width: height:" , "contents": "CGSize(${1:CGFloat}, height:${2:CGFloat})" },{ "trigger": "copy \t func NSCopying -> AnyObject" , "contents": "copy(${1:})" },{ "trigger": "NSString \t characters: length:" , "contents": "NSString(${1:UnsafePointer<unichar>}, length:${2:Int})" },{ "trigger": "compareObject \t func NSSortDescriptor -> NSComparisonResult" , "contents": "compareObject(${1:AnyObject}, toObject:${2:AnyObject})" },{ "trigger": "setDouble \t func NSUserDefaults -> void" , "contents": "setDouble(${1:Double}, forKey:${2:String})" },{ "trigger": "removeCharactersInString \t func NSMutableCharacterSet -> void" , "contents": "removeCharactersInString(${1:String})" },{ "trigger": "NSHTTPCookieDomain \t String", "contents": "NSHTTPCookieDomain" },{ "trigger": "NSRegularExpression.escapedTemplateForString \t class NSRegularExpression -> String" , "contents": "NSRegularExpression.escapedTemplateForString(${1:String})" },{ "trigger": "NSMutableString \t capacity:" , "contents": "NSMutableString(${1:Int})" },{ "trigger": "acceptInputForMode \t func NSRunLoop -> void" , "contents": "acceptInputForMode(${1:String}, beforeDate:${2:NSDate})" },{ "trigger": "NSIntersectionRange \t func unknown -> NSRange" , "contents": "NSIntersectionRange(${1:NSRange}, _:${2:NSRange})" },{ "trigger": "replaceObjectsInRange \t func NSMutableOrderedSet -> void" , "contents": "replaceObjectsInRange(${1:NSRange}, withObjects:${2:UnsafePointer<AnyObject?>}, count:${3:Int})" },{ "trigger": "waitUntilDate \t func NSCondition -> Bool" , "contents": "waitUntilDate(${1:NSDate})" },{ "trigger": "endEditing \t func NSMutableAttributedString -> void" , "contents": "endEditing(${1:})" },{ "trigger": "percentEncodedPath \t String", "contents": "percentEncodedPath" },{ "trigger": "String \t format: locale: arguments:" , "contents": "String(${1:String}, locale:${2:NSLocale?}, arguments:${3:[CVarArgType]})" },{ "trigger": "key \t String", "contents": "key" },{ "trigger": "laterDate \t func NSDate -> NSDate" , "contents": "laterDate(${1:NSDate})" },{ "trigger": "isFormattingError \t Bool", "contents": "isFormattingError" },{ "trigger": "NSMutableAttributedString \t NSMutableAttributedString", "contents": "NSMutableAttributedString" },{ "trigger": "resourceURL \t NSURL", "contents": "resourceURL" },{ "trigger": "compareDate \t func NSCalendar -> NSComparisonResult" , "contents": "compareDate(${1:NSDate}, toDate:${2:NSDate}, toUnitGranularity:${3:NSCalendarUnit})" },{ "trigger": "NSDate \t timeIntervalSince1970:" , "contents": "NSDate(timeIntervalSince1970:${1:NSTimeInterval})" },{ "trigger": "NSLocalizedDescriptionKey \t String", "contents": "NSLocalizedDescriptionKey" },{ "trigger": "createSymbolicLinkAtURL \t func NSFileManager -> void" , "contents": "createSymbolicLinkAtURL(${1:NSURL}, withDestinationURL:${2:NSURL})" },{ "trigger": "NSDecimalMultiplyByPowerOf10 \t func unknown -> NSCalculationError" , "contents": "NSDecimalMultiplyByPowerOf10(${1:UnsafeMutablePointer<NSDecimal>}, _:${2:UnsafePointer<NSDecimal>}, _:${3:Int16}, _:${4:NSRoundingMode})" },{ "trigger": "== \t func unknown -> Bool" , "contents": "==(${1:CGFloat}, rhs:${2:CGFloat})" },{ "trigger": "NSLocale.windowsLocaleCodeFromLocaleIdentifier \t class NSLocale -> UInt32" , "contents": "NSLocale.windowsLocaleCodeFromLocaleIdentifier(${1:String})" },{ "trigger": "NSNumber \t longLong:" , "contents": "NSNumber(longLong:${1:Int64})" },{ "trigger": "sortUsingComparator \t func NSMutableOrderedSet -> void" , "contents": "sortUsingComparator(${1:NSComparator})" },{ "trigger": "stringByAppendingPathExtension \t func NSString -> String?" , "contents": "stringByAppendingPathExtension(${1:String})" },{ "trigger": "NSMutableArray \t :" , "contents": "NSMutableArray(${1:})" },{ "trigger": "familyName \t String", "contents": "familyName" },{ "trigger": "NSProgressFileCompletedCountKey \t String", "contents": "NSProgressFileCompletedCountKey" },{ "trigger": "NSFileReferenceCount \t String", "contents": "NSFileReferenceCount" },{ "trigger": "== \t func unknown -> Bool" , "contents": "==(${1:CGPoint}, rhs:${2:CGPoint})" },{ "trigger": "sortWithOptions \t func NSMutableArray -> void" , "contents": "sortWithOptions(${1:NSSortOptions}, usingComparator:${2:NSComparator})" },{ "trigger": "scanInt \t func NSScanner -> Int32?" , "contents": "scanInt(${1:})" },{ "trigger": "NSTextCheckingResult \t NSTextCheckingResult", "contents": "NSTextCheckingResult" },{ "trigger": "expressionType \t NSExpressionType", "contents": "expressionType" },{ "trigger": "rangeAtIndex \t func NSTextCheckingResult -> NSRange" , "contents": "rangeAtIndex(${1:Int})" },{ "trigger": "stringForObjectValue \t func NSFormatter -> String?" , "contents": "stringForObjectValue(${1:AnyObject})" },{ "trigger": "NSCocoaError \t rawValue:" , "contents": "NSCocoaError(${1:Int})" },{ "trigger": "NSJSONSerialization.isValidJSONObject \t class NSJSONSerialization -> Bool" , "contents": "NSJSONSerialization.isValidJSONObject(${1:Any})" },{ "trigger": "unitStringFromKilograms \t func NSMassFormatter -> String" , "contents": "unitStringFromKilograms(${1:Double}, usedUnit:${2:UnsafeMutablePointer<NSMassFormatterUnit>})" },{ "trigger": "URLsForDirectory \t func NSFileManager -> [NSURL]" , "contents": "URLsForDirectory(${1:NSSearchPathDirectory}, inDomains:${2:NSSearchPathDomainMask})" },{ "trigger": "positiveFormat \t String", "contents": "positiveFormat" },{ "trigger": "NSThread.callStackReturnAddresses \t class NSThread -> [NSNumber]" , "contents": "NSThread.callStackReturnAddresses(${1:})" },{ "trigger": "URLByAppendingPathExtension \t func NSURL -> NSURL?" , "contents": "URLByAppendingPathExtension(${1:String})" },{ "trigger": "NSURLQueryItem \t coder:" , "contents": "NSURLQueryItem(coder:${1:NSCoder})" },{ "trigger": "precomposedStringWithCanonicalMapping \t String", "contents": "precomposedStringWithCanonicalMapping" },{ "trigger": "diskCapacity \t Int", "contents": "diskCapacity" },{ "trigger": "NSString \t CString: encoding:" , "contents": "NSString(CString:${1:UnsafePointer<Int8>}, encoding:${2:UInt})" },{ "trigger": "taskDescription \t String", "contents": "taskDescription" },{ "trigger": "HTTPCookieAcceptPolicy \t NSHTTPCookieAcceptPolicy", "contents": "HTTPCookieAcceptPolicy" },{ "trigger": "downloadTaskWithRequest \t func NSURLSession -> NSURLSessionDownloadTask" , "contents": "downloadTaskWithRequest(${1:NSURLRequest})" },{ "trigger": "removeVolatileDomainForName \t func NSUserDefaults -> void" , "contents": "removeVolatileDomainForName(${1:String})" },{ "trigger": "objectIsForcedForKey \t func NSUserDefaults -> Bool" , "contents": "objectIsForcedForKey(${1:String})" },{ "trigger": "objectsForXQuery \t func NSXMLNode -> [AnyObject]" , "contents": "objectsForXQuery(${1:String})" },{ "trigger": "port \t Int", "contents": "port" },{ "trigger": "localizedCompare \t func String -> NSComparisonResult" , "contents": "localizedCompare(${1:String})" },{ "trigger": "isFileError \t Bool", "contents": "isFileError" },{ "trigger": "objectsAtIndexes \t func Generator -> [AnyObject]" , "contents": "objectsAtIndexes(${1:NSIndexSet})" },{ "trigger": "systemVersion \t UInt", "contents": "systemVersion" },{ "trigger": "NSHTTPCookieVersion \t String", "contents": "NSHTTPCookieVersion" },{ "trigger": "NSString \t contentsOfFile: encoding:" , "contents": "NSString(contentsOfFile:${1:String}, encoding:${2:UInt})" },{ "trigger": "maximumIntegerDigits \t Int", "contents": "maximumIntegerDigits" },{ "trigger": "NSURLErrorBackgroundSessionWasDisconnected \t Int", "contents": "NSURLErrorBackgroundSessionWasDisconnected" },{ "trigger": "NSURLErrorCancelledReasonBackgroundUpdatesDisabled \t Int", "contents": "NSURLErrorCancelledReasonBackgroundUpdatesDisabled" },{ "trigger": "NSCalendarDayChangedNotification \t String", "contents": "NSCalendarDayChangedNotification" },{ "trigger": "entityDeclarationForName \t func NSXMLDTD -> NSXMLDTDNode?" , "contents": "entityDeclarationForName(${1:String})" },{ "trigger": "NSString \t unicodeScalarLiteral:" , "contents": "NSString(unicodeScalarLiteral:${1:StaticString})" },{ "trigger": "absoluteURL \t NSURL", "contents": "absoluteURL" },{ "trigger": "evaluateWithObject \t func NSPredicate -> Bool" , "contents": "evaluateWithObject(${1:AnyObject?})" },{ "trigger": "dataTaskWithURL \t func NSURLSession -> NSURLSessionDataTask" , "contents": "dataTaskWithURL(${1:NSURL})" },{ "trigger": "NSZone \t :" , "contents": "NSZone(${1:})" },{ "trigger": "decodeRectForKey \t func NSCoder -> NSRect" , "contents": "decodeRectForKey(${1:String})" },{ "trigger": "downloadTaskWithRequest \t func NSURLSession -> Void" , "contents": "downloadTaskWithRequest(${1:NSURLRequest}, completionHandler:${2:NSURL?}, NSURLResponse?:${3:}, NSError?:${4:})" },{ "trigger": "stackSize \t Int", "contents": "stackSize" },{ "trigger": "NSXMLNode.document \t class NSXMLNode -> AnyObject" , "contents": "NSXMLNode.document(${1:})" },{ "trigger": "transformPoint \t func NSAffineTransform -> NSPoint" , "contents": "transformPoint(${1:NSPoint})" },{ "trigger": "NSDateInterval \t start: end:" , "contents": "NSDateInterval(${1:NSDate}, end:${2:NSDate})" },{ "trigger": "Generator \t array: copyItems:" , "contents": "Generator(${1:[AnyObject]}, copyItems:${2:Bool})" },{ "trigger": "Generator \t object: forKey:" , "contents": "Generator(${1:AnyObject}, forKey:${2:NSCopying})" },{ "trigger": "NSComparisonPredicateOptions \t NSComparisonPredicateOptions", "contents": "NSComparisonPredicateOptions" },{ "trigger": "getRelationship \t func NSFileManager -> void" , "contents": "getRelationship(${1:UnsafeMutablePointer<NSURLRelationship>}, ofDirectory:${2:NSSearchPathDirectory}, inDomain:${3:NSSearchPathDomainMask}, toItemAtURL:${4:NSURL})" },{ "trigger": "isEqualToIndexSet \t func NSIndexSet -> Bool" , "contents": "isEqualToIndexSet(${1:NSIndexSet})" },{ "trigger": "NSOutputStream \t toFileAtPath: append:" , "contents": "NSOutputStream(toFileAtPath:${1:String}, append:${2:Bool})" },{ "trigger": "getDefaultCredentialForProtectionSpace \t func NSURLCredentialStorage -> Void" , "contents": "getDefaultCredentialForProtectionSpace(${1:NSURLProtectionSpace}, task:${2:NSURLSessionTask}, completionHandler:${3:NSURLCredential? -> Void})" },{ "trigger": "unionSet \t func NSMutableOrderedSet -> void" , "contents": "unionSet(${1:Set<NSObject>})" },{ "trigger": "NSURLAuthenticationMethodNTLM \t String", "contents": "NSURLAuthenticationMethodNTLM" },{ "trigger": "NSXMLNodeCompactEmptyElement \t Int", "contents": "NSXMLNodeCompactEmptyElement" },{ "trigger": "encodeWithCoder \t func UserClass -> void" , "contents": "encodeWithCoder(aCoder:${1:NSCoder})" },{ "trigger": "NSSizeToCGSize \t func unknown -> CGSize" , "contents": "NSSizeToCGSize(${1:NSSize})" },{ "trigger": "positiveInfinitySymbol \t String", "contents": "positiveInfinitySymbol" },{ "trigger": "setByAddingObjectsFromSet \t func NSSet -> Set NSObject " , "contents": "setByAddingObjectsFromSet(${1:Set<NSObject>})" },{ "trigger": "isProxy \t func NSObject -> Bool" , "contents": "isProxy(${1:})" },{ "trigger": "NSLocale.currentLocale \t class NSLocale -> NSLocale" , "contents": "NSLocale.currentLocale(${1:})" },{ "trigger": "NSTimeZone \t abbreviation:" , "contents": "NSTimeZone(${1:String})" },{ "trigger": "NSCalendarIdentifierEthiopicAmeteAlem \t String", "contents": "NSCalendarIdentifierEthiopicAmeteAlem" },{ "trigger": "NSCharacterSet \t contentsOfFile:" , "contents": "NSCharacterSet(contentsOfFile:${1:String})" },{ "trigger": "falseExpression \t NSExpression", "contents": "falseExpression" },{ "trigger": "NSStreamSOCKSProxyVersionKey \t String", "contents": "NSStreamSOCKSProxyVersionKey" },{ "trigger": "NSFileGroupOwnerAccountName \t String", "contents": "NSFileGroupOwnerAccountName" },{ "trigger": "NSURLCache.setSharedURLCache \t class NSURLCache -> void" , "contents": "NSURLCache.setSharedURLCache(${1:NSURLCache})" },{ "trigger": "NSXMLNodePreserveQuotes \t Int", "contents": "NSXMLNodePreserveQuotes" },{ "trigger": "removeObjectsAtIndexes \t func NSMutableArray -> void" , "contents": "removeObjectsAtIndexes(${1:NSIndexSet})" },{ "trigger": "percentEncodedQuery \t String", "contents": "percentEncodedQuery" },{ "trigger": "NSCharacterSet.URLQueryAllowedCharacterSet \t class NSCharacterSet -> NSCharacterSet" , "contents": "NSCharacterSet.URLQueryAllowedCharacterSet(${1:})" },{ "trigger": "includesApproximationPhrase \t Bool", "contents": "includesApproximationPhrase" },{ "trigger": "NSFileImmutable \t String", "contents": "NSFileImmutable" },{ "trigger": "parent \t NSXMLNode", "contents": "parent" },{ "trigger": "cachedResponseForRequest \t func NSURLCache -> NSCachedURLResponse?" , "contents": "cachedResponseForRequest(${1:NSURLRequest})" },{ "trigger": "encodeWithCoder \t func NSURLCredential -> void" , "contents": "encodeWithCoder(${1:NSCoder})" },{ "trigger": "longCharacterIsMember \t func NSCharacterSet -> Bool" , "contents": "longCharacterIsMember(${1:UTF32Char})" },{ "trigger": "NSSet \t :" , "contents": "NSSet(${1:})" },{ "trigger": "NSUUID \t UUIDString:" , "contents": "NSUUID(UUIDString:${1:String})" },{ "trigger": "NSEdgeInsetsZero \t NSEdgeInsets", "contents": "NSEdgeInsetsZero" },{ "trigger": "weekdayOrdinal \t Int", "contents": "weekdayOrdinal" },{ "trigger": "NSPersonNameComponentsFormatter.localizedStringFromPersonNameComponents \t class NSPersonNameComponentsFormatter -> String" , "contents": "NSPersonNameComponentsFormatter.localizedStringFromPersonNameComponents(${1:NSPersonNameComponents}, style:${2:NSPersonNameComponentsFormatterStyle}, options:${3:NSPersonNameComponentsFormatterOptions})" },{ "trigger": "filterUsingPredicate \t func NSMutableArray -> void" , "contents": "filterUsingPredicate(${1:NSPredicate})" },{ "trigger": "addValue \t func NSMutableURLRequest -> void" , "contents": "addValue(${1:String}, forHTTPHeaderField:${2:String})" },{ "trigger": "NSURLRequestCachePolicy \t NSURLRequestCachePolicy", "contents": "NSURLRequestCachePolicy" },{ "trigger": "encodeInteger \t func NSCoder -> void" , "contents": "encodeInteger(${1:Int}, forKey:${2:String})" },{ "trigger": "indexesPassingTest \t func NSIndexSet -> Bool" , "contents": "indexesPassingTest(${1:Int}, UnsafeMutablePointer<ObjCBool>:${2:})" },{ "trigger": "setUserInfoObject \t func NSProgress -> void" , "contents": "setUserInfoObject(${1:AnyObject?}, forKey:${2:String})" },{ "trigger": "translateXBy \t func NSAffineTransform -> void" , "contents": "translateXBy(${1:CGFloat}, yBy:${2:CGFloat})" },{ "trigger": "String._conditionallyBridgeFromObject \t static String -> Bool" , "contents": "String._conditionallyBridgeFromObject(${1:NSString}, inout:${2:String?})" },{ "trigger": "rangeOfData \t func NSData -> NSRange" , "contents": "rangeOfData(${1:NSData}, options:${2:NSDataSearchOptions}, range:${3:NSRange})" },{ "trigger": "x \t CGFloat", "contents": "x" },{ "trigger": "HTTPMethod \t String", "contents": "HTTPMethod" },{ "trigger": "downloadTaskWithResumeData \t func NSURLSession -> NSURLSessionDownloadTask" , "contents": "downloadTaskWithResumeData(${1:NSData})" },{ "trigger": "NSExpression \t NSExpression", "contents": "NSExpression" },{ "trigger": "suspended \t Bool", "contents": "suspended" },{ "trigger": "getLineStart \t func NSString -> void" , "contents": "getLineStart(${1:UnsafeMutablePointer<Int>}, end:${2:UnsafeMutablePointer<Int>}, contentsEnd:${3:UnsafeMutablePointer<Int>}, forRange:${4:NSRange})" },{ "trigger": "NSDateComponents \t :" , "contents": "NSDateComponents(${1:})" },{ "trigger": "capitalizedString \t String", "contents": "capitalizedString" },{ "trigger": "isWritableFileAtPath \t func NSFileManager -> Bool" , "contents": "isWritableFileAtPath(${1:String})" },{ "trigger": "NSNotificationQueue \t notificationCenter:" , "contents": "NSNotificationQueue(${1:NSNotificationCenter})" },{ "trigger": "removeObject \t func NSMutableSet -> void" , "contents": "removeObject(${1:AnyObject})" },{ "trigger": "mutableCopyWithZone \t func NSOrderedSet -> AnyObject" , "contents": "mutableCopyWithZone(${1:NSZone})" },{ "trigger": "addNamespace \t func NSXMLElement -> void" , "contents": "addNamespace(${1:NSXMLNode})" },{ "trigger": "NSURLProtocol \t task: cachedResponse: client:" , "contents": "NSURLProtocol(${1:NSURLSessionTask}, cachedResponse:${2:NSCachedURLResponse?}, client:${3:NSURLProtocolClient?})" },{ "trigger": "NSBundle \t identifier:" , "contents": "NSBundle(${1:String})" },{ "trigger": "removeIndexesInRange \t func NSMutableIndexSet -> void" , "contents": "removeIndexesInRange(${1:NSRange})" },{ "trigger": "reservedSpaceLength \t Int", "contents": "reservedSpaceLength" },{ "trigger": "objectByApplyingXSLTAtURL \t func NSXMLDocument -> AnyObject" , "contents": "objectByApplyingXSLTAtURL(${1:NSURL}, arguments:${2:[String })" },{ "trigger": "NSMutableDictionary \t sharedKeySet:" , "contents": "NSMutableDictionary(sharedKeySet:${1:AnyObject})" },{ "trigger": "NSURLErrorDataLengthExceedsMaximum \t Int", "contents": "NSURLErrorDataLengthExceedsMaximum" },{ "trigger": "replaceCharactersInRange \t func NSMutableString -> void" , "contents": "replaceCharactersInRange(${1:NSRange}, withString:${2:String})" },{ "trigger": "stringByAppendingPathComponent \t func String -> String" , "contents": "stringByAppendingPathComponent(${1:String})" },{ "trigger": "sortedArrayWithOptions \t func NSOrderedSet -> [AnyObject]" , "contents": "sortedArrayWithOptions(${1:NSSortOptions}, usingComparator:${2:NSComparator})" },{ "trigger": "stringByFoldingWithOptions \t func NSString -> String" , "contents": "stringByFoldingWithOptions(${1:NSStringCompareOptions}, locale:${2:NSLocale?})" },{ "trigger": "NSURLSessionDownloadTask \t NSURLSessionDownloadTask", "contents": "NSURLSessionDownloadTask" },{ "trigger": "setAttributes \t func NSMutableAttributedString -> void" , "contents": "setAttributes(${1:[String }, range:${2:NSRange})" },{ "trigger": "appendData \t func NSMutableData -> void" , "contents": "appendData(${1:NSData})" },{ "trigger": "dateWithEra \t func NSCalendar -> NSDate?" , "contents": "dateWithEra(${1:Int}, yearForWeekOfYear:${2:Int}, weekOfYear:${3:Int}, weekday:${4:Int}, hour:${5:Int}, minute:${6:Int}, second:${7:Int}, nanosecond:${8:Int})" },{ "trigger": "NSOrderedSet \t coder:" , "contents": "NSOrderedSet(coder:${1:NSCoder})" },{ "trigger": "writeToFile \t func NSData -> void" , "contents": "writeToFile(${1:String}, options:${2:NSDataWritingOptions})" },{ "trigger": "NSUserDefaults.standardUserDefaults \t class NSUserDefaults -> NSUserDefaults" , "contents": "NSUserDefaults.standardUserDefaults(${1:})" },{ "trigger": "indexLessThanIndex \t func NSIndexSet -> Int" , "contents": "indexLessThanIndex(${1:Int})" },{ "trigger": "decimalNumberByAdding \t func NSDecimalNumber -> NSDecimalNumber" , "contents": "decimalNumberByAdding(${1:NSDecimalNumber}, withBehavior:${2:NSDecimalNumberBehaviors?})" },{ "trigger": "NSExpression.expressionForAnyKey \t class NSExpression -> NSExpression" , "contents": "NSExpression.expressionForAnyKey(${1:})" },{ "trigger": "NSURLErrorFailingURLErrorKey \t String", "contents": "NSURLErrorFailingURLErrorKey" },{ "trigger": "mutableCopyWithZone \t func Generator -> AnyObject" , "contents": "mutableCopyWithZone(${1:NSZone})" },{ "trigger": "NSBundle \t URL:" , "contents": "NSBundle(URL:${1:NSURL})" },{ "trigger": "NSNumberFormatterPadPosition \t NSNumberFormatterPadPosition", "contents": "NSNumberFormatterPadPosition" },{ "trigger": "replacementObjectForCoder \t func NSObject -> AnyObject?" , "contents": "replacementObjectForCoder(${1:NSCoder})" },{ "trigger": "stringByAppendingPathComponent \t func NSString -> String" , "contents": "stringByAppendingPathComponent(${1:String})" },{ "trigger": "credentialsForProtectionSpace \t func NSURLCredentialStorage -> [String" , "contents": "credentialsForProtectionSpace(${1:NSURLProtectionSpace})" },{ "trigger": "NSURLAuthenticationMethodHTTPBasic \t String", "contents": "NSURLAuthenticationMethodHTTPBasic" },{ "trigger": "resetWithCompletionHandler \t func NSURLSession -> Void" , "contents": "resetWithCompletionHandler(${1: -> Void})" },{ "trigger": "NSNumber \t unsignedInt:" , "contents": "NSNumber(unsignedInt:${1:UInt32})" },{ "trigger": "removeObjectsInRange \t func NSMutableOrderedSet -> void" , "contents": "removeObjectsInRange(${1:NSRange})" },{ "trigger": "setRootElement \t func NSXMLDocument -> void" , "contents": "setRootElement(${1:NSXMLElement})" },{ "trigger": "NSStreamSOCKSProxyHostKey \t String", "contents": "NSStreamSOCKSProxyHostKey" },{ "trigger": "String \t UTF8String:" , "contents": "String(UTF8String:${1:UnsafePointer<CChar>})" },{ "trigger": "objectsWithOptions \t func NSSet -> Bool" , "contents": "objectsWithOptions(${1:NSEnumerationOptions}, passingTest:${2:AnyObject}, UnsafeMutablePointer<ObjCBool>:${3:})" },{ "trigger": "NSString \t extendedGraphemeClusterLiteral:" , "contents": "NSString(extendedGraphemeClusterLiteral:${1:StaticString})" },{ "trigger": "indexesOfObjectsAtIndexes \t func NSOrderedSet -> Bool" , "contents": "indexesOfObjectsAtIndexes(${1:NSIndexSet}, options:${2:NSEnumerationOptions}, passingTest:${3:AnyObject}, Int:${4:}, UnsafeMutablePointer<ObjCBool>:${5:})" },{ "trigger": "bridge \t func Dictionary -> NSDictionary" , "contents": "bridge(${1:})" },{ "trigger": "NSMutableURLRequest \t coder:" , "contents": "NSMutableURLRequest(coder:${1:NSCoder})" },{ "trigger": "compare \t func NSDate -> NSComparisonResult" , "contents": "compare(${1:NSDate})" },{ "trigger": "copyWithZone \t func NSURLSessionTask -> AnyObject" , "contents": "copyWithZone(${1:NSZone})" },{ "trigger": "enumerateObjectsWithOptions \t func Generator -> Void" , "contents": "enumerateObjectsWithOptions(${1:NSEnumerationOptions}, usingBlock:${2:AnyObject}, Int:${3:}, UnsafeMutablePointer<ObjCBool>:${4:})" },{ "trigger": "NSArray \t NSArray", "contents": "NSArray" },{ "trigger": "unknown \t :" , "contents": "unknown(${1:})" },{ "trigger": "NSUnicodeStringEncoding \t UInt", "contents": "NSUnicodeStringEncoding" },{ "trigger": "NSHTTPCookie.requestHeaderFieldsWithCookies \t class NSHTTPCookie -> [String" , "contents": "NSHTTPCookie.requestHeaderFieldsWithCookies(${1:[NSHTTPCookie]})" },{ "trigger": "copyWithZone \t func NSCachedURLResponse -> AnyObject" , "contents": "copyWithZone(${1:NSZone})" },{ "trigger": "NSStringFromPoint \t func unknown -> String" , "contents": "NSStringFromPoint(${1:NSPoint})" },{ "trigger": "linkItemAtURL \t func NSFileManager -> void" , "contents": "linkItemAtURL(${1:NSURL}, toURL:${2:NSURL})" },{ "trigger": "NSSocketPort \t coder:" , "contents": "NSSocketPort(coder:${1:NSCoder})" },{ "trigger": "NSBundle.URLForResource \t class NSBundle -> NSURL?" , "contents": "NSBundle.URLForResource(${1:String?}, withExtension:${2:String?}, subdirectory:${3:String?}, inBundleWithURL:${4:NSURL})" },{ "trigger": "NSXMLDTDNode \t kind: options:" , "contents": "NSXMLDTDNode(${1:NSXMLNodeKind}, options:${2:Int})" },{ "trigger": "NSMatchingOptions \t NSMatchingOptions", "contents": "NSMatchingOptions" },{ "trigger": "daylightSavingTimeOffset \t NSTimeInterval", "contents": "daylightSavingTimeOffset" },{ "trigger": "client \t NSURLProtocolClient", "contents": "client" },{ "trigger": "NSSizeFromCGSize \t func unknown -> NSSize" , "contents": "NSSizeFromCGSize(${1:CGSize})" },{ "trigger": "NSRegularExpression \t pattern: options:" , "contents": "NSRegularExpression(${1:String}, options:${2:NSRegularExpressionOptions})" },{ "trigger": "writeToURL \t func NSData -> void" , "contents": "writeToURL(${1:NSURL}, options:${2:NSDataWritingOptions})" },{ "trigger": "NSVolumeEnumerationOptions \t NSVolumeEnumerationOptions", "contents": "NSVolumeEnumerationOptions" },{ "trigger": "NSLengthFormatter \t coder:" , "contents": "NSLengthFormatter(${1:NSCoder})" },{ "trigger": "scanInteger \t func NSScanner -> Int?" , "contents": "scanInteger(${1:})" },{ "trigger": "addChild \t func NSXMLDTD -> void" , "contents": "addChild(${1:NSXMLNode})" },{ "trigger": "removeFromRunLoop \t func NSStream -> void" , "contents": "removeFromRunLoop(${1:NSRunLoop}, forMode:${2:String})" },{ "trigger": "copyWithZone \t func Generator -> AnyObject" , "contents": "copyWithZone(${1:NSZone})" },{ "trigger": "NSURLErrorCannotDecodeRawData \t Int", "contents": "NSURLErrorCannotDecodeRawData" },{ "trigger": "response \t NSURLResponse", "contents": "response" },{ "trigger": "NSPersonNameComponentsFormatterOptions \t rawValue:" , "contents": "NSPersonNameComponentsFormatterOptions(${1:UInt})" },{ "trigger": "scanDecimal \t func NSScanner -> Bool" , "contents": "scanDecimal(${1:UnsafeMutablePointer<NSDecimal>})" },{ "trigger": "postNotificationName \t func NSNotificationCenter -> void" , "contents": "postNotificationName(${1:String}, object:${2:AnyObject?})" },{ "trigger": "NSStreamSOCKSProxyPortKey \t String", "contents": "NSStreamSOCKSProxyPortKey" },{ "trigger": "URLForAuxiliaryExecutable \t func NSBundle -> NSURL?" , "contents": "URLForAuxiliaryExecutable(${1:String})" },{ "trigger": "removeChildAtIndex \t func NSXMLDocument -> void" , "contents": "removeChildAtIndex(${1:Int})" },{ "trigger": "NSXMLNodePreserveNamespaceOrder \t Int", "contents": "NSXMLNodePreserveNamespaceOrder" },{ "trigger": "NSURLQueryItem \t NSURLQueryItem", "contents": "NSURLQueryItem" },{ "trigger": "NSURLErrorServerCertificateHasUnknownRoot \t Int", "contents": "NSURLErrorServerCertificateHasUnknownRoot" },{ "trigger": "NSOperationQueuePriority \t NSOperationQueuePriority", "contents": "NSOperationQueuePriority" },{ "trigger": "setCookie \t func NSHTTPCookieStorage -> void" , "contents": "setCookie(${1:NSHTTPCookie})" },{ "trigger": "minimumRangeOfUnit \t func NSCalendar -> NSRange" , "contents": "minimumRangeOfUnit(${1:NSCalendarUnit})" },{ "trigger": "NSURLProtocol.canInitWithTask \t class NSURLProtocol -> Bool" , "contents": "NSURLProtocol.canInitWithTask(${1:NSURLSessionTask})" },{ "trigger": "daylightSavingTime \t Bool", "contents": "daylightSavingTime" },{ "trigger": "NSDecimalNormalize \t func unknown -> NSCalculationError" , "contents": "NSDecimalNormalize(${1:UnsafeMutablePointer<NSDecimal>}, _:${2:UnsafeMutablePointer<NSDecimal>}, _:${3:NSRoundingMode})" },{ "trigger": "enumeratorAtURL \t func NSFileManager -> Bool?" , "contents": "enumeratorAtURL(${1:NSURL}, includingPropertiesForKeys:${2:[String]?}, options:${3:NSDirectoryEnumerationOptions}, errorHandler:${4:NSURL}, NSError:${5:})" },{ "trigger": "NSCalendarIdentifierIslamicTabular \t String", "contents": "NSCalendarIdentifierIslamicTabular" },{ "trigger": "NSKeyedUnarchiver \t NSKeyedUnarchiver", "contents": "NSKeyedUnarchiver" },{ "trigger": "setObject \t func NSMutableDictionary -> void" , "contents": "setObject(${1:AnyObject}, forKey:${2:NSObject})" },{ "trigger": "keyEnumerator \t func Generator -> NSEnumerator" , "contents": "keyEnumerator(${1:})" },{ "trigger": "isEqualToArray \t func Generator -> Bool" , "contents": "isEqualToArray(${1:[AnyObject]})" },{ "trigger": "NSRegularExpressionOptions \t NSRegularExpressionOptions", "contents": "NSRegularExpressionOptions" },{ "trigger": "supportsSecureCoding \t func NSDateComponents -> Bool" , "contents": "supportsSecureCoding(${1:})" },{ "trigger": "shouldReportNamespacePrefixes \t Bool", "contents": "shouldReportNamespacePrefixes" },{ "trigger": "NSPredicate \t coder:" , "contents": "NSPredicate(coder:${1:NSCoder})" },{ "trigger": "addEntriesFromDictionary \t func NSMutableDictionary -> void" , "contents": "addEntriesFromDictionary(${1:[NSObject })" },{ "trigger": "NSCountedSet \t capacity:" , "contents": "NSCountedSet(capacity:${1:Int})" },{ "trigger": "indexesOfObjectsWithOptions \t func Generator -> Bool" , "contents": "indexesOfObjectsWithOptions(${1:NSEnumerationOptions}, passingTest:${2:AnyObject}, Int:${3:}, UnsafeMutablePointer<ObjCBool>:${4:})" },{ "trigger": "substringFromIndex \t func NSString -> String" , "contents": "substringFromIndex(${1:Int})" },{ "trigger": "NSNumber \t long:" , "contents": "NSNumber(long:${1:Int})" },{ "trigger": "proxyType \t String", "contents": "proxyType" },{ "trigger": "insertAttributedString \t func NSMutableAttributedString -> void" , "contents": "insertAttributedString(${1:NSAttributedString}, atIndex:${2:Int})" },{ "trigger": "generate \t func NSDictionary -> Generator" , "contents": "generate(${1:})" },{ "trigger": "dateWithEra \t func NSCalendar -> NSDate?" , "contents": "dateWithEra(${1:Int}, year:${2:Int}, month:${3:Int}, day:${4:Int}, hour:${5:Int}, minute:${6:Int}, second:${7:Int}, nanosecond:${8:Int})" },{ "trigger": "NSURLProtocol \t NSURLProtocol", "contents": "NSURLProtocol" },{ "trigger": "NSDictionary \t NSDictionary", "contents": "NSDictionary" },{ "trigger": "unlock \t func NSConditionLock -> void" , "contents": "unlock(${1:})" },{ "trigger": "stringFromDate \t func NSDateFormatter -> String" , "contents": "stringFromDate(${1:NSDate})" },{ "trigger": "stringByRemovingPercentEncoding \t String", "contents": "stringByRemovingPercentEncoding" },{ "trigger": "finishTasksAndInvalidate \t func NSURLSession -> void" , "contents": "finishTasksAndInvalidate(${1:})" },{ "trigger": "floatValue \t Float", "contents": "floatValue" },{ "trigger": "NSRangeFromString \t func unknown -> NSRange" , "contents": "NSRangeFromString(${1:String})" },{ "trigger": "floatForKey \t func NSUserDefaults -> Float" , "contents": "floatForKey(${1:String})" },{ "trigger": "_bridgeToObject \t func Double -> NSNumber" , "contents": "_bridgeToObject(${1:})" },{ "trigger": "filePathURL \t NSURL", "contents": "filePathURL" },{ "trigger": "NSCalendarUnit \t rawValue:" , "contents": "NSCalendarUnit(${1:UInt})" },{ "trigger": "NSXMLElement \t name: URI:" , "contents": "NSXMLElement(${1:String}, URI:${2:String?})" },{ "trigger": "NSHost \t address:" , "contents": "NSHost(${1:String})" },{ "trigger": "+ \t func unknown -> CGFloat" , "contents": "+(${1:CGFloat}, rhs:${2:CGFloat})" },{ "trigger": "operand \t NSExpression", "contents": "operand" },{ "trigger": "String.availableStringEncodings \t static String -> [NSStringEncoding]" , "contents": "String.availableStringEncodings(${1:})" },{ "trigger": "NSURLProtectionSpace \t host: port: `protocol`: realm: authenticationMethod:" , "contents": "NSURLProtectionSpace(${1:String}, port:${2:Int}, `protocol`:${3:String?}, realm:${4:String?}, authenticationMethod:${5:String?})" },{ "trigger": "NSZeroPoint \t NSPoint", "contents": "NSZeroPoint" },{ "trigger": "NSEdgeInsetsEqual \t func unknown -> Bool" , "contents": "NSEdgeInsetsEqual(${1:NSEdgeInsets}, _:${2:NSEdgeInsets})" },{ "trigger": "getParagraphStart \t func NSString -> void" , "contents": "getParagraphStart(${1:UnsafeMutablePointer<Int>}, end:${2:UnsafeMutablePointer<Int>}, contentsEnd:${3:UnsafeMutablePointer<Int>}, forRange:${4:NSRange})" },{ "trigger": "fileSystemRepresentationWithPath \t func NSFileManager -> UnsafePointer Int8 " , "contents": "fileSystemRepresentationWithPath(${1:String})" },{ "trigger": "customPlaygroundQuickLook \t func NSString -> PlaygroundQuickLook" , "contents": "customPlaygroundQuickLook(${1:})" },{ "trigger": "NSCalendar \t calendarIdentifier:" , "contents": "NSCalendar(calendarIdentifier:${1:String})" },{ "trigger": "NSMutableSet \t NSMutableSet", "contents": "NSMutableSet" },{ "trigger": "preflight \t func NSBundle -> void" , "contents": "preflight(${1:})" },{ "trigger": "NSSortDescriptor \t coder:" , "contents": "NSSortDescriptor(coder:${1:NSCoder})" },{ "trigger": "encodeWithCoder \t func NSRegularExpression -> void" , "contents": "encodeWithCoder(${1:NSCoder})" },{ "trigger": "receivesCredentialSecurely \t Bool", "contents": "receivesCredentialSecurely" },{ "trigger": "removeObjectAtIndex \t func NSMutableArray -> void" , "contents": "removeObjectAtIndex(${1:Int})" },{ "trigger": "objectForKey \t func NSCache -> AnyObject?" , "contents": "objectForKey(${1:AnyObject})" },{ "trigger": "removeObjectsInArray \t func NSMutableArray -> void" , "contents": "removeObjectsInArray(${1:[AnyObject]})" },{ "trigger": "rectValue \t NSRect", "contents": "rectValue" },{ "trigger": "NSIndexSet \t :" , "contents": "NSIndexSet(${1:})" },{ "trigger": "enqueueNotification \t func NSNotificationQueue -> void" , "contents": "enqueueNotification(${1:NSNotification}, postingStyle:${2:NSPostingStyle}, coalesceMask:${3:NSNotificationCoalescing}, forModes:${4:[String]?})" },{ "trigger": "unsignedIntegerValue \t UInt", "contents": "unsignedIntegerValue" },{ "trigger": "password \t String", "contents": "password" },{ "trigger": "cancelByProducingResumeData \t func NSURLSessionDownloadTask -> Void" , "contents": "cancelByProducingResumeData(${1:NSData? -> Void})" },{ "trigger": "NSInputStream \t fileAtPath:" , "contents": "NSInputStream(fileAtPath:${1:String})" },{ "trigger": "NSNumber \t unsignedLongLong:" , "contents": "NSNumber(unsignedLongLong:${1:UInt64})" },{ "trigger": "NSURLQueryItem.supportsSecureCoding \t static NSURLQueryItem -> Bool" , "contents": "NSURLQueryItem.supportsSecureCoding(${1:})" },{ "trigger": "NSURLCredential \t user: password: persistence:" , "contents": "NSURLCredential(${1:String}, password:${2:String}, persistence:${3:NSURLCredentialPersistence})" },{ "trigger": "NSUserDefaults \t NSUserDefaults", "contents": "NSUserDefaults" },{ "trigger": "standalone \t Bool", "contents": "standalone" },{ "trigger": "NSScanner.localizedScannerWithString \t class NSScanner -> AnyObject" , "contents": "NSScanner.localizedScannerWithString(${1:String})" },{ "trigger": "UserClass \t UserClass", "contents": "UserClass" },{ "trigger": "NSDecimal \t :" , "contents": "NSDecimal(${1:})" },{ "trigger": "NSError \t coder:" , "contents": "NSError(coder:${1:NSCoder})" },{ "trigger": "encodePoint \t func NSCoder -> void" , "contents": "encodePoint(${1:NSPoint})" },{ "trigger": "setObject \t func NSUserDefaults -> void" , "contents": "setObject(${1:AnyObject?}, forKey:${2:String})" },{ "trigger": "propertyForKey \t func NSStream -> AnyObject?" , "contents": "propertyForKey(${1:String})" },{ "trigger": "level \t Int", "contents": "level" },{ "trigger": "localizedLowercaseString \t String", "contents": "localizedLowercaseString" },{ "trigger": "dateBySettingUnit \t func NSCalendar -> NSDate?" , "contents": "dateBySettingUnit(${1:NSCalendarUnit}, value:${2:Int}, ofDate:${3:NSDate}, options:${4:NSCalendarOptions})" },{ "trigger": "allowsFractionalUnits \t Bool", "contents": "allowsFractionalUnits" },{ "trigger": "NSMutableDictionary \t objects: forKeys: count:" , "contents": "NSMutableDictionary(${1:UnsafePointer<AnyObject>}, forKeys:${2:UnsafePointer<NSObject>}, count:${3:Int})" },{ "trigger": "addDependency \t func NSOperation -> void" , "contents": "addDependency(${1:NSOperation})" },{ "trigger": "encodePoint \t func NSCoder -> void" , "contents": "encodePoint(${1:NSPoint}, forKey:${2:String})" },{ "trigger": "uppercaseStringWithLocale \t func NSString -> String" , "contents": "uppercaseStringWithLocale(${1:NSLocale?})" },{ "trigger": "NSTimer.scheduledTimer \t class NSTimer -> Void" , "contents": "NSTimer.scheduledTimer(${1:NSTimeInterval}, repeats:${2:Bool}, fire:${3:NSTimer -> Void})" },{ "trigger": "copyWithZone \t func NSOrderedSet -> AnyObject" , "contents": "copyWithZone(${1:NSZone})" },{ "trigger": "NSFileHandleNotificationDataItem \t String", "contents": "NSFileHandleNotificationDataItem" },{ "trigger": "attributedSubstringFromRange \t func NSAttributedString -> NSAttributedString" , "contents": "attributedSubstringFromRange(${1:NSRange})" },{ "trigger": "NSClassFromString \t func unknown -> AnyClass?" , "contents": "NSClassFromString(${1:String})" },{ "trigger": "NSLocaleGroupingSeparator \t String", "contents": "NSLocaleGroupingSeparator" },{ "trigger": "filteredSetUsingPredicate \t func NSSet -> Set NSObject " , "contents": "filteredSetUsingPredicate(${1:NSPredicate})" },{ "trigger": "rangeOfFirstMatchInString \t func NSRegularExpression -> NSRange" , "contents": "rangeOfFirstMatchInString(${1:String}, options:${2:NSMatchingOptions}, range:${3:NSRange})" },{ "trigger": "nextDateAfterDate \t func NSCalendar -> NSDate?" , "contents": "nextDateAfterDate(${1:NSDate}, matchingComponents:${2:NSDateComponents}, options:${3:NSCalendarOptions})" },{ "trigger": "limitDateForMode \t func NSRunLoop -> NSDate?" , "contents": "limitDateForMode(${1:String})" },{ "trigger": "suspend \t func NSTask -> Bool" , "contents": "suspend(${1:})" },{ "trigger": "encodeWithCoder \t func NSTextCheckingResult -> void" , "contents": "encodeWithCoder(${1:NSCoder})" },{ "trigger": "generate \t func NSSet -> Generator" , "contents": "generate(${1:})" },{ "trigger": "NSURLErrorCannotCreateFile \t Int", "contents": "NSURLErrorCannotCreateFile" },{ "trigger": "NSNull \t coder:" , "contents": "NSNull(coder:${1:NSCoder})" },{ "trigger": "registerDefaults \t func NSUserDefaults -> void" , "contents": "registerDefaults(${1:[String })" },{ "trigger": "NSOrderedSet.supportsSecureCoding \t static NSOrderedSet -> Bool" , "contents": "NSOrderedSet.supportsSecureCoding(${1:})" },{ "trigger": "encodeWithCoder \t func NSSet -> void" , "contents": "encodeWithCoder(${1:NSCoder})" },{ "trigger": "NSTimeZone.resetSystemTimeZone \t class NSTimeZone -> void" , "contents": "NSTimeZone.resetSystemTimeZone(${1:})" },{ "trigger": "NSMutableSet \t objects: count:" , "contents": "NSMutableSet(${1:UnsafePointer<AnyObject?>}, count:${2:Int})" },{ "trigger": "unlock \t func NSCondition -> void" , "contents": "unlock(${1:})" },{ "trigger": "unsignedShortValue \t UInt", "contents": "unsignedShortValue" },{ "trigger": "positiveSuffix \t String", "contents": "positiveSuffix" },{ "trigger": "NSCoder \t NSCoder", "contents": "NSCoder" },{ "trigger": "NSKeyedArchiver.classNameForClass \t class NSKeyedArchiver -> String?" , "contents": "NSKeyedArchiver.classNameForClass(${1:AnyClass})" },{ "trigger": "String._forceBridgeFromObject \t static String -> void" , "contents": "String._forceBridgeFromObject(${1:NSString}, inout:${2:String?})" },{ "trigger": "waitUntilFinished \t func NSOperation -> void" , "contents": "waitUntilFinished(${1:})" },{ "trigger": "indexOfObjectIdenticalTo \t func Generator -> Int" , "contents": "indexOfObjectIdenticalTo(${1:AnyObject})" },{ "trigger": "NSURLErrorFileIsDirectory \t Int", "contents": "NSURLErrorFileIsDirectory" },{ "trigger": "NSProgress \t totalUnitCount: parent: pendingUnitCount:" , "contents": "NSProgress(totalUnitCount:${1:Int64}, parent:${2:NSProgress}, pendingUnitCount:${3:Int64})" },{ "trigger": "streamTaskWithHostName \t func NSURLSession -> NSURLSessionStreamTask" , "contents": "streamTaskWithHostName(${1:String}, port:${2:Int})" },{ "trigger": "CGFloat \t _:" , "contents": "CGFloat(_:${1:Float})" },{ "trigger": "NSURLProtocol.propertyForKey \t class NSURLProtocol -> AnyObject?" , "contents": "NSURLProtocol.propertyForKey(${1:String}, inRequest:${2:NSURLRequest})" },{ "trigger": "NSURLCredentialPersistence \t NSURLCredentialPersistence", "contents": "NSURLCredentialPersistence" },{ "trigger": "timeIntervalSinceReferenceDate \t NSTimeInterval", "contents": "timeIntervalSinceReferenceDate" },{ "trigger": "removeLastObject \t func NSMutableArray -> void" , "contents": "removeLastObject(${1:})" },{ "trigger": "base64EncodedStringWithOptions \t func NSData -> String" , "contents": "base64EncodedStringWithOptions(${1:NSDataBase64EncodingOptions})" },{ "trigger": "stringFromNumber \t func NSNumberFormatter -> String?" , "contents": "stringFromNumber(${1:NSNumber})" },{ "trigger": "totalUnitCount \t Int", "contents": "totalUnitCount" },{ "trigger": "keysOfEntriesWithOptions \t func Generator -> Bool" , "contents": "keysOfEntriesWithOptions(${1:NSEnumerationOptions}, passingTest:${2:AnyObject}, AnyObject:${3:}, UnsafeMutablePointer<ObjCBool>:${4:})" },{ "trigger": "NSNumber \t unsignedShort:" , "contents": "NSNumber(unsignedShort:${1:UInt16})" },{ "trigger": "NSStringEnumerationOptions \t NSStringEnumerationOptions", "contents": "NSStringEnumerationOptions" },{ "trigger": "NSMassFormatterUnit \t NSMassFormatterUnit", "contents": "NSMassFormatterUnit" },{ "trigger": "NSOrderedSet \t array:" , "contents": "NSOrderedSet(${1:[AnyObject]})" },{ "trigger": "CGRect \t CGRect", "contents": "CGRect" },{ "trigger": "NSOrderedSet \t object:" , "contents": "NSOrderedSet(${1:AnyObject})" },{ "trigger": "right \t CGFloat", "contents": "right" },{ "trigger": "NSNEXTSTEPStringEncoding \t UInt", "contents": "NSNEXTSTEPStringEncoding" },{ "trigger": "encodeWithCoder \t func NSNotification -> void" , "contents": "encodeWithCoder(${1:NSCoder})" },{ "trigger": "year \t Int", "contents": "year" },{ "trigger": "decimalNumberBySubtracting \t func NSDecimalNumber -> NSDecimalNumber" , "contents": "decimalNumberBySubtracting(${1:NSDecimalNumber})" },{ "trigger": "tryLock \t func NSRecursiveLock -> Bool" , "contents": "tryLock(${1:})" },{ "trigger": "maximumUnitCount \t Int", "contents": "maximumUnitCount" },{ "trigger": "NSError.supportsSecureCoding \t static NSError -> Bool" , "contents": "NSError.supportsSecureCoding(${1:})" },{ "trigger": "isReadableFileAtPath \t func NSFileManager -> Bool" , "contents": "isReadableFileAtPath(${1:String})" },{ "trigger": "NSTimeZone.abbreviationDictionary \t class NSTimeZone -> [String" , "contents": "NSTimeZone.abbreviationDictionary(${1:})" },{ "trigger": "encodeWithCoder \t func NSDecimalNumberHandler -> void" , "contents": "encodeWithCoder(${1:NSCoder})" },{ "trigger": "height \t CGFloat", "contents": "height" },{ "trigger": "NSMutableIndexSet \t NSMutableIndexSet", "contents": "NSMutableIndexSet" },{ "trigger": "NSDecimalDivide \t func unknown -> NSCalculationError" , "contents": "NSDecimalDivide(${1:UnsafeMutablePointer<NSDecimal>}, _:${2:UnsafePointer<NSDecimal>}, _:${3:UnsafePointer<NSDecimal>}, _:${4:NSRoundingMode})" },{ "trigger": "task \t NSURLSessionTask", "contents": "task" },{ "trigger": "indexOfObject \t func Generator -> Int" , "contents": "indexOfObject(${1:AnyObject}, inSortedRange:${2:NSRange}, options:${3:NSBinarySearchingOptions}, usingComparator:${4:NSComparator})" },{ "trigger": "threadPriority \t Double", "contents": "threadPriority" },{ "trigger": "NSXMLNode.processingInstructionWithName \t class NSXMLNode -> AnyObject" , "contents": "NSXMLNode.processingInstructionWithName(${1:String}, stringValue:${2:String})" },{ "trigger": "notANumberSymbol \t String", "contents": "notANumberSymbol" },{ "trigger": "NSDecimalMaxSize \t Int", "contents": "NSDecimalMaxSize" },{ "trigger": "sendBeforeDate \t func NSPort -> Bool" , "contents": "sendBeforeDate(${1:NSDate}, components:${2:NSMutableArray?}, from:${3:NSPort?}, reserved:${4:Int})" },{ "trigger": "NSURLAuthenticationMethodHTTPDigest \t String", "contents": "NSURLAuthenticationMethodHTTPDigest" },{ "trigger": "endIndex \t Index", "contents": "endIndex" },{ "trigger": "NSPort \t :" , "contents": "NSPort(${1:})" },{ "trigger": "yearForWeekOfYear \t Int", "contents": "yearForWeekOfYear" },{ "trigger": "proposedCredential \t NSURLCredential", "contents": "proposedCredential" },{ "trigger": "objectAtIndex \t func NSOrderedSet -> AnyObject" , "contents": "objectAtIndex(${1:Int})" },{ "trigger": "NSURLRequest \t NSURLRequest", "contents": "NSURLRequest" },{ "trigger": "indexOfObjectWithOptions \t func NSOrderedSet -> Bool" , "contents": "indexOfObjectWithOptions(${1:NSEnumerationOptions}, passingTest:${2:AnyObject}, Int:${3:}, UnsafeMutablePointer<ObjCBool>:${4:})" },{ "trigger": "NSURLSessionConfiguration \t NSURLSessionConfiguration", "contents": "NSURLSessionConfiguration" },{ "trigger": "components \t func NSCalendar -> NSDateComponents?" , "contents": "components(${1:NSCalendarUnit}, fromDateComponents:${2:NSDateComponents}, toDateComponents:${3:NSDateComponents}, options:${4:NSCalendarOptions})" },{ "trigger": "/ \t func unknown -> CGFloat" , "contents": "/(${1:CGFloat}, rhs:${2:CGFloat})" },{ "trigger": "phoneticRepresentation \t NSPersonNameComponents", "contents": "phoneticRepresentation" },{ "trigger": "NSOrderedSet \t objects: count:" , "contents": "NSOrderedSet(${1:UnsafePointer<AnyObject?>}, count:${2:Int})" },{ "trigger": "longLongValue \t Int", "contents": "longLongValue" },{ "trigger": "NSURLErrorDownloadDecodingFailedMidStream \t Int", "contents": "NSURLErrorDownloadDecodingFailedMidStream" },{ "trigger": "rawValue \t :", "contents": "rawValue" },{ "trigger": "NSNumber \t float:" , "contents": "NSNumber(float:${1:Float})" },{ "trigger": "object \t AnyObject", "contents": "object" },{ "trigger": "transformSize \t func NSAffineTransform -> NSSize" , "contents": "transformSize(${1:NSSize})" },{ "trigger": "NSFileManagerItemReplacementOptions \t rawValue:" , "contents": "NSFileManagerItemReplacementOptions(${1:UInt})" },{ "trigger": "native \t NativeType", "contents": "native" },{ "trigger": "NSFileHandleNotificationFileHandleItem \t String", "contents": "NSFileHandleNotificationFileHandleItem" },{ "trigger": "insertObjects \t func NSMutableOrderedSet -> void" , "contents": "insertObjects(${1:[AnyObject]}, atIndexes:${2:NSIndexSet})" },{ "trigger": "NSRegularExpression \t coder:" , "contents": "NSRegularExpression(coder:${1:NSCoder})" },{ "trigger": "NSKeyedUnarchiver.unarchiveTopLevelObjectWithData \t class NSKeyedUnarchiver -> AnyObject?" , "contents": "NSKeyedUnarchiver.unarchiveTopLevelObjectWithData(${1:NSData})" },{ "trigger": "open \t func NSStream -> void" , "contents": "open(${1:})" },{ "trigger": "socketType \t Int", "contents": "socketType" },{ "trigger": "NSURLErrorResourceUnavailable \t Int", "contents": "NSURLErrorResourceUnavailable" },{ "trigger": "lowercaseString \t String", "contents": "lowercaseString" },{ "trigger": "NSAffineTransform \t transform:" , "contents": "NSAffineTransform(${1:NSAffineTransform})" },{ "trigger": "closeRead \t func NSURLSessionStreamTask -> void" , "contents": "closeRead(${1:})" },{ "trigger": "NSBlockOperation \t NSBlockOperation", "contents": "NSBlockOperation" },{ "trigger": "removeCredential \t func NSURLCredentialStorage -> void" , "contents": "removeCredential(${1:NSURLCredential}, forProtectionSpace:${2:NSURLProtectionSpace})" },{ "trigger": "Generator.supportsSecureCoding \t static Generator -> Bool" , "contents": "Generator.supportsSecureCoding(${1:})" },{ "trigger": "month \t Int", "contents": "month" },{ "trigger": "NSLocale.supportsSecureCoding \t static NSLocale -> Bool" , "contents": "NSLocale.supportsSecureCoding(${1:})" },{ "trigger": "encodeWithCoder \t func NSPort -> void" , "contents": "encodeWithCoder(${1:NSCoder})" },{ "trigger": "nextObject \t func NSEnumerator -> AnyObject?" , "contents": "nextObject(${1:})" },{ "trigger": "scanHexInt \t func NSScanner -> UInt32?" , "contents": "scanHexInt(${1:})" },{ "trigger": "skipDescendants \t func NSDirectoryEnumerator -> void" , "contents": "skipDescendants(${1:})" },{ "trigger": "nextDaylightSavingTimeTransition \t NSDate", "contents": "nextDaylightSavingTimeTransition" },{ "trigger": "scanLongLong \t func NSScanner -> Int64?" , "contents": "scanLongLong(${1:})" },{ "trigger": "NSURLProtocol.removePropertyForKey \t class NSURLProtocol -> void" , "contents": "NSURLProtocol.removePropertyForKey(${1:String}, inRequest:${2:NSMutableURLRequest})" },{ "trigger": "insertString \t func NSMutableString -> void" , "contents": "insertString(${1:String}, atIndex:${2:Int})" },{ "trigger": "delegate \t NSURLSessionDelegate", "contents": "delegate" },{ "trigger": "NSPipe \t :" , "contents": "NSPipe(${1:})" },{ "trigger": "NSEnumerationOptions \t rawValue:" , "contents": "NSEnumerationOptions(${1:UInt})" },{ "trigger": "privateFrameworksPath \t String", "contents": "privateFrameworksPath" },{ "trigger": "tY \t CGFloat", "contents": "tY" },{ "trigger": "NSString \t format: arguments:" , "contents": "NSString(${1:String}, arguments:${2:CVaListPointer})" },{ "trigger": "startOfDayForDate \t func NSCalendar -> NSDate" , "contents": "startOfDayForDate(${1:NSDate})" },{ "trigger": "removeCookiesSinceDate \t func NSHTTPCookieStorage -> void" , "contents": "removeCookiesSinceDate(${1:NSDate})" },{ "trigger": "path \t String", "contents": "path" },{ "trigger": "indexPassingTest \t func NSIndexSet -> Bool" , "contents": "indexPassingTest(${1:Int}, UnsafeMutablePointer<ObjCBool>:${2:})" },{ "trigger": "NSJSONSerialization \t NSJSONSerialization", "contents": "NSJSONSerialization" },{ "trigger": "componentsSeparatedByString \t func String -> [String]" , "contents": "componentsSeparatedByString(${1:String})" },{ "trigger": "arrayByAddingObject \t func Generator -> [AnyObject]" , "contents": "arrayByAddingObject(${1:AnyObject})" },{ "trigger": "adaptive \t Bool", "contents": "adaptive" },{ "trigger": "appendTransform \t func NSAffineTransform -> void" , "contents": "appendTransform(${1:NSAffineTransform})" },{ "trigger": "removeObjectIdenticalTo \t func NSMutableArray -> void" , "contents": "removeObjectIdenticalTo(${1:AnyObject}, inRange:${2:NSRange})" },{ "trigger": "NSInputStream \t NSInputStream", "contents": "NSInputStream" },{ "trigger": "NSURL \t NSURL", "contents": "NSURL" },{ "trigger": "weekOfYear \t Int", "contents": "weekOfYear" },{ "trigger": "setObject \t func NSCache -> void" , "contents": "setObject(${1:AnyObject}, forKey:${2:AnyObject})" },{ "trigger": "NSFileTypeDirectory \t String", "contents": "NSFileTypeDirectory" },{ "trigger": "allowEvaluation \t func NSSortDescriptor -> void" , "contents": "allowEvaluation(${1:})" },{ "trigger": "createDirectoryAtPath \t func NSFileManager -> void" , "contents": "createDirectoryAtPath(${1:String}, withIntermediateDirectories:${2:Bool}, attributes:${3:[String })" },{ "trigger": "decimalNumberByMultiplyingByPowerOf10 \t func NSDecimalNumber -> NSDecimalNumber" , "contents": "decimalNumberByMultiplyingByPowerOf10(${1:Int16})" },{ "trigger": "decodeObjectOfClassDecodedObjectType \t func NSCoder -> DecodedObjectType?" , "contents": "decodeObjectOfClassDecodedObjectType(${1:DecodedObjectType.Type}, forKey:${2:String})" },{ "trigger": "NSMakeSize \t func unknown -> NSSize" , "contents": "NSMakeSize(${1:CGFloat}, _:${2:CGFloat})" },{ "trigger": "isEqualToString \t func NSString -> Bool" , "contents": "isEqualToString(${1:String})" },{ "trigger": "objectsForXQuery \t func NSXMLNode -> [AnyObject]" , "contents": "objectsForXQuery(${1:String}, constants:${2:[String })" },{ "trigger": "NSStringEncodingErrorKey \t String", "contents": "NSStringEncodingErrorKey" },{ "trigger": "NSKeyedUnarchiver.unarchiveObjectWithFile \t class NSKeyedUnarchiver -> AnyObject?" , "contents": "NSKeyedUnarchiver.unarchiveObjectWithFile(${1:String})" },{ "trigger": "rawValue \t Int", "contents": "rawValue" },{ "trigger": "NSArgumentDomain \t String", "contents": "NSArgumentDomain" },{ "trigger": "persistence \t NSURLCredentialPersistence", "contents": "persistence" },{ "trigger": "NSCompoundPredicate \t NSCompoundPredicate", "contents": "NSCompoundPredicate" },{ "trigger": "stringFromDate \t func NSDateComponentsFormatter -> String?" , "contents": "stringFromDate(${1:NSDate}, toDate:${2:NSDate})" },{ "trigger": "seekToEndOfFile \t func NSFileHandle -> UInt64" , "contents": "seekToEndOfFile(${1:})" },{ "trigger": "NSNumber \t unsignedChar:" , "contents": "NSNumber(unsignedChar:${1:UInt8})" },{ "trigger": "NSPredicate \t NSPredicate", "contents": "NSPredicate" },{ "trigger": "encodeSize \t func NSCoder -> void" , "contents": "encodeSize(${1:NSSize}, forKey:${2:String})" },{ "trigger": "addAttributes \t func NSMutableAttributedString -> void" , "contents": "addAttributes(${1:[String }, range:${2:NSRange})" },{ "trigger": "NSEnergyFormatter \t NSEnergyFormatter", "contents": "NSEnergyFormatter" },{ "trigger": "NSObject.classFallbacksForKeyedArchiver \t class NSObject -> [String]" , "contents": "NSObject.classFallbacksForKeyedArchiver(${1:})" },{ "trigger": "waitUntilAllOperationsAreFinished \t func NSOperationQueue -> void" , "contents": "waitUntilAllOperationsAreFinished(${1:})" },{ "trigger": "NSCalendarIdentifierIslamic \t String", "contents": "NSCalendarIdentifierIslamic" },{ "trigger": "scanString \t func NSScanner -> String?" , "contents": "scanString(string:${1:String})" },{ "trigger": "decodeIntForKey \t func NSCoder -> Int32" , "contents": "decodeIntForKey(${1:String})" },{ "trigger": "NSXMLDocumentValidate \t Int", "contents": "NSXMLDocumentValidate" },{ "trigger": "smallestEncoding \t NSStringEncoding", "contents": "smallestEncoding" },{ "trigger": "getHour \t func NSCalendar -> void" , "contents": "getHour(${1:UnsafeMutablePointer<Int>}, minute:${2:UnsafeMutablePointer<Int>}, second:${3:UnsafeMutablePointer<Int>}, nanosecond:${4:UnsafeMutablePointer<Int>}, fromDate:${5:NSDate})" },{ "trigger": "NSSet \t NSSet", "contents": "NSSet" },{ "trigger": "NSCompoundPredicate \t coder:" , "contents": "NSCompoundPredicate(${1:NSCoder})" },{ "trigger": "addOperations \t func NSOperationQueue -> void" , "contents": "addOperations(${1:[NSOperation]}, waitUntilFinished:${2:Bool})" },{ "trigger": "NSFileHandle.fileHandleWithStandardInput \t class NSFileHandle -> NSFileHandle" , "contents": "NSFileHandle.fileHandleWithStandardInput(${1:})" },{ "trigger": "generate \t func NSArray -> Generator" , "contents": "generate(${1:})" },{ "trigger": "indexesOfObjectsPassingTest \t func Generator -> Bool" , "contents": "indexesOfObjectsPassingTest(${1:AnyObject}, Int:${2:}, UnsafeMutablePointer<ObjCBool>:${3:})" },{ "trigger": "NSComparisonPredicate \t leftExpression: rightExpression: modifier: type: options:" , "contents": "NSComparisonPredicate(leftExpression:${1:NSExpression}, rightExpression:${2:NSExpression}, modifier:${3:NSComparisonPredicateModifier}, type:${4:NSPredicateOperatorType}, options:${5:NSComparisonPredicateOptions})" },{ "trigger": "NSFileTypeRegular \t String", "contents": "NSFileTypeRegular" },{ "trigger": "isDate \t func NSCalendar -> Bool" , "contents": "isDate(${1:NSDate}, equalToDate:${2:NSDate}, toUnitGranularity:${3:NSCalendarUnit})" },{ "trigger": "mutableString \t NSMutableString", "contents": "mutableString" },{ "trigger": "_bridgeToObject \t func Float -> NSNumber" , "contents": "_bridgeToObject(${1:})" },{ "trigger": "NSDataSearchOptions \t NSDataSearchOptions", "contents": "NSDataSearchOptions" },{ "trigger": "_bridgeToObject \t func Dictionary -> NSDictionary" , "contents": "_bridgeToObject(${1:})" },{ "trigger": "NSSortOptions \t rawValue:" , "contents": "NSSortOptions(${1:UInt})" },{ "trigger": "scanHexDouble \t func NSScanner -> Double?" , "contents": "scanHexDouble(${1:})" },{ "trigger": "read \t func NSInputStream -> Int" , "contents": "read(${1:UnsafeMutablePointer<UInt8>}, maxLength:${2:Int})" },{ "trigger": "builtInPlugInsURL \t NSURL", "contents": "builtInPlugInsURL" },{ "trigger": "NSKeyedArchiver \t forWritingWithMutableData:" , "contents": "NSKeyedArchiver(forWritingWithMutableData:${1:NSMutableData})" },{ "trigger": "classForCoder \t AnyClass", "contents": "classForCoder" },{ "trigger": "NSByteCountFormatterUnits \t rawValue:" , "contents": "NSByteCountFormatterUnits(${1:UInt})" },{ "trigger": "NSASCIIStringEncoding \t UInt", "contents": "NSASCIIStringEncoding" },{ "trigger": "allowedUnits \t NSByteCountFormatterUnits", "contents": "allowedUnits" },{ "trigger": "NSFileSystemFileNumber \t String", "contents": "NSFileSystemFileNumber" },{ "trigger": "rangeOfScheme \t NSRange", "contents": "rangeOfScheme" },{ "trigger": "stringFromDate \t func NSDateIntervalFormatter -> String" , "contents": "stringFromDate(${1:NSDate}, toDate:${2:NSDate})" },{ "trigger": "physicalMemory \t UInt", "contents": "physicalMemory" },{ "trigger": "NSURLErrorClientCertificateRequired \t Int", "contents": "NSURLErrorClientCertificateRequired" },{ "trigger": "NSURLErrorBackgroundSessionInUseByAnotherProcess \t Int", "contents": "NSURLErrorBackgroundSessionInUseByAnotherProcess" },{ "trigger": "NSURLSessionTaskPriorityHigh \t Float", "contents": "NSURLSessionTaskPriorityHigh" }]
 }
