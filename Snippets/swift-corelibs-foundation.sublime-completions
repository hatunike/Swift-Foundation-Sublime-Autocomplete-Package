{
"scope": "source.swift",
"completions":
 [ 
{ "trigger": "pause) \t func NSProgress -> void" , "contents": "pause(${1:}))" },{ "trigger": "copyWithZone) \t func NSRegularExpression -> AnyObject" , "contents": "copyWithZone(${1:NSZone}))" },{ "trigger": "removeSuiteNamed) \t func NSUserDefaults -> void" , "contents": "removeSuiteNamed(${1:String}))" },{ "trigger": "removeAttribute) \t func NSMutableAttributedString -> void" , "contents": "removeAttribute(${1:String}), range:${2:NSRange}))" },{ "trigger": "sharedSupportURL \t NSURL", "contents": "sharedSupportURL" },{ "trigger": "tX \t CGFloat", "contents": "tX" },{ "trigger": "streamStatus \t NSStreamStatus", "contents": "streamStatus" },{ "trigger": "member) \t func NSSet -> AnyObject?" , "contents": "member(${1:AnyObject}))" },{ "trigger": "encodeWithCoder) \t func NSURLQueryItem -> void" , "contents": "encodeWithCoder(${1:NSCoder}))" },{ "trigger": "copyWithZone) \t func NSUUID -> AnyObject" , "contents": "copyWithZone(${1:NSZone}))" },{ "trigger": "XPath \t String", "contents": "XPath" },{ "trigger": "encodeWithCoder) \t func NSIndexSet -> void" , "contents": "encodeWithCoder(${1:NSCoder}))" },{ "trigger": "dateByAddingUnit) \t func NSCalendar -> NSDate?" , "contents": "dateByAddingUnit(${1:NSCalendarUnit}), value:${2:Int}), toDate:${3:NSDate}), options:${4:NSCalendarOptions}))" },{ "trigger": "NSOrderedSet) \t :" , "contents": "NSOrderedSet(${1:}))" },{ "trigger": "intersectsIndexesInRange) \t func NSIndexSet -> Bool" , "contents": "intersectsIndexesInRange(${1:NSRange}))" },{ "trigger": "mainDocumentURL \t NSURL", "contents": "mainDocumentURL" },{ "trigger": "NSLocaleQuotationBeginDelimiterKey \t String", "contents": "NSLocaleQuotationBeginDelimiterKey" },{ "trigger": "NSIntegralRectWithOptions) \t func unknown -> NSRect" , "contents": "NSIntegralRectWithOptions(${1:NSRect}), _:${2:NSAlignmentOptions}))" },{ "trigger": "NSCalendarIdentifierPersian \t String", "contents": "NSCalendarIdentifierPersian" },{ "trigger": "NSLocaleCurrencySymbol \t String", "contents": "NSLocaleCurrencySymbol" },{ "trigger": "fastestEncoding \t UInt", "contents": "fastestEncoding" },{ "trigger": "componentsSeparatedByString) \t func NSString -> [String]" , "contents": "componentsSeparatedByString(${1:String}))" },{ "trigger": "commonPrefixWithString) \t func NSString -> String" , "contents": "commonPrefixWithString(${1:String}), options:${2:NSStringCompareOptions}))" },{ "trigger": "shouldUseExtendedBackgroundIdleMode \t Bool", "contents": "shouldUseExtendedBackgroundIdleMode" },{ "trigger": "serverTrust \t SecTrust", "contents": "serverTrust" },{ "trigger": "unknown) \t location: length:" , "contents": "unknown(${1:Int}), length:${2:Int}))" },{ "trigger": "URLForResource) \t func NSBundle -> NSURL?" , "contents": "URLForResource(${1:String?}), withExtension:${2:String?}), subdirectory:${3:String?}))" },{ "trigger": "pathForResource) \t func NSBundle -> String?" , "contents": "pathForResource(${1:String?}), ofType:${2:String?}), inDirectory:${3:String?}))" },{ "trigger": "replaceItemAtURL) \t func NSFileManager -> NSURL" , "contents": "replaceItemAtURL(${1:NSURL}), withItemAtURL:${2:NSURL}), backupItemName:${3:String?}), options:${4:NSFileManagerItemReplacementOptions}))" },{ "trigger": "stringFromJoules) \t func NSEnergyFormatter -> String" , "contents": "stringFromJoules(${1:Double}))" },{ "trigger": "pattern \t String", "contents": "pattern" },{ "trigger": "defaultSessionConfiguration) \t class NSURLSessionConfiguration -> NSURLSessionConfiguration" , "contents": "defaultSessionConfiguration(${1:}))" },{ "trigger": "ready \t Bool", "contents": "ready" },{ "trigger": "receivePort \t NSPort", "contents": "receivePort" },{ "trigger": "failureResponse \t NSURLResponse", "contents": "failureResponse" },{ "trigger": "NSURLErrorCancelledReasonInsufficientSystemResources \t Int", "contents": "NSURLErrorCancelledReasonInsufficientSystemResources" },{ "trigger": "NSDecimalNumberHandler) \t coder:" , "contents": "NSDecimalNumberHandler(coder:${1:NSCoder}))" },{ "trigger": "NSDateIntervalFormatter) \t coder:" , "contents": "NSDateIntervalFormatter(${1:NSCoder}))" },{ "trigger": "pathsForResourcesOfType) \t func NSBundle -> [String]" , "contents": "pathsForResourcesOfType(${1:String?}), inDirectory:${2:String?}))" },{ "trigger": "negativeSuffix \t String", "contents": "negativeSuffix" },{ "trigger": "NSRecoveryAttempterErrorKey \t String", "contents": "NSRecoveryAttempterErrorKey" },{ "trigger": "NSZeroSize \t NSSize", "contents": "NSZeroSize" },{ "trigger": "NSNotification \t NSNotification", "contents": "NSNotification" },{ "trigger": "dataWithPropertyList) \t class NSPropertyListSerialization -> NSData" , "contents": "dataWithPropertyList(${1:AnyObject}), format:${2:NSPropertyListFormat}), options:${3:NSPropertyListWriteOptions}))" },{ "trigger": "isEqualToDate) \t func NSDate -> Bool" , "contents": "isEqualToDate(${1:NSDate}))" },{ "trigger": "NSDataWritingOptions) \t rawValue:" , "contents": "NSDataWritingOptions(${1:UInt}))" },{ "trigger": "components) \t func NSCalendar -> NSDateComponents?" , "contents": "components(${1:NSCalendarUnit}), fromDate:${2:NSDate}))" },{ "trigger": "write) \t func NSOutputStream -> Int" , "contents": "write(${1:UnsafePointerUInt8}), maxLength:${2:Int}))" },{ "trigger": "NSURLProtectionSpace) \t proxyHost: port: type: realm: authenticationMethod:" , "contents": "NSURLProtectionSpace(proxyHost:${1:String}), port:${2:Int}), type:${3:String?}), realm:${4:String?}), authenticationMethod:${5:String?}))" },{ "trigger": "NSURLResponse) \t coder:" , "contents": "NSURLResponse(coder:${1:NSCoder}))" },{ "trigger": "hash \t Int", "contents": "hash" },{ "trigger": "NSAlignmentOptions \t NSAlignmentOptions", "contents": "NSAlignmentOptions" },{ "trigger": "Float) \t _:" , "contents": "Float(_:${1:NSNumber}))" },{ "trigger": "NSURLRequest) \t coder:" , "contents": "NSURLRequest(coder:${1:NSCoder}))" },{ "trigger": "NSURLSessionConfiguration) \t :" , "contents": "NSURLSessionConfiguration(${1:}))" },{ "trigger": "canonicalXMLStringPreservingComments) \t func NSXMLNode -> String" , "contents": "canonicalXMLStringPreservingComments(${1:Bool}))" },{ "trigger": "NSXMLParser) \t contentsOfURL:" , "contents": "NSXMLParser(contentsOfURL:${1:NSURL}))" },{ "trigger": "NSFileHandle) \t fileDescriptor: closeOnDealloc:" , "contents": "NSFileHandle(fileDescriptor:${1:Int32}), closeOnDealloc:${2:Bool}))" },{ "trigger": "NSPredicate) \t fromMetadataQueryString:" , "contents": "NSPredicate(fromMetadataQueryString:${1:String}))" },{ "trigger": "objectForKey) \t func NSUserDefaults -> AnyObject?" , "contents": "objectForKey(${1:String}))" },{ "trigger": "cancellable \t Bool", "contents": "cancellable" },{ "trigger": "notationDeclarationForName) \t func NSXMLDTD -> NSXMLDTDNode?" , "contents": "notationDeclarationForName(${1:String}))" },{ "trigger": "NSURLCredential) \t coder:" , "contents": "NSURLCredential(coder:${1:NSCoder}))" },{ "trigger": "NSBinarySearchingOptions \t NSBinarySearchingOptions", "contents": "NSBinarySearchingOptions" },{ "trigger": "uploadTaskWithRequest) \t func NSURLSession -> Void)" , "contents": "uploadTaskWithRequest(${1:NSURLRequest}), fromData:${2:NSData?}), completionHandler:${3:NSData?}), NSURLResponse?:${4:}), NSError?:${5:}))" },{ "trigger": "NSStringCompareOptions) \t rawValue:" , "contents": "NSStringCompareOptions(${1:UInt}))" },{ "trigger": "pathForResource) \t func NSBundle -> String?" , "contents": "pathForResource(${1:String?}), ofType:${2:String?}))" },{ "trigger": "NSMutableString) \t extendedGraphemeClusterLiteral:" , "contents": "NSMutableString(extendedGraphemeClusterLiteral:${1:StaticString}))" },{ "trigger": "NSURLErrorCancelledReasonUserForceQuitApplication \t Int", "contents": "NSURLErrorCancelledReasonUserForceQuitApplication" },{ "trigger": "version \t Int", "contents": "version" },{ "trigger": "NSNotification) \t :" , "contents": "NSNotification(${1:}))" },{ "trigger": "main) \t func NSOperation -> void" , "contents": "main(${1:}))" },{ "trigger": "elementDeclarationForName) \t func NSXMLDTD -> NSXMLDTDNode?" , "contents": "elementDeclarationForName(${1:String}))" },{ "trigger": "NSRectEdge \t NSRectEdge", "contents": "NSRectEdge" },{ "trigger": "elementWithName) \t class NSXMLNode -> AnyObject" , "contents": "elementWithName(${1:String}), children:${2:[NSXMLNode]?}), attributes:${3:[NSXMLNode]?}))" },{ "trigger": "stringByDeletingLastPathComponent \t :", "contents": "stringByDeletingLastPathComponent" },{ "trigger": "allowsFloats \t Bool", "contents": "allowsFloats" },{ "trigger": "Generator) \t dictionary:" , "contents": "Generator(${1:[NSObject }))" },{ "trigger": "fileDescriptor \t Int", "contents": "fileDescriptor" },{ "trigger": "lastPathComponent \t :", "contents": "lastPathComponent" },{ "trigger": "countStyle \t NSByteCountFormatterCountStyle", "contents": "countStyle" },{ "trigger": "stringByStandardizingPath \t String", "contents": "stringByStandardizingPath" },{ "trigger": "NSCountedSet \t NSCountedSet", "contents": "NSCountedSet" },{ "trigger": "copyWithZone) \t func NSScanner -> AnyObject" , "contents": "copyWithZone(${1:NSZone}))" },{ "trigger": ") \t func unknown -> Bool" , "contents": "(${1:CGFloat}), rhs:${2:CGFloat}))" },{ "trigger": "paddingPosition \t NSNumberFormatterPadPosition", "contents": "paddingPosition" },{ "trigger": "attributesAtIndex) \t func NSAttributedString -> [String" , "contents": "attributesAtIndex(${1:Int}), effectiveRange:${2:NSRangePointer}))" },{ "trigger": "NSURLErrorCannotOpenFile \t Int", "contents": "NSURLErrorCannotOpenFile" },{ "trigger": "removeAllObjects) \t func NSMutableArray -> void" , "contents": "removeAllObjects(${1:}))" },{ "trigger": "patchVersion \t Int", "contents": "patchVersion" },{ "trigger": "sortUsingDescriptors) \t func NSMutableArray -> void" , "contents": "sortUsingDescriptors(${1:[NSSortDescriptor]}))" },{ "trigger": "isCoderError \t Bool", "contents": "isCoderError" },{ "trigger": "NSURLSession \t NSURLSession", "contents": "NSURLSession" },{ "trigger": "timeStyle \t NSDateFormatterStyle", "contents": "timeStyle" },{ "trigger": "NSCocoaErrorDomain \t String", "contents": "NSCocoaErrorDomain" },{ "trigger": "NSNumber) \t coder:" , "contents": "NSNumber(coder:${1:NSCoder}))" },{ "trigger": "uploadTaskWithRequest) \t func NSURLSession -> NSURLSessionUploadTask" , "contents": "uploadTaskWithRequest(${1:NSURLRequest}), fromFile:${2:NSURL}))" },{ "trigger": "stringFromValue) \t func NSEnergyFormatter -> String" , "contents": "stringFromValue(${1:Double}), unit:${2:NSEnergyFormatterUnit}))" },{ "trigger": "componentsInTimeZone) \t func NSCalendar -> NSDateComponents?" , "contents": "componentsInTimeZone(${1:NSTimeZone}), fromDate:${2:NSDate}))" },{ "trigger": "givenName \t String", "contents": "givenName" },{ "trigger": "NSEqualSizes) \t func unknown -> Bool" , "contents": "NSEqualSizes(${1:NSSize}), _:${2:NSSize}))" },{ "trigger": "NSMutableArray) \t contentsOfFile:" , "contents": "NSMutableArray(contentsOfFile:${1:String}))" },{ "trigger": "NSAffineTransform \t NSAffineTransform", "contents": "NSAffineTransform" },{ "trigger": "URLForResource) \t func NSBundle -> NSURL?" , "contents": "URLForResource(${1:String?}), withExtension:${2:String?}), subdirectory:${3:String?}), localization:${4:String?}))" },{ "trigger": "NSRegistrationDomain \t String", "contents": "NSRegistrationDomain" },{ "trigger": "keyPath \t String", "contents": "keyPath" },{ "trigger": "NSDate \t NSDate", "contents": "NSDate" },{ "trigger": "NSFileHandle) \t forUpdatingAtPath:" , "contents": "NSFileHandle(forUpdatingAtPath:${1:String}))" },{ "trigger": "NSCharacterSet) \t range:" , "contents": "NSCharacterSet(range:${1:NSRange}))" },{ "trigger": "longValue \t Int", "contents": "longValue" },{ "trigger": "addObjectsFromArray) \t func NSMutableSet -> void" , "contents": "addObjectsFromArray(${1:[AnyObject]}))" },{ "trigger": "copyWithZone) \t func NSError -> AnyObject" , "contents": "copyWithZone(${1:NSZone}))" },{ "trigger": "AMSymbol \t String", "contents": "AMSymbol" },{ "trigger": "mountedVolumeURLsIncludingResourceValuesForKeys) \t func NSFileManager -> [NSURL]?" , "contents": "mountedVolumeURLsIncludingResourceValuesForKeys(${1:[String]?}), options:${2:NSVolumeEnumerationOptions}))" },{ "trigger": "NSHTTPURLResponse) \t URL: statusCode: HTTPVersion: headerFields:" , "contents": "NSHTTPURLResponse(URL:${1:NSURL}), statusCode:${2:Int}), HTTPVersion:${3:String?}), headerFields:${4:[String }))" },{ "trigger": "unionOrderedSet) \t func NSMutableOrderedSet -> void" , "contents": "unionOrderedSet(${1:NSOrderedSet}))" },{ "trigger": "bytes \t UnsafePointer", "contents": "bytes" },{ "trigger": "editingStringForObjectValue) \t func NSFormatter -> String?" , "contents": "editingStringForObjectValue(${1:AnyObject}))" },{ "trigger": "defaultManager) \t class NSFileManager -> NSFileManager" , "contents": "defaultManager(${1:}))" },{ "trigger": "NSSocketPort) \t TCPPort:" , "contents": "NSSocketPort(TCPPort:${1:UInt16}))" },{ "trigger": "URLsForResourcesWithExtension) \t func NSBundle -> [NSURL]?" , "contents": "URLsForResourcesWithExtension(${1:String?}), subdirectory:${2:String?}), localization:${3:String?}))" },{ "trigger": "NSCalendarIdentifierHebrew \t String", "contents": "NSCalendarIdentifierHebrew" },{ "trigger": "NSDivideRect) \t func unknown -> void" , "contents": "NSDivideRect(${1:NSRect}), _:${2:UnsafeMutablePointerNSRect}), _:${3:UnsafeMutablePointerNSRect}), _:${4:CGFloat}), _:${5:NSRectEdge}))" },{ "trigger": "availableStringEncodings) \t static String -> [NSStringEncoding]" , "contents": "availableStringEncodings(${1:}))" },{ "trigger": "getBytes) \t func NSData -> void" , "contents": "getBytes(${1:UnsafeMutablePointerVoid}), range:${2:NSRange}))" },{ "trigger": "stringFromDateComponents) \t func NSDateComponentsFormatter -> String?" , "contents": "stringFromDateComponents(${1:NSDateComponents}))" },{ "trigger": "encodeBytes) \t func NSCoder -> void" , "contents": "encodeBytes(${1:UnsafePointerVoid}), length:${2:Int}))" },{ "trigger": "addObjects) \t func NSMutableOrderedSet -> void" , "contents": "addObjects(${1:UnsafePointerAnyObject?}), count:${2:Int}))" },{ "trigger": "exit) \t class NSThread -> void" , "contents": "exit(${1:}))" },{ "trigger": "NSURLErrorAppTransportSecurityRequiresSecureConnection \t Int", "contents": "NSURLErrorAppTransportSecurityRequiresSecureConnection" },{ "trigger": "NSComparisonPredicate) \t coder:" , "contents": "NSComparisonPredicate(${1:NSCoder}))" },{ "trigger": "NSURL) \t fileURLWithFileSystemRepresentation: isDirectory: relativeToURL:" , "contents": "NSURL(fileURLWithFileSystemRepresentation:${1:UnsafePointerInt8}), isDirectory:${2:Bool}), relativeToURL:${3:NSURL?}))" },{ "trigger": "NSURLErrorDNSLookupFailed \t Int", "contents": "NSURLErrorDNSLookupFailed" },{ "trigger": "NSURLProtectionSpaceFTP \t String", "contents": "NSURLProtectionSpaceFTP" },{ "trigger": "prefix \t String", "contents": "prefix" },{ "trigger": "NSURLErrorBackgroundSessionRequiresSharedContainer \t Int", "contents": "NSURLErrorBackgroundSessionRequiresSharedContainer" },{ "trigger": "writeToURL) \t func NSData -> Bool" , "contents": "writeToURL(${1:NSURL}), atomically:${2:Bool}))" },{ "trigger": "rangeOfComposedCharacterSequenceAtIndex) \t func NSString -> NSRange" , "contents": "rangeOfComposedCharacterSequenceAtIndex(${1:Int}))" },{ "trigger": "DTDNodeWithXMLString) \t class NSXMLNode -> AnyObject?" , "contents": "DTDNodeWithXMLString(${1:String}))" },{ "trigger": "decodeTopLevelObjectOfClassDecodedObjectType) \t func NSCoder -> DecodedObjectType?" , "contents": "decodeTopLevelObjectOfClassDecodedObjectType(${1:DecodedObjectType.Type}), forKey:${2:String}))" },{ "trigger": "base64EncodedDataWithOptions) \t func NSData -> NSData" , "contents": "base64EncodedDataWithOptions(${1:NSDataBase64EncodingOptions}))" },{ "trigger": "NSOrderedSet) \t objects:" , "contents": "NSOrderedSet(objects:${1:AnyObject...}))" },{ "trigger": "isDateInTomorrow) \t func NSCalendar -> Bool" , "contents": "isDateInTomorrow(${1:NSDate}))" },{ "trigger": "localizedStringFromDateComponents) \t class NSDateComponentsFormatter -> String?" , "contents": "localizedStringFromDateComponents(${1:NSDateComponents}), unitsStyle:${2:NSDateComponentsFormatterUnitsStyle}))" },{ "trigger": "NSOutputStream) \t toMemory:" , "contents": "NSOutputStream(${1:}))" },{ "trigger": "format \t String", "contents": "format" },{ "trigger": "NSURLErrorSecureConnectionFailed \t Int", "contents": "NSURLErrorSecureConnectionFailed" },{ "trigger": "NSComparisonPredicate \t NSComparisonPredicate", "contents": "NSComparisonPredicate" },{ "trigger": "NSFileTypeBlockSpecial \t String", "contents": "NSFileTypeBlockSpecial" },{ "trigger": "lineDirectionForLanguage) \t class NSLocale -> NSLocaleLanguageDirection" , "contents": "lineDirectionForLanguage(${1:String}))" },{ "trigger": "DTDKind \t NSXMLDTDNodeKind", "contents": "DTDKind" },{ "trigger": "removeAttributeForName) \t func NSXMLElement -> void" , "contents": "removeAttributeForName(${1:String}))" },{ "trigger": "NSMutableOrderedSet) \t arrayLiteral:" , "contents": "NSMutableOrderedSet(arrayLiteral:${1:AnyObject...}))" },{ "trigger": "operatingSystemVersionString \t String", "contents": "operatingSystemVersionString" },{ "trigger": "formUnionWithCharacterSet) \t func NSMutableCharacterSet -> void" , "contents": "formUnionWithCharacterSet(${1:NSCharacterSet}))" },{ "trigger": "NSNumberFormatterStyle \t NSNumberFormatterStyle", "contents": "NSNumberFormatterStyle" },{ "trigger": "fractionCompleted \t Double", "contents": "fractionCompleted" },{ "trigger": "NSTextCheckingType \t NSTextCheckingType", "contents": "NSTextCheckingType" },{ "trigger": "groupingSize \t Int", "contents": "groupingSize" },{ "trigger": "currentProgress) \t class NSProgress -> NSProgress?" , "contents": "currentProgress(${1:}))" },{ "trigger": "prependTransform) \t func NSAffineTransform -> void" , "contents": "prependTransform(${1:NSAffineTransform}))" },{ "trigger": "NSOperationQueue) \t :" , "contents": "NSOperationQueue(${1:}))" },{ "trigger": "allKeysForObject) \t func Generator -> [AnyObject]" , "contents": "allKeysForObject(${1:AnyObject}))" },{ "trigger": "decodeInt32ForKey) \t func NSCoder -> Int32" , "contents": "decodeInt32ForKey(${1:String}))" },{ "trigger": "dateBySettingHour) \t func NSCalendar -> NSDate?" , "contents": "dateBySettingHour(${1:Int}), minute:${2:Int}), second:${3:Int}), ofDate:${4:NSDate}), options:${5:NSCalendarOptions}))" },{ "trigger": "objectsForKeys) \t func Generator -> [AnyObject]" , "contents": "objectsForKeys(${1:[NSObject]}), notFoundMarker:${2:AnyObject}))" },{ "trigger": "bottom \t CGFloat", "contents": "bottom" },{ "trigger": "expiresDate \t NSDate", "contents": "expiresDate" },{ "trigger": "negativeFormat \t String", "contents": "negativeFormat" },{ "trigger": "rotateByRadians) \t func NSAffineTransform -> void" , "contents": "rotateByRadians(${1:CGFloat}))" },{ "trigger": "encodeByrefObject) \t func NSCoder -> void" , "contents": "encodeByrefObject(${1:AnyObject?}))" },{ "trigger": "mutableCopyWithZone) \t func NSIndexSet -> AnyObject" , "contents": "mutableCopyWithZone(${1:NSZone}))" },{ "trigger": "maximumLengthOfBytesUsingEncoding) \t func NSString -> Int" , "contents": "maximumLengthOfBytesUsingEncoding(${1:UInt}))" },{ "trigger": "NSMutableString) \t unicodeScalarLiteral:" , "contents": "NSMutableString(unicodeScalarLiteral:${1:StaticString}))" },{ "trigger": "supportsSecureCoding) \t static NSValue -> Bool" , "contents": "supportsSecureCoding(${1:}))" },{ "trigger": "NSMaxX) \t func unknown -> CGFloat" , "contents": "NSMaxX(${1:NSRect}))" },{ "trigger": "indexesOfObjectsPassingTest) \t func NSOrderedSet -> Bool)" , "contents": "indexesOfObjectsPassingTest(${1:AnyObject}), Int:${2:}), UnsafeMutablePointerObjCBool:${3:}))" },{ "trigger": "fileSystemRepresentation \t :", "contents": "fileSystemRepresentation" },{ "trigger": "encodeWithCoder) \t func NSCalendar -> void" , "contents": "encodeWithCoder(${1:NSCoder}))" },{ "trigger": "delegateQueue \t NSOperationQueue", "contents": "delegateQueue" },{ "trigger": "relativeString \t String", "contents": "relativeString" },{ "trigger": "NSURLErrorClientCertificateRejected \t Int", "contents": "NSURLErrorClientCertificateRejected" },{ "trigger": "NSValue \t NSValue", "contents": "NSValue" },{ "trigger": "addAttribute) \t func NSXMLElement -> void" , "contents": "addAttribute(${1:NSXMLNode}))" },{ "trigger": "NSLocaleLanguageDirection \t NSLocaleLanguageDirection", "contents": "NSLocaleLanguageDirection" },{ "trigger": "insertChildren) \t func NSXMLElement -> void" , "contents": "insertChildren(${1:[NSXMLNode]}), atIndex:${2:Int}))" },{ "trigger": "decimalNumberByRaisingToPower) \t func NSDecimalNumber -> NSDecimalNumber" , "contents": "decimalNumberByRaisingToPower(${1:Int}), withBehavior:${2:NSDecimalNumberBehaviors?}))" },{ "trigger": "removeAllObjects) \t func NSMutableDictionary -> void" , "contents": "removeAllObjects(${1:}))" },{ "trigger": "localizedStandardRangeOfString) \t func NSString -> NSRange" , "contents": "localizedStandardRangeOfString(${1:String}))" },{ "trigger": "windowsLocaleCodeFromLocaleIdentifier) \t class NSLocale -> UInt32" , "contents": "windowsLocaleCodeFromLocaleIdentifier(${1:String}))" },{ "trigger": "postNotificationName) \t func NSNotificationCenter -> void" , "contents": "postNotificationName(${1:String}), object:${2:AnyObject?}), userInfo:${3:[NSObject }))" },{ "trigger": "getRelationship) \t func NSFileManager -> void" , "contents": "getRelationship(${1:UnsafeMutablePointerNSURLRelationship}), ofDirectoryAtURL:${2:NSURL}), toItemAtURL:${3:NSURL}))" },{ "trigger": "identifier \t String", "contents": "identifier" },{ "trigger": "objectValue \t AnyObject", "contents": "objectValue" },{ "trigger": "classForClassName) \t func NSKeyedUnarchiver -> AnyClass?" , "contents": "classForClassName(${1:String}))" },{ "trigger": "resultType \t NSTextCheckingType", "contents": "resultType" },{ "trigger": "parameterString \t String", "contents": "parameterString" },{ "trigger": "arrayForKey) \t func NSUserDefaults -> [AnyObject]?" , "contents": "arrayForKey(${1:String}))" },{ "trigger": "NSNumber) \t integer:" , "contents": "NSNumber(integer:${1:Int}))" },{ "trigger": "unregisterClass) \t class NSURLProtocol -> void" , "contents": "unregisterClass(${1:AnyClass}))" },{ "trigger": "NSURLProtectionSpace) \t coder:" , "contents": "NSURLProtectionSpace(coder:${1:NSCoder}))" },{ "trigger": "NSFormattingUnitStyle \t NSFormattingUnitStyle", "contents": "NSFormattingUnitStyle" },{ "trigger": "CGSize) \t :" , "contents": "CGSize(${1:}))" },{ "trigger": "NSMutableOrderedSet) \t coder:" , "contents": "NSMutableOrderedSet(coder:${1:NSCoder}))" },{ "trigger": "componentsJoinedByString) \t func Generator -> String" , "contents": "componentsJoinedByString(${1:String}))" },{ "trigger": "setURL) \t func NSUserDefaults -> void" , "contents": "setURL(${1:NSURL?}), forKey:${2:String}))" },{ "trigger": "decodeObject) \t func NSCoder -> AnyObject?" , "contents": "decodeObject(${1:}))" },{ "trigger": "removeChildAtIndex) \t func NSXMLDTD -> void" , "contents": "removeChildAtIndex(${1:Int}))" },{ "trigger": "second \t Int", "contents": "second" },{ "trigger": "becomeCurrentWithPendingUnitCount) \t func NSProgress -> void" , "contents": "becomeCurrentWithPendingUnitCount(${1:Int64}))" },{ "trigger": "*) \t func unknown -> CGFloat" , "contents": "*(${1:CGFloat}), rhs:${2:CGFloat}))" },{ "trigger": "NSBundle) \t path:" , "contents": "NSBundle(${1:String}))" },{ "trigger": "start) \t func NSOperation -> void" , "contents": "start(${1:}))" },{ "trigger": "configuration \t NSURLSessionConfiguration", "contents": "configuration" },{ "trigger": "nextWeekendAfter) \t func NSCalendar -> NSDateInterval?" , "contents": "nextWeekendAfter(${1:NSDate}), options:${2:NSCalendarOptions}))" },{ "trigger": "encodeWithCoder) \t func NSOrderedSet -> void" , "contents": "encodeWithCoder(${1:NSCoder}))" },{ "trigger": "unarchiveObjectWithFile) \t class NSKeyedUnarchiver -> AnyObject?" , "contents": "unarchiveObjectWithFile(${1:String}))" },{ "trigger": "setAbbreviationDictionary) \t class NSTimeZone -> void" , "contents": "setAbbreviationDictionary(${1:[String }))" },{ "trigger": "synchronizeFile) \t func NSFileHandle -> void" , "contents": "synchronizeFile(${1:}))" },{ "trigger": "resolvePrefixForNamespaceURI) \t func NSXMLElement -> String?" , "contents": "resolvePrefixForNamespaceURI(${1:String}))" },{ "trigger": "copyWithZone) \t func NSTextCheckingResult -> AnyObject" , "contents": "copyWithZone(${1:NSZone}))" },{ "trigger": "Generator) \t objects: forKeys:" , "contents": "Generator(${1:[AnyObject]}), forKeys:${2:[NSObject]}))" },{ "trigger": "attributeDeclarationForName) \t func NSXMLDTD -> NSXMLDTDNode?" , "contents": "attributeDeclarationForName(${1:String}), elementName:${2:String}))" },{ "trigger": "NSAlignmentOptions) \t rawValue:" , "contents": "NSAlignmentOptions(${1:UInt64}))" },{ "trigger": "NSExpression) \t coder:" , "contents": "NSExpression(coder:${1:NSCoder}))" },{ "trigger": "subarrayWithRange) \t func Generator -> [AnyObject]" , "contents": "subarrayWithRange(${1:NSRange}))" },{ "trigger": "NSLocaleCollatorIdentifier \t String", "contents": "NSLocaleCollatorIdentifier" },{ "trigger": "NSZone \t NSZone", "contents": "NSZone" },{ "trigger": "NSPointFromCGPoint) \t func unknown -> NSPoint" , "contents": "NSPointFromCGPoint(${1:CGPoint}))" },{ "trigger": "exchangeObjectAtIndex) \t func NSMutableOrderedSet -> void" , "contents": "exchangeObjectAtIndex(${1:Int}), withObjectAtIndex:${2:Int}))" },{ "trigger": "sortRange) \t func NSMutableOrderedSet -> void" , "contents": "sortRange(${1:NSRange}), options:${2:NSSortOptions}), usingComparator:${3:NSComparator}))" },{ "trigger": "hasThousandSeparators \t Bool", "contents": "hasThousandSeparators" },{ "trigger": "streamError \t NSError", "contents": "streamError" },{ "trigger": "waitUntilExit) \t func NSTask -> void" , "contents": "waitUntilExit(${1:}))" },{ "trigger": "addObject) \t func NSMutableOrderedSet -> void" , "contents": "addObject(${1:AnyObject}))" },{ "trigger": "scanHexFloat) \t func NSScanner -> Bool" , "contents": "scanHexFloat(${1:UnsafeMutablePointerFloat}))" },{ "trigger": "start) \t func NSThread -> void" , "contents": "start(${1:}))" },{ "trigger": "sharedCredentialStorage) \t class NSURLCredentialStorage -> NSURLCredentialStorage" , "contents": "sharedCredentialStorage(${1:}))" },{ "trigger": "NSURLProtectionSpaceSOCKSProxy \t String", "contents": "NSURLProtectionSpaceSOCKSProxy" },{ "trigger": "NSURLAuthenticationMethodClientCertificate \t String", "contents": "NSURLAuthenticationMethodClientCertificate" },{ "trigger": "canInitWithTask) \t class NSURLProtocol -> Bool" , "contents": "canInitWithTask(${1:NSURLSessionTask}))" },{ "trigger": "NSMutableURLRequest \t NSMutableURLRequest", "contents": "NSMutableURLRequest" },{ "trigger": "integerForKey) \t func NSUserDefaults -> Int" , "contents": "integerForKey(${1:String}))" },{ "trigger": "attributeWithName) \t class NSXMLNode -> AnyObject" , "contents": "attributeWithName(${1:String}), URI:${2:String}), stringValue:${3:String}))" },{ "trigger": "resignCurrent) \t func NSProgress -> void" , "contents": "resignCurrent(${1:}))" },{ "trigger": "operatingSystemVersion \t NSOperatingSystemVersion", "contents": "operatingSystemVersion" },{ "trigger": "requestHeaderFieldsWithCookies) \t class NSHTTPCookie -> [String" , "contents": "requestHeaderFieldsWithCookies(${1:[NSHTTPCookie]}))" },{ "trigger": "stringByTrimmingCharactersInSet) \t func NSString -> String" , "contents": "stringByTrimmingCharactersInSet(${1:NSCharacterSet}))" },{ "trigger": "caseInsensitiveCompare) \t func String -> NSComparisonResult" , "contents": "caseInsensitiveCompare(${1:String}))" },{ "trigger": "minimumIntegerDigits \t Int", "contents": "minimumIntegerDigits" },{ "trigger": "removeCachedResponseForRequest) \t func NSURLCache -> void" , "contents": "removeCachedResponseForRequest(${1:NSURLRequest}))" },{ "trigger": "archivedDataWithRootObject) \t class NSKeyedArchiver -> NSData" , "contents": "archivedDataWithRootObject(${1:AnyObject}))" },{ "trigger": "copy) \t func NSObject -> AnyObject" , "contents": "copy(${1:}))" },{ "trigger": "encodeWithCoder) \t func NSString -> void" , "contents": "encodeWithCoder(${1:NSCoder}))" },{ "trigger": "NSXMLNodePreservePrefixes \t NSXMLNodeOptionRawType", "contents": "NSXMLNodePreservePrefixes" },{ "trigger": "NSCharacterSet \t NSCharacterSet", "contents": "NSCharacterSet" },{ "trigger": "calendarIdentifier \t String", "contents": "calendarIdentifier" },{ "trigger": "encodeWithCoder) \t func NSURL -> void" , "contents": "encodeWithCoder(${1:NSCoder}))" },{ "trigger": "setChildren) \t func NSXMLElement -> void" , "contents": "setChildren(${1:[NSXMLNode]?}))" },{ "trigger": "NSNotification) \t name: object: userInfo:" , "contents": "NSNotification(${1:String}), object:${2:AnyObject?}), userInfo:${3:[NSObject }))" },{ "trigger": "insertChildren) \t func NSXMLDocument -> void" , "contents": "insertChildren(${1:[NSXMLNode]}), atIndex:${2:Int}))" },{ "trigger": "sortedArrayUsingComparator) \t func NSOrderedSet -> [AnyObject]" , "contents": "sortedArrayUsingComparator(${1:NSComparator}))" },{ "trigger": "copyWithZone) \t func NSPredicate -> AnyObject" , "contents": "copyWithZone(${1:NSZone}))" },{ "trigger": "timeStyle \t NSDateIntervalFormatterStyle", "contents": "timeStyle" },{ "trigger": "classForKeyedArchiver \t AnyClass", "contents": "classForKeyedArchiver" },{ "trigger": "NSMidY) \t func unknown -> CGFloat" , "contents": "NSMidY(${1:NSRect}))" },{ "trigger": "NSURLErrorBackgroundTaskCancelledReasonKey \t String", "contents": "NSURLErrorBackgroundTaskCancelledReasonKey" },{ "trigger": "stringByAddingPercentEncodingWithAllowedCharacters) \t func NSString -> String?" , "contents": "stringByAddingPercentEncodingWithAllowedCharacters(${1:NSCharacterSet}))" },{ "trigger": "flushWithCompletionHandler) \t func NSURLSession -> Void)" , "contents": "flushWithCompletionHandler(${1: - Void}))" },{ "trigger": "privateFrameworksURL \t NSURL", "contents": "privateFrameworksURL" },{ "trigger": "minimumDecimalNumber) \t class NSDecimalNumber -> NSDecimalNumber" , "contents": "minimumDecimalNumber(${1:}))" },{ "trigger": "currencySymbol \t String", "contents": "currencySymbol" },{ "trigger": "NSExpression) \t expressionType:" , "contents": "NSExpression(expressionType:${1:NSExpressionType}))" },{ "trigger": "unitStringFromMeters) \t func NSLengthFormatter -> String" , "contents": "unitStringFromMeters(${1:Double}), usedUnit:${2:UnsafeMutablePointerNSLengthFormatterUnit}))" },{ "trigger": "isUbiquitousFileError \t Bool", "contents": "isUbiquitousFileError" },{ "trigger": "NSHTTPURLResponse \t NSHTTPURLResponse", "contents": "NSHTTPURLResponse" },{ "trigger": "NSJSONReadingOptions \t NSJSONReadingOptions", "contents": "NSJSONReadingOptions" },{ "trigger": "enumerateObjectsUsingBlock) \t func Generator -> Void)" , "contents": "enumerateObjectsUsingBlock(${1:AnyObject}), Int:${2:}), UnsafeMutablePointerObjCBool:${3:}))" },{ "trigger": "NSURLErrorCancelled \t Int", "contents": "NSURLErrorCancelled" },{ "trigger": "NSOperatingSystemVersion) \t majorVersion: minorVersion: patchVersion:" , "contents": "NSOperatingSystemVersion(${1:Int}), minorVersion:${2:Int}), patchVersion:${3:Int}))" },{ "trigger": "abortParsing) \t func NSXMLParser -> void" , "contents": "abortParsing(${1:}))" },{ "trigger": "NSFileAppendOnly \t String", "contents": "NSFileAppendOnly" },{ "trigger": "_forceBridgeFromObject) \t static Set -> void" , "contents": "_forceBridgeFromObject(${1:NSSet}), inout:${2:Set?}))" },{ "trigger": "indexesWithOptions) \t func NSIndexSet -> Bool)" , "contents": "indexesWithOptions(${1:NSEnumerationOptions}), passingTest:${2:Int}), UnsafeMutablePointerObjCBool:${3:}))" },{ "trigger": "request \t NSURLRequest", "contents": "request" },{ "trigger": "synchronize) \t func NSUserDefaults -> Bool" , "contents": "synchronize(${1:}))" },{ "trigger": "objectEnumerator) \t func Generator -> NSEnumerator" , "contents": "objectEnumerator(${1:}))" },{ "trigger": "NSAffineTransform) \t coder:" , "contents": "NSAffineTransform(coder:${1:NSCoder}))" },{ "trigger": "fireDate \t NSDate", "contents": "fireDate" },{ "trigger": "setCookies) \t func NSHTTPCookieStorage -> void" , "contents": "setCookies(${1:[NSHTTPCookie]}), forURL:${2:NSURL?}), mainDocumentURL:${3:NSURL?}))" },{ "trigger": "stringFromPersonNameComponents) \t func NSPersonNameComponentsFormatter -> String" , "contents": "stringFromPersonNameComponents(${1:NSPersonNameComponents}))" },{ "trigger": "encodeWithCoder) \t func NSPersonNameComponents -> void" , "contents": "encodeWithCoder(${1:NSCoder}))" },{ "trigger": "rangeOfHost \t NSRange", "contents": "rangeOfHost" },{ "trigger": "URLForResource) \t class NSBundle -> NSURL?" , "contents": "URLForResource(${1:String?}), withExtension:${2:String?}), subdirectory:${3:String?}), inBundleWithURL:${4:NSURL}))" },{ "trigger": "NSTimeZone) \t name:" , "contents": "NSTimeZone(name:${1:String}))" },{ "trigger": "readInBackgroundAndNotify) \t func NSFileHandle -> void" , "contents": "readInBackgroundAndNotify(${1:}))" },{ "trigger": "scanUpToCharactersFromSet) \t func NSScanner -> String?" , "contents": "scanUpToCharactersFromSet(${1:NSCharacterSet}))" },{ "trigger": "NSURLErrorHTTPTooManyRedirects \t Int", "contents": "NSURLErrorHTTPTooManyRedirects" },{ "trigger": "intersectSet) \t func NSMutableSet -> void" , "contents": "intersectSet(${1:SetNSObject}))" },{ "trigger": "NSPointToCGPoint) \t func unknown -> CGPoint" , "contents": "NSPointToCGPoint(${1:NSPoint}))" },{ "trigger": "sharedContainerIdentifier \t String", "contents": "sharedContainerIdentifier" },{ "trigger": "linkItemAtPath) \t func NSFileManager -> void" , "contents": "linkItemAtPath(${1:String}), toPath:${2:String}))" },{ "trigger": "formattingContext \t NSFormattingContext", "contents": "formattingContext" },{ "trigger": "removeObjectAtIndex) \t func NSMutableOrderedSet -> void" , "contents": "removeObjectAtIndex(${1:Int}))" },{ "trigger": "copyWithZone) \t func NSFormatter -> AnyObject" , "contents": "copyWithZone(${1:NSZone}))" },{ "trigger": "systemUptime \t NSTimeInterval", "contents": "systemUptime" },{ "trigger": "valid \t Bool", "contents": "valid" },{ "trigger": "stringFromKilograms) \t func NSMassFormatter -> String" , "contents": "stringFromKilograms(${1:Double}))" },{ "trigger": "containsString) \t func NSString -> Bool" , "contents": "containsString(${1:String}))" },{ "trigger": "NSMakeRect) \t func unknown -> NSRect" , "contents": "NSMakeRect(${1:CGFloat}), _:${2:CGFloat}), _:${3:CGFloat}), _:${4:CGFloat}))" },{ "trigger": "dateTemplate \t String", "contents": "dateTemplate" },{ "trigger": "_bridgeToObject) \t func UInt -> NSNumber" , "contents": "_bridgeToObject(${1:}))" },{ "trigger": "NSEqualRanges) \t func unknown -> Bool" , "contents": "NSEqualRanges(${1:NSRange}), _:${2:NSRange}))" },{ "trigger": "NSRunLoop \t NSRunLoop", "contents": "NSRunLoop" },{ "trigger": "URLCache \t NSURLCache", "contents": "URLCache" },{ "trigger": "setClass) \t func NSKeyedUnarchiver -> void" , "contents": "setClass(${1:AnyClass?}), forClassName:${2:String}))" },{ "trigger": "NSURLSessionTaskPriorityDefault \t Float", "contents": "NSURLSessionTaskPriorityDefault" },{ "trigger": "NSXMLNodePromoteSignificantWhitespace \t NSXMLNodeOptionRawType", "contents": "NSXMLNodePromoteSignificantWhitespace" },{ "trigger": "unsignedLongLongValue \t UInt", "contents": "unsignedLongLongValue" },{ "trigger": "NSJSONWritingOptions \t NSJSONWritingOptions", "contents": "NSJSONWritingOptions" },{ "trigger": "roundingIncrement \t NSNumber", "contents": "roundingIncrement" },{ "trigger": "NSNumber) \t bool:" , "contents": "NSNumber(bool:${1:Bool}))" },{ "trigger": "addTimer) \t func NSRunLoop -> void" , "contents": "addTimer(${1:NSTimer}), forMode:${2:String}))" },{ "trigger": "NSProgressFileOperationKindReceiving \t String", "contents": "NSProgressFileOperationKindReceiving" },{ "trigger": "minusSign \t String", "contents": "minusSign" },{ "trigger": "characterDirectionForLanguage) \t class NSLocale -> NSLocaleLanguageDirection" , "contents": "characterDirectionForLanguage(${1:String}))" },{ "trigger": "NSStream \t NSStream", "contents": "NSStream" },{ "trigger": "dictionaryForKey) \t func NSUserDefaults -> [String" , "contents": "dictionaryForKey(${1:String}))" },{ "trigger": "isDeletableFileAtPath) \t func NSFileManager -> Bool" , "contents": "isDeletableFileAtPath(${1:String}))" },{ "trigger": "classNamed) \t func NSBundle -> AnyClass?" , "contents": "classNamed(${1:String}))" },{ "trigger": "decomposedStringWithCompatibilityMapping \t String", "contents": "decomposedStringWithCompatibilityMapping" },{ "trigger": "removeCredential) \t func NSURLCredentialStorage -> void" , "contents": "removeCredential(${1:NSURLCredential}), forProtectionSpace:${2:NSURLProtectionSpace}), options:${3:[String }), task:${4:NSURLSessionTask}))" },{ "trigger": "NSURLProtectionSpaceHTTPProxy \t String", "contents": "NSURLProtectionSpaceHTTPProxy" },{ "trigger": "NSKeyedArchiver \t NSKeyedArchiver", "contents": "NSKeyedArchiver" },{ "trigger": "NSXMLNodeKind \t NSXMLNodeKind", "contents": "NSXMLNodeKind" },{ "trigger": "canonicalLocaleIdentifierFromString) \t class NSLocale -> String" , "contents": "canonicalLocaleIdentifierFromString(${1:String}))" },{ "trigger": "NSInputStream) \t data:" , "contents": "NSInputStream(${1:NSData}))" },{ "trigger": "NSURLCacheStoragePolicy \t NSURLCacheStoragePolicy", "contents": "NSURLCacheStoragePolicy" },{ "trigger": "elementWithName) \t class NSXMLNode -> AnyObject" , "contents": "elementWithName(${1:String}), URI:${2:String}))" },{ "trigger": "NSURLCredentialStorage \t NSURLCredentialStorage", "contents": "NSURLCredentialStorage" },{ "trigger": "NSProcessInfo \t NSProcessInfo", "contents": "NSProcessInfo" },{ "trigger": "NSOrderedSet) \t set:" , "contents": "NSOrderedSet(${1:SetNSObject}))" },{ "trigger": "NSAttributedString \t NSAttributedString", "contents": "NSAttributedString" },{ "trigger": "objectAtIndex) \t func Generator -> AnyObject" , "contents": "objectAtIndex(${1:Int}))" },{ "trigger": "shortValue \t Int", "contents": "shortValue" },{ "trigger": "removeDependency) \t func NSOperation -> void" , "contents": "removeDependency(${1:NSOperation}))" },{ "trigger": "NSStreamNetworkServiceTypeVideo \t String", "contents": "NSStreamNetworkServiceTypeVideo" },{ "trigger": "encodeObject) \t func NSCoder -> void" , "contents": "encodeObject(${1:AnyObject?}), forKey:${2:String}))" },{ "trigger": "NSPort) \t coder:" , "contents": "NSPort(coder:${1:NSCoder}))" },{ "trigger": "address \t NSData", "contents": "address" },{ "trigger": "intersectOrderedSet) \t func NSMutableOrderedSet -> void" , "contents": "intersectOrderedSet(${1:NSOrderedSet}))" },{ "trigger": "isEqualToAttributedString) \t func NSAttributedString -> Bool" , "contents": "isEqualToAttributedString(${1:NSAttributedString}))" },{ "trigger": "addOperationWithBlock) \t func NSOperationQueue -> Void)" , "contents": "addOperationWithBlock(${1: - Void}))" },{ "trigger": "replaceCharactersInRange) \t func NSMutableAttributedString -> void" , "contents": "replaceCharactersInRange(${1:NSRange}), withAttributedString:${2:NSAttributedString}))" },{ "trigger": "displayNameForKey) \t func NSLocale -> String?" , "contents": "displayNameForKey(${1:String}), value:${2:String}))" },{ "trigger": "setStringValue) \t func NSXMLNode -> void" , "contents": "setStringValue(${1:String}), resolvingEntities:${2:Bool}))" },{ "trigger": "NSComparisonPredicateModifier \t NSComparisonPredicateModifier", "contents": "NSComparisonPredicateModifier" },{ "trigger": "NSFileExtensionHidden \t String", "contents": "NSFileExtensionHidden" },{ "trigger": "copyWithZone) \t func NSXMLNode -> AnyObject" , "contents": "copyWithZone(${1:NSZone}))" },{ "trigger": "attributesOfFileSystemForPath) \t func NSFileManager -> [String" , "contents": "attributesOfFileSystemForPath(${1:String}))" },{ "trigger": "era \t Int", "contents": "era" },{ "trigger": "indexOfObjectPassingTest) \t func Generator -> Bool)" , "contents": "indexOfObjectPassingTest(${1:AnyObject}), Int:${2:}), UnsafeMutablePointerObjCBool:${3:}))" },{ "trigger": "dataWithJSONObject) \t class NSJSONSerialization -> NSData" , "contents": "dataWithJSONObject(${1:AnyObject}), options:${2:NSJSONWritingOptions}))" },{ "trigger": "secondsFromGMTForDate) \t func NSTimeZone -> Int" , "contents": "secondsFromGMTForDate(${1:NSDate}))" },{ "trigger": "NSURLSessionDataTask \t NSURLSessionDataTask", "contents": "NSURLSessionDataTask" },{ "trigger": "matchesInString) \t func NSRegularExpression -> [NSTextCheckingResult]" , "contents": "matchesInString(${1:String}), options:${2:NSMatchingOptions}), range:${3:NSRange}))" },{ "trigger": "networkServiceType \t NSURLRequestNetworkServiceType", "contents": "networkServiceType" },{ "trigger": "propertyForKey) \t class NSURLProtocol -> AnyObject?" , "contents": "propertyForKey(${1:String}), inRequest:${2:NSURLRequest}))" },{ "trigger": "bundlePath \t String", "contents": "bundlePath" },{ "trigger": "NSDecimalCompact) \t func unknown -> void" , "contents": "NSDecimalCompact(${1:UnsafeMutablePointerNSDecimal}))" },{ "trigger": "majorVersion \t Int", "contents": "majorVersion" },{ "trigger": "NSCalendarIdentifierEthiopicAmeteMihret \t String", "contents": "NSCalendarIdentifierEthiopicAmeteMihret" },{ "trigger": "decimalNumberByDividingBy) \t func NSDecimalNumber -> NSDecimalNumber" , "contents": "decimalNumberByDividingBy(${1:NSDecimalNumber}))" },{ "trigger": "minusSet) \t func NSMutableSet -> void" , "contents": "minusSet(${1:SetNSObject}))" },{ "trigger": "getIndexes) \t func NSIndexPath -> void" , "contents": "getIndexes(${1:UnsafeMutablePointerInt}), range:${2:NSRange}))" },{ "trigger": "firstIndex \t Int", "contents": "firstIndex" },{ "trigger": "NSCalendar \t NSCalendar", "contents": "NSCalendar" },{ "trigger": "NSBundle) \t forClass:" , "contents": "NSBundle(forClass:${1:AnyClass}))" },{ "trigger": "decodeBytesWithReturnedLength) \t func NSCoder -> UnsafeMutablePointer Void " , "contents": "decodeBytesWithReturnedLength(${1:UnsafeMutablePointerInt}))" },{ "trigger": "stringFromMeters) \t func NSLengthFormatter -> String" , "contents": "stringFromMeters(${1:Double}))" },{ "trigger": "insertObject) \t func NSMutableOrderedSet -> void" , "contents": "insertObject(${1:AnyObject}), atIndex:${2:Int}))" },{ "trigger": "NSStreamStatus \t NSStreamStatus", "contents": "NSStreamStatus" },{ "trigger": "NSOperatingSystemVersion) \t :" , "contents": "NSOperatingSystemVersion(${1:}))" },{ "trigger": "bitmapRepresentation \t NSData", "contents": "bitmapRepresentation" },{ "trigger": "replaceObjectsAtIndexes) \t func NSMutableOrderedSet -> void" , "contents": "replaceObjectsAtIndexes(${1:NSIndexSet}), withObjects:${2:[AnyObject]}))" },{ "trigger": "mutableCopyWithZone) \t func NSData -> AnyObject" , "contents": "mutableCopyWithZone(${1:NSZone}))" },{ "trigger": "NSDateComponentsFormatter) \t coder:" , "contents": "NSDateComponentsFormatter(${1:NSCoder}))" },{ "trigger": "roundingMode \t NSNumberFormatterRoundingMode", "contents": "roundingMode" },{ "trigger": "capitalizedStringWithLocale) \t func NSString -> String" , "contents": "capitalizedStringWithLocale(${1:NSLocale?}))" },{ "trigger": "NSDecimalCopy) \t func unknown -> void" , "contents": "NSDecimalCopy(${1:UnsafeMutablePointerNSDecimal}), _:${2:UnsafePointerNSDecimal}))" },{ "trigger": "hasSuffix) \t func NSString -> Bool" , "contents": "hasSuffix(${1:String}))" },{ "trigger": "doubleForKey) \t func NSUserDefaults -> Double" , "contents": "doubleForKey(${1:String}))" },{ "trigger": "NSStreamNetworkServiceType \t String", "contents": "NSStreamNetworkServiceType" },{ "trigger": "Generator) \t coder:" , "contents": "Generator(coder:${1:NSCoder}))" },{ "trigger": "scaleBy) \t func NSAffineTransform -> void" , "contents": "scaleBy(${1:CGFloat}))" },{ "trigger": "decodePoint) \t func NSCoder -> NSPoint" , "contents": "decodePoint(${1:}))" },{ "trigger": "stringByResolvingSymlinksInPath \t String", "contents": "stringByResolvingSymlinksInPath" },{ "trigger": "precomposedStringWithCompatibilityMapping \t String", "contents": "precomposedStringWithCompatibilityMapping" },{ "trigger": "encodeObject) \t func NSCoder -> void" , "contents": "encodeObject(${1:AnyObject?}))" },{ "trigger": "encodeWithCoder) \t func NSIndexPath -> void" , "contents": "encodeWithCoder(${1:NSCoder}))" },{ "trigger": "NSURLErrorCannotLoadFromNetwork \t Int", "contents": "NSURLErrorCannotLoadFromNetwork" },{ "trigger": "copyWithZone) \t func NSDateComponents -> AnyObject" , "contents": "copyWithZone(${1:NSZone}))" },{ "trigger": "Generator) \t :" , "contents": "Generator(${1:}))" },{ "trigger": "percentEncodedHost \t String", "contents": "percentEncodedHost" },{ "trigger": "NSHTTPCookieDiscard \t String", "contents": "NSHTTPCookieDiscard" },{ "trigger": "ordinalityOfUnit) \t func NSCalendar -> Int" , "contents": "ordinalityOfUnit(${1:NSCalendarUnit}), inUnit:${2:NSCalendarUnit}), forDate:${3:NSDate}))" },{ "trigger": "NSDecimalRound) \t func unknown -> void" , "contents": "NSDecimalRound(${1:UnsafeMutablePointerNSDecimal}), _:${2:UnsafePointerNSDecimal}), _:${3:Int}), _:${4:NSRoundingMode}))" },{ "trigger": "NSFileTypeUnknown \t String", "contents": "NSFileTypeUnknown" },{ "trigger": "NSURL) \t fileURLWithPath: isDirectory:" , "contents": "NSURL(fileURLWithPath:${1:String}), isDirectory:${2:Bool}))" },{ "trigger": "resolveNamespaceForName) \t func NSXMLElement -> NSXMLNode?" , "contents": "resolveNamespaceForName(${1:String}))" },{ "trigger": "startSecureConnection) \t func NSURLSessionStreamTask -> void" , "contents": "startSecureConnection(${1:}))" },{ "trigger": "NSComparisonPredicateOptions) \t rawValue:" , "contents": "NSComparisonPredicateOptions(${1:UInt}))" },{ "trigger": "NSDateComponentsFormatterZeroFormattingBehavior \t NSDateComponentsFormatterZeroFormattingBehavior", "contents": "NSDateComponentsFormatterZeroFormattingBehavior" },{ "trigger": "isSupersetOfSet) \t func NSCharacterSet -> Bool" , "contents": "isSupersetOfSet(${1:NSCharacterSet}))" },{ "trigger": "stringFromTimeInterval) \t func NSDateComponentsFormatter -> String?" , "contents": "stringFromTimeInterval(${1:NSTimeInterval}))" },{ "trigger": "isEqualToDictionary) \t func Generator -> Bool" , "contents": "isEqualToDictionary(${1:[NSObject }))" },{ "trigger": "NSNotificationCenter \t NSNotificationCenter", "contents": "NSNotificationCenter" },{ "trigger": "==) \t func unknown -> Bool" , "contents": "==(${1:CGSize}), rhs:${2:CGSize}))" },{ "trigger": "terminationReason \t NSTaskTerminationReason", "contents": "terminationReason" },{ "trigger": "realm \t String", "contents": "realm" },{ "trigger": "sortedCookiesUsingDescriptors) \t func NSHTTPCookieStorage -> [NSHTTPCookie]" , "contents": "sortedCookiesUsingDescriptors(${1:[NSSortDescriptor]}))" },{ "trigger": "localizedNameOfStringEncoding) \t static String -> String" , "contents": "localizedNameOfStringEncoding(${1:NSStringEncoding}))" },{ "trigger": "currentThread) \t static NSThread -> NSThread" , "contents": "currentThread(${1:}))" },{ "trigger": "NSTimeZone \t NSTimeZone", "contents": "NSTimeZone" },{ "trigger": "lock) \t func NSRecursiveLock -> void" , "contents": "lock(${1:}))" },{ "trigger": "allowedClasses \t Set", "contents": "allowedClasses" },{ "trigger": "NSDecimal \t NSDecimal", "contents": "NSDecimal" },{ "trigger": "abbreviationForDate) \t func NSTimeZone -> String?" , "contents": "abbreviationForDate(${1:NSDate}))" },{ "trigger": "fragment \t String", "contents": "fragment" },{ "trigger": "NSRectFromString) \t func unknown -> NSRect" , "contents": "NSRectFromString(${1:String}))" },{ "trigger": "insertChild) \t func NSXMLDocument -> void" , "contents": "insertChild(${1:NSXMLNode}), atIndex:${2:Int}))" },{ "trigger": "NSMinX) \t func unknown -> CGFloat" , "contents": "NSMinX(${1:NSRect}))" },{ "trigger": "generate) \t func NSOrderedSet -> NSFastGenerator" , "contents": "generate(${1:}))" },{ "trigger": "indexesOfObjectsWithOptions) \t func NSOrderedSet -> Bool)" , "contents": "indexesOfObjectsWithOptions(${1:NSEnumerationOptions}), passingTest:${2:AnyObject}), Int:${3:}), UnsafeMutablePointerObjCBool:${4:}))" },{ "trigger": "canBeConvertedToEncoding) \t func NSString -> Bool" , "contents": "canBeConvertedToEncoding(${1:UInt}))" },{ "trigger": "NSDecimalNumber) \t integerLiteral:" , "contents": "NSDecimalNumber(integerLiteral:${1:Int}))" },{ "trigger": "atEnd \t Bool", "contents": "atEnd" },{ "trigger": "predicateWithSubstitutionVariables) \t func NSPredicate -> Self" , "contents": "predicateWithSubstitutionVariables(${1:[String }))" },{ "trigger": "localizedStandardContainsString) \t func NSString -> Bool" , "contents": "localizedStandardContainsString(${1:String}))" },{ "trigger": "removeObjectForKey) \t func NSCache -> void" , "contents": "removeObjectForKey(${1:AnyObject}))" },{ "trigger": "NSSymbolStringEncoding \t UInt", "contents": "NSSymbolStringEncoding" },{ "trigger": "NSCache) \t :" , "contents": "NSCache(${1:}))" },{ "trigger": "writeData) \t func NSURLSessionStreamTask -> Void)" , "contents": "writeData(${1:NSData}), timeout:${2:NSTimeInterval}), completionHandler:${3:NSError? - Void}))" },{ "trigger": "NSIndexSet) \t coder:" , "contents": "NSIndexSet(coder:${1:NSCoder}))" },{ "trigger": "scanFloat) \t func NSScanner -> Float?" , "contents": "scanFloat(${1:}))" },{ "trigger": "encodeWithCoder) \t func NSURLAuthenticationChallenge -> void" , "contents": "encodeWithCoder(${1:NSCoder}))" },{ "trigger": "addAttribute) \t func NSMutableAttributedString -> void" , "contents": "addAttribute(${1:String}), value:${2:AnyObject}), range:${3:NSRange}))" },{ "trigger": "NSIndexSet) \t indexesInRange:" , "contents": "NSIndexSet(indexesInRange:${1:NSRange}))" },{ "trigger": "maximumRangeOfUnit) \t func NSCalendar -> NSRange" , "contents": "maximumRangeOfUnit(${1:NSCalendarUnit}))" },{ "trigger": "NSSortDescriptor \t NSSortDescriptor", "contents": "NSSortDescriptor" },{ "trigger": "sharedSession) \t class NSURLSession -> NSURLSession" , "contents": "sharedSession(${1:}))" },{ "trigger": "NSPersonNameComponentSuffix \t String", "contents": "NSPersonNameComponentSuffix" },{ "trigger": "dataTaskWithURL) \t func NSURLSession -> Void)" , "contents": "dataTaskWithURL(${1:NSURL}), completionHandler:${2:NSData?}), NSURLResponse?:${3:}), NSError?:${4:}))" },{ "trigger": "NSMaxY) \t func unknown -> CGFloat" , "contents": "NSMaxY(${1:NSRect}))" },{ "trigger": "localeIdentifierFromComponents) \t class NSLocale -> String" , "contents": "localeIdentifierFromComponents(${1:[String }))" },{ "trigger": "supportsSecureCoding) \t static NSPredicate -> Bool" , "contents": "supportsSecureCoding(${1:}))" },{ "trigger": "copyWithZone) \t func NSURL -> AnyObject" , "contents": "copyWithZone(${1:NSZone}))" },{ "trigger": "addOperation) \t func NSOperationQueue -> void" , "contents": "addOperation(${1:NSOperation}))" },{ "trigger": "setAttributesWithDictionary) \t func NSXMLElement -> void" , "contents": "setAttributesWithDictionary(${1:[String }))" },{ "trigger": "NSValue) \t rect:" , "contents": "NSValue(${1:NSRect}))" },{ "trigger": "NSData \t NSData", "contents": "NSData" },{ "trigger": "addObjectsFromArray) \t func NSMutableArray -> void" , "contents": "addObjectsFromArray(${1:[AnyObject]}))" },{ "trigger": "maximumFractionDigits \t Int", "contents": "maximumFractionDigits" },{ "trigger": "removeAllIndexes) \t func NSMutableIndexSet -> void" , "contents": "removeAllIndexes(${1:}))" },{ "trigger": "Int) \t _:" , "contents": "Int(_:${1:NSNumber}))" },{ "trigger": "compare) \t func NSString -> NSComparisonResult" , "contents": "compare(${1:String}), options:${2:NSStringCompareOptions}), range:${3:NSRange}), locale:${4:AnyObject?}))" },{ "trigger": "boolForKey) \t func NSUserDefaults -> Bool" , "contents": "boolForKey(${1:String}))" },{ "trigger": "getCString) \t func NSString -> Bool" , "contents": "getCString(${1:UnsafeMutablePointerInt8}), maxLength:${2:Int}), encoding:${3:UInt}))" },{ "trigger": "NSRoundingMode \t NSRoundingMode", "contents": "NSRoundingMode" },{ "trigger": "_conditionallyBridgeFromObject) \t static Double -> Bool" , "contents": "_conditionallyBridgeFromObject(${1:NSNumber}), inout:${2:Double?}))" },{ "trigger": "indexOfObjectPassingTest) \t func NSOrderedSet -> Bool)" , "contents": "indexOfObjectPassingTest(${1:AnyObject}), Int:${2:}), UnsafeMutablePointerObjCBool:${3:}))" },{ "trigger": "activeProcessorCount \t Int", "contents": "activeProcessorCount" },{ "trigger": "characterIsMember) \t func NSCharacterSet -> Bool" , "contents": "characterIsMember(${1:unichar}))" },{ "trigger": "NSFileHandle) \t forWritingAtPath:" , "contents": "NSFileHandle(forWritingAtPath:${1:String}))" },{ "trigger": "localizedCaseInsensitiveContainsString) \t func NSString -> Bool" , "contents": "localizedCaseInsensitiveContainsString(${1:String}))" },{ "trigger": "NSContainsRect) \t func unknown -> Bool" , "contents": "NSContainsRect(${1:NSRect}), _:${2:NSRect}))" },{ "trigger": "main) \t func NSThread -> void" , "contents": "main(${1:}))" },{ "trigger": "replaceObjectsInRange) \t func NSMutableArray -> void" , "contents": "replaceObjectsInRange(${1:NSRange}), withObjectsFromArray:${2:[AnyObject]}), range:${3:NSRange}))" },{ "trigger": "scheme \t String", "contents": "scheme" },{ "trigger": "NSFileDeviceIdentifier \t String", "contents": "NSFileDeviceIdentifier" },{ "trigger": "downloadTaskWithResumeData) \t func NSURLSession -> Void)" , "contents": "downloadTaskWithResumeData(${1:NSData}), completionHandler:${2:NSURL?}), NSURLResponse?:${3:}), NSError?:${4:}))" },{ "trigger": "copyWithZone) \t func NSValue -> AnyObject" , "contents": "copyWithZone(${1:NSZone}))" },{ "trigger": "indexOfObjectWithOptions) \t func Generator -> Bool)" , "contents": "indexOfObjectWithOptions(${1:NSEnumerationOptions}), passingTest:${2:AnyObject}), Int:${3:}), UnsafeMutablePointerObjCBool:${4:}))" },{ "trigger": "setAttributes) \t func NSFileManager -> void" , "contents": "setAttributes(${1:[String }), ofItemAtPath:${2:String}))" },{ "trigger": "encodeDouble) \t func NSCoder -> void" , "contents": "encodeDouble(${1:Double}), forKey:${2:String}))" },{ "trigger": "NSCalendarIdentifierChinese \t String", "contents": "NSCalendarIdentifierChinese" },{ "trigger": "sharedURLCache) \t class NSURLCache -> NSURLCache" , "contents": "sharedURLCache(${1:}))" },{ "trigger": "NSDateComponents \t NSDateComponents", "contents": "NSDateComponents" },{ "trigger": "NSDataBase) \t rawValue:" , "contents": "NSDataBase(${1:UInt}))" },{ "trigger": "setLocalizedDateFormatFromTemplate) \t func NSDateFormatter -> void" , "contents": "setLocalizedDateFormatFromTemplate(${1:String}))" },{ "trigger": "NSURLQueryItem) \t name: value:" , "contents": "NSURLQueryItem(${1:String}), value:${2:String?}))" },{ "trigger": "NSKeyedArchiveRootObjectKey \t String", "contents": "NSKeyedArchiveRootObjectKey" },{ "trigger": "pathsForResourcesOfType) \t func NSBundle -> [String]" , "contents": "pathsForResourcesOfType(${1:String?}), inDirectory:${2:String?}), forLocalization:${3:String?}))" },{ "trigger": "NSNumber \t NSNumber", "contents": "NSNumber" },{ "trigger": "sortWithOptions) \t func NSMutableOrderedSet -> void" , "contents": "sortWithOptions(${1:NSSortOptions}), usingComparator:${2:NSComparator}))" },{ "trigger": "NSSocketPort) \t protocolFamily: socketType: `protocol`: socket:" , "contents": "NSSocketPort(protocolFamily:${1:Int32}), socketType:${2:Int32}), `protocol`:${3:Int32}), socket:${4:NSSocketNativeHandle}))" },{ "trigger": "replaceBytesInRange) \t func NSMutableData -> void" , "contents": "replaceBytesInRange(${1:NSRange}), withBytes:${2:UnsafePointerVoid}), length:${3:Int}))" },{ "trigger": "NSDefaultRunLoopMode \t String", "contents": "NSDefaultRunLoopMode" },{ "trigger": "localizedStringForStatusCode) \t class NSHTTPURLResponse -> String" , "contents": "localizedStringForStatusCode(${1:Int}))" },{ "trigger": "nonBaseCharacterSet) \t class NSCharacterSet -> NSCharacterSet" , "contents": "nonBaseCharacterSet(${1:}))" },{ "trigger": "NSCalendarIdentifierJapanese \t String", "contents": "NSCalendarIdentifierJapanese" },{ "trigger": "NSDateComponentsFormatterZeroFormattingBehavior) \t rawValue:" , "contents": "NSDateComponentsFormatterZeroFormattingBehavior(${1:UInt}))" },{ "trigger": "NSStreamSocketSecurityLevelNone \t String", "contents": "NSStreamSocketSecurityLevelNone" },{ "trigger": "NSInputStream) \t URL:" , "contents": "NSInputStream(URL:${1:NSURL}))" },{ "trigger": "NSByteCountFormatter \t NSByteCountFormatter", "contents": "NSByteCountFormatter" },{ "trigger": "NSURLProtocol) \t request: cachedResponse: client:" , "contents": "NSURLProtocol(${1:NSURLRequest}), cachedResponse:${2:NSCachedURLResponse?}), client:${3:NSURLProtocolClient?}))" },{ "trigger": "hasBytesAvailable \t Bool", "contents": "hasBytesAvailable" },{ "trigger": "lockWhenCondition) \t func NSConditionLock -> Bool" , "contents": "lockWhenCondition(${1:Int}), beforeDate:${2:NSDate}))" },{ "trigger": "CGRectEdge \t CGRectEdge", "contents": "CGRectEdge" },{ "trigger": "NSData) \t contentsOfURL: options:" , "contents": "NSData(contentsOfURL:${1:NSURL}), options:${2:NSDataReadingOptions}))" },{ "trigger": "includesTimeRemainingPhrase \t Bool", "contents": "includesTimeRemainingPhrase" },{ "trigger": "decimalSeparator \t String", "contents": "decimalSeparator" },{ "trigger": "containsObject) \t func NSOrderedSet -> Bool" , "contents": "containsObject(${1:AnyObject}))" },{ "trigger": "replaceChildAtIndex) \t func NSXMLElement -> void" , "contents": "replaceChildAtIndex(${1:Int}), withNode:${2:NSXMLNode}))" },{ "trigger": "decodeDoubleForKey) \t func NSCoder -> Double" , "contents": "decodeDoubleForKey(${1:String}))" },{ "trigger": "rangeOfPassword \t NSRange", "contents": "rangeOfPassword" },{ "trigger": "arrayByAddingObjectsFromArray) \t func Generator -> [AnyObject]" , "contents": "arrayByAddingObjectsFromArray(${1:[AnyObject]}))" },{ "trigger": "encodeInt32) \t func NSCoder -> void" , "contents": "encodeInt32(${1:Int32}), forKey:${2:String}))" },{ "trigger": "domain \t String", "contents": "domain" },{ "trigger": "NSStringFromRect) \t func unknown -> String" , "contents": "NSStringFromRect(${1:NSRect}))" },{ "trigger": "uppercaseLetterCharacterSet) \t class NSCharacterSet -> NSCharacterSet" , "contents": "uppercaseLetterCharacterSet(${1:}))" },{ "trigger": "enumerateRangesUsingBlock) \t func NSIndexSet -> Void)" , "contents": "enumerateRangesUsingBlock(${1:NSRange}), UnsafeMutablePointerObjCBool:${2:}))" },{ "trigger": "validate) \t func NSXMLDocument -> void" , "contents": "validate(${1:}))" },{ "trigger": "options \t NSComparisonPredicateOptions", "contents": "options" },{ "trigger": "NSFileHFSCreatorCode \t String", "contents": "NSFileHFSCreatorCode" },{ "trigger": "supportsSecureCoding) \t static NSExpression -> Bool" , "contents": "supportsSecureCoding(${1:}))" },{ "trigger": "objCType \t UnsafePointer", "contents": "objCType" },{ "trigger": "NSDateComponentUndefined \t Int", "contents": "NSDateComponentUndefined" },{ "trigger": "charValue \t Int", "contents": "charValue" },{ "trigger": "executablePath \t String", "contents": "executablePath" },{ "trigger": "enumerateObjectsWithOptions) \t func NSSet -> Void)" , "contents": "enumerateObjectsWithOptions(${1:NSEnumerationOptions}), usingBlock:${2:AnyObject}), UnsafeMutablePointerObjCBool:${3:}))" },{ "trigger": "CGFloat) \t _:" , "contents": "CGFloat(_:${1:Double}))" },{ "trigger": "CGSize \t CGSize", "contents": "CGSize" },{ "trigger": "storeCachedResponse) \t func NSURLCache -> void" , "contents": "storeCachedResponse(${1:NSCachedURLResponse}), forDataTask:${2:NSURLSessionDataTask}))" },{ "trigger": "NSByteCountFormatter) \t coder:" , "contents": "NSByteCountFormatter(${1:NSCoder}))" },{ "trigger": "localizedStringFromNumber) \t class NSNumberFormatter -> String" , "contents": "localizedStringFromNumber(${1:NSNumber}), numberStyle:${2:NSNumberFormatterStyle}))" },{ "trigger": "numberStyle \t NSNumberFormatterStyle", "contents": "numberStyle" },{ "trigger": "decodeSize) \t func NSCoder -> NSSize" , "contents": "decodeSize(${1:}))" },{ "trigger": "URLByAppendingPathComponent) \t func NSURL -> NSURL?" , "contents": "URLByAppendingPathComponent(${1:String}))" },{ "trigger": "setCredential) \t func NSURLCredentialStorage -> void" , "contents": "setCredential(${1:NSURLCredential}), forProtectionSpace:${2:NSURLProtectionSpace}), task:${3:NSURLSessionTask}))" },{ "trigger": "originalRequest \t NSURLRequest", "contents": "originalRequest" },{ "trigger": "parserError \t NSError", "contents": "parserError" },{ "trigger": "NSAffineTransformStruct) \t :" , "contents": "NSAffineTransformStruct(${1:}))" },{ "trigger": "timeoutIntervalForRequest \t NSTimeInterval", "contents": "timeoutIntervalForRequest" },{ "trigger": "sharedHTTPCookieStorage) \t class NSHTTPCookieStorage -> NSHTTPCookieStorage" , "contents": "sharedHTTPCookieStorage(${1:}))" },{ "trigger": "NSFileTypeSocket \t String", "contents": "NSFileTypeSocket" },{ "trigger": "NSLock) \t :" , "contents": "NSLock(${1:}))" },{ "trigger": "setObject) \t func NSMutableOrderedSet -> void" , "contents": "setObject(${1:AnyObject}), atIndex:${2:Int}))" },{ "trigger": "removeObject) \t func NSMutableOrderedSet -> void" , "contents": "removeObject(${1:AnyObject}))" },{ "trigger": "NSStreamSOCKSProxyUserKey \t String", "contents": "NSStreamSOCKSProxyUserKey" },{ "trigger": "stringByReplacingCharactersInRange) \t func NSString -> String" , "contents": "stringByReplacingCharactersInRange(${1:NSRange}), withString:${2:String}))" },{ "trigger": "systemTimeZone) \t class NSTimeZone -> NSTimeZone" , "contents": "systemTimeZone(${1:}))" },{ "trigger": "TLSMaximumSupportedProtocol \t SSLProtocol", "contents": "TLSMaximumSupportedProtocol" },{ "trigger": "NSVolumeEnumerationOptions) \t rawValue:" , "contents": "NSVolumeEnumerationOptions(${1:UInt}))" },{ "trigger": "isSubsetOfOrderedSet) \t func NSOrderedSet -> Bool" , "contents": "isSubsetOfOrderedSet(${1:NSOrderedSet}))" },{ "trigger": "removeObjectsForKeys) \t func NSMutableDictionary -> void" , "contents": "removeObjectsForKeys(${1:[AnyObject]}))" },{ "trigger": "NSFormattingContext \t NSFormattingContext", "contents": "NSFormattingContext" },{ "trigger": "decodePropertyListForKey) \t func NSCoder -> AnyObject?" , "contents": "decodePropertyListForKey(${1:String}))" },{ "trigger": "NSProgressFileTotalCountKey \t String", "contents": "NSProgressFileTotalCountKey" },{ "trigger": "setByAddingObject) \t func NSSet -> Set NSObject " , "contents": "setByAddingObject(${1:AnyObject}))" },{ "trigger": "addObject) \t func NSMutableSet -> void" , "contents": "addObject(${1:AnyObject}))" },{ "trigger": "dateStyle \t NSDateFormatterStyle", "contents": "dateStyle" },{ "trigger": "exponentSymbol \t String", "contents": "exponentSymbol" },{ "trigger": "isExecutableFileAtPath) \t func NSFileManager -> Bool" , "contents": "isExecutableFileAtPath(${1:String}))" },{ "trigger": "localizedNameOfStringEncoding) \t class NSString -> String" , "contents": "localizedNameOfStringEncoding(${1:UInt}))" },{ "trigger": "localName \t String", "contents": "localName" },{ "trigger": "removeItemAtURL) \t func NSFileManager -> void" , "contents": "removeItemAtURL(${1:NSURL}))" },{ "trigger": "toRange) \t func NSRange -> Range Int ?" , "contents": "toRange(${1:}))" },{ "trigger": "scale) \t func NSDecimalNumberHandler -> Int16" , "contents": "scale(${1:}))" },{ "trigger": "multiplier \t NSNumber", "contents": "multiplier" },{ "trigger": "notANumber) \t class NSDecimalNumber -> NSDecimalNumber" , "contents": "notANumber(${1:}))" },{ "trigger": "subpathsOfDirectoryAtPath) \t func NSFileManager -> [String]" , "contents": "subpathsOfDirectoryAtPath(${1:String}))" },{ "trigger": "NSURLErrorDomain \t String", "contents": "NSURLErrorDomain" },{ "trigger": "Generator) \t object:" , "contents": "Generator(object:${1:AnyObject}))" },{ "trigger": "localizedFailureReason \t String", "contents": "localizedFailureReason" },{ "trigger": "setSet) \t func NSMutableSet -> void" , "contents": "setSet(${1:SetNSObject}))" },{ "trigger": "NSXMLDocument) \t rootElement:" , "contents": "NSXMLDocument(rootElement:${1:NSXMLElement?}))" },{ "trigger": "NSMidX) \t func unknown -> CGFloat" , "contents": "NSMidX(${1:NSRect}))" },{ "trigger": "firstMatchInString) \t func NSRegularExpression -> NSTextCheckingResult?" , "contents": "firstMatchInString(${1:String}), options:${2:NSMatchingOptions}), range:${3:NSRange}))" },{ "trigger": "NSXMLNodePreserveQuotes \t NSXMLNodeOptionRawType", "contents": "NSXMLNodePreserveQuotes" },{ "trigger": "characterEncoding \t String", "contents": "characterEncoding" },{ "trigger": "NSStreamDataWrittenToMemoryStreamKey \t String", "contents": "NSStreamDataWrittenToMemoryStreamKey" },{ "trigger": "encodeInt64) \t func NSCoder -> void" , "contents": "encodeInt64(${1:Int64}), forKey:${2:String}))" },{ "trigger": "bundleURL \t NSURL", "contents": "bundleURL" },{ "trigger": "fileURL \t Bool", "contents": "fileURL" },{ "trigger": "encodeConditionalObject) \t func NSCoder -> void" , "contents": "encodeConditionalObject(${1:AnyObject?}), forKey:${2:String}))" },{ "trigger": "NSTextCheckingType) \t rawValue:" , "contents": "NSTextCheckingType(${1:UInt64}))" },{ "trigger": "NSNotFound \t Int", "contents": "NSNotFound" },{ "trigger": "rangeOfString) \t func NSString -> NSRange" , "contents": "rangeOfString(${1:String}))" },{ "trigger": "+=) \t func unknown -> void" , "contents": "+=(inout:${1:CGFloat}), rhs:${2:CGFloat}))" },{ "trigger": "NSMutableData \t NSMutableData", "contents": "NSMutableData" },{ "trigger": "NSSizeFromString) \t func unknown -> NSSize" , "contents": "NSSizeFromString(${1:String}))" },{ "trigger": "NSDataSearchOptions) \t rawValue:" , "contents": "NSDataSearchOptions(${1:UInt}))" },{ "trigger": "descriptionWithLocale) \t func NSOrderedSet -> String" , "contents": "descriptionWithLocale(${1:AnyObject?}), indent:${2:Int}))" },{ "trigger": "zero) \t class NSDecimalNumber -> NSDecimalNumber" , "contents": "zero(${1:}))" },{ "trigger": "canonicalLanguageIdentifierFromString) \t class NSLocale -> String" , "contents": "canonicalLanguageIdentifierFromString(${1:String}))" },{ "trigger": "unknown) \t rawValue:" , "contents": "unknown(${1:RawValue}))" },{ "trigger": "nextSibling \t NSXMLNode", "contents": "nextSibling" },{ "trigger": "discretionary \t Bool", "contents": "discretionary" },{ "trigger": "dataUsingEncoding) \t func NSString -> NSData?" , "contents": "dataUsingEncoding(${1:UInt}))" },{ "trigger": "NSFileCreationDate \t String", "contents": "NSFileCreationDate" },{ "trigger": "internationalCurrencySymbol \t String", "contents": "internationalCurrencySymbol" },{ "trigger": "globallyUniqueString \t String", "contents": "globallyUniqueString" },{ "trigger": "tryLock) \t func NSConditionLock -> Bool" , "contents": "tryLock(${1:}))" },{ "trigger": "lock) \t func NSCondition -> void" , "contents": "lock(${1:}))" },{ "trigger": "location \t Int", "contents": "location" },{ "trigger": "NSTaskTerminationReason \t NSTaskTerminationReason", "contents": "NSTaskTerminationReason" },{ "trigger": "minimumSignificantDigits \t Int", "contents": "minimumSignificantDigits" },{ "trigger": "enumerateLinesUsingBlock) \t func NSString -> Void)" , "contents": "enumerateLinesUsingBlock(${1:String}), UnsafeMutablePointerObjCBool:${2:}))" },{ "trigger": "secure \t Bool", "contents": "secure" },{ "trigger": "NSXMLNodeExpandEmptyElement \t NSXMLNodeOptionRawType", "contents": "NSXMLNodeExpandEmptyElement" },{ "trigger": "NSURLCredentialStorageRemoveSynchronizableCredentials \t String", "contents": "NSURLCredentialStorageRemoveSynchronizableCredentials" },{ "trigger": "unitStringFromValue) \t func NSMassFormatter -> String" , "contents": "unitStringFromValue(${1:Double}), unit:${2:NSMassFormatterUnit}))" },{ "trigger": "_conditionallyBridgeFromObject) \t static Dictionary -> Bool" , "contents": "_conditionallyBridgeFromObject(${1:NSDictionary}), inout:${2:Dictionary?}))" },{ "trigger": "minimum \t NSNumber", "contents": "minimum" },{ "trigger": "countOfBytesExpectedToReceive \t Int", "contents": "countOfBytesExpectedToReceive" },{ "trigger": "day \t Int", "contents": "day" },{ "trigger": "removePersistentDomainForName) \t func NSUserDefaults -> void" , "contents": "removePersistentDomainForName(${1:String}))" },{ "trigger": "NSString) \t UTF8String:" , "contents": "NSString(UTF8String:${1:UnsafePointerInt8}))" },{ "trigger": "intersectsSet) \t func NSOrderedSet -> Bool" , "contents": "intersectsSet(${1:SetNSObject}))" },{ "trigger": "NSTimer \t NSTimer", "contents": "NSTimer" },{ "trigger": "stringsByAppendingPaths) \t func NSString -> [String]" , "contents": "stringsByAppendingPaths(${1:[String]}))" },{ "trigger": "outputStreamToMemory) \t class NSOutputStream -> Self" , "contents": "outputStreamToMemory(${1:}))" },{ "trigger": "rangeOfString) \t func NSString -> NSRange" , "contents": "rangeOfString(${1:String}), options:${2:NSStringCompareOptions}), range:${3:NSRange}), locale:${4:NSLocale?}))" },{ "trigger": "setDefaultTimeZone) \t class NSTimeZone -> void" , "contents": "setDefaultTimeZone(${1:NSTimeZone}))" },{ "trigger": "removeObject) \t func NSMutableArray -> void" , "contents": "removeObject(${1:AnyObject}), inRange:${2:NSRange}))" },{ "trigger": "mainQueue) \t class NSOperationQueue -> NSOperationQueue" , "contents": "mainQueue(${1:}))" },{ "trigger": "stringForKey) \t func NSUserDefaults -> String?" , "contents": "stringForKey(${1:String}))" },{ "trigger": "NSXMLNodePreserveWhitespace \t NSXMLNodeOptionRawType", "contents": "NSXMLNodePreserveWhitespace" },{ "trigger": "NSBundle \t NSBundle", "contents": "NSBundle" },{ "trigger": "indexGreaterThanOrEqualToIndex) \t func NSIndexSet -> Int" , "contents": "indexGreaterThanOrEqualToIndex(${1:Int}))" },{ "trigger": "NSAffineTransformStruct) \t m11: m12: m21: m22: tX: tY:" , "contents": "NSAffineTransformStruct(${1:CGFloat}), m12:${2:CGFloat}), m21:${3:CGFloat}), m22:${4:CGFloat}), tX:${5:CGFloat}), tY:${6:CGFloat}))" },{ "trigger": "rangeOfWeekendContaining) \t func NSCalendar -> NSDateInterval?" , "contents": "rangeOfWeekendContaining(${1:NSDate}))" },{ "trigger": "NSUnionRect) \t func unknown -> NSRect" , "contents": "NSUnionRect(${1:NSRect}), _:${2:NSRect}))" },{ "trigger": "sortedArrayUsingFunction) \t func Generator -> Int," , "contents": "sortedArrayUsingFunction(comparator:${1:@conventionc AnyObject}), AnyObject:${2:}), UnsafeMutablePointerVoid:${3:}), context:${4:UnsafeMutablePointerVoid}))" },{ "trigger": "enumerateObjectsUsingBlock) \t func NSSet -> Void)" , "contents": "enumerateObjectsUsingBlock(${1:AnyObject}), UnsafeMutablePointerObjCBool:${2:}))" },{ "trigger": "NSObject) \t :" , "contents": "NSObject(${1:}))" },{ "trigger": "decimalNumberByRoundingAccordingToBehavior) \t func NSDecimalNumber -> NSDecimalNumber" , "contents": "decimalNumberByRoundingAccordingToBehavior(${1:NSDecimalNumberBehaviors?}))" },{ "trigger": "getTasksWithCompletionHandler) \t func NSURLSession -> Void)" , "contents": "getTasksWithCompletionHandler(${1:[NSURLSessionDataTask]}), [NSURLSessionUploadTask]:${2:}), [NSURLSessionDownloadTask]:${3:}))" },{ "trigger": "uploadTaskWithStreamedRequest) \t func NSURLSession -> NSURLSessionUploadTask" , "contents": "uploadTaskWithStreamedRequest(${1:NSURLRequest}))" },{ "trigger": "timeoutIntervalForResource \t NSTimeInterval", "contents": "timeoutIntervalForResource" },{ "trigger": "NSDataWritingOptions \t NSDataWritingOptions", "contents": "NSDataWritingOptions" },{ "trigger": "encodeInt) \t func NSCoder -> void" , "contents": "encodeInt(${1:Int32}), forKey:${2:String}))" },{ "trigger": "removeObserver) \t func NSNotificationCenter -> void" , "contents": "removeObserver(${1:AnyObject}), name:${2:String?}), object:${3:AnyObject?}))" },{ "trigger": "beginEditing) \t func NSMutableAttributedString -> void" , "contents": "beginEditing(${1:}))" },{ "trigger": "socket \t NSSocketNativeHandle", "contents": "socket" },{ "trigger": "NSLocaleCalendar \t String", "contents": "NSLocaleCalendar" },{ "trigger": "===) \t func unknown -> Bool" , "contents": "===(${1:NSNull?}), rhs:${2:NSNull?}))" },{ "trigger": "NSXMLDocument) \t contentsOfURL: options:" , "contents": "NSXMLDocument(contentsOfURL:${1:NSURL}), options:${2:Int}))" },{ "trigger": "NSXMLParserExternalEntityResolvingPolicy \t NSXMLParserExternalEntityResolvingPolicy", "contents": "NSXMLParserExternalEntityResolvingPolicy" },{ "trigger": "NSProgressFileOperationKindCopying \t String", "contents": "NSProgressFileOperationKindCopying" },{ "trigger": "NSIntersectsRect) \t func unknown -> Bool" , "contents": "NSIntersectsRect(${1:NSRect}), _:${2:NSRect}))" },{ "trigger": "NSData) \t contentsOfFile:" , "contents": "NSData(contentsOfFile:${1:String}))" },{ "trigger": "NSMatchingFlags \t NSMatchingFlags", "contents": "NSMatchingFlags" },{ "trigger": "NSDataBase \t NSDataBase", "contents": "NSDataBase" },{ "trigger": "removePropertyForKey) \t class NSURLProtocol -> void" , "contents": "removePropertyForKey(${1:String}), inRequest:${2:NSMutableURLRequest}))" },{ "trigger": "NSIntegralRect) \t func unknown -> NSRect" , "contents": "NSIntegralRect(${1:NSRect}))" },{ "trigger": "countOfBytesExpectedToSend \t Int", "contents": "countOfBytesExpectedToSend" },{ "trigger": "error \t NSError", "contents": "error" },{ "trigger": "appStoreReceiptURL \t NSURL", "contents": "appStoreReceiptURL" },{ "trigger": "nodesForXPath) \t func NSXMLNode -> [NSXMLNode]" , "contents": "nodesForXPath(${1:String}))" },{ "trigger": "Generator) \t objects: forKeys: count:" , "contents": "Generator(${1:UnsafePointerAnyObject}), forKeys:${2:UnsafePointerNSObject}), count:${3:Int}))" },{ "trigger": "CGFloat) \t :" , "contents": "CGFloat(${1:}))" },{ "trigger": "countLimit \t Int", "contents": "countLimit" },{ "trigger": "bridge) \t func NSDictionary -> [NSObject:" , "contents": "bridge(${1:}))" },{ "trigger": "NSAttributedString) \t string: attributes:" , "contents": "NSAttributedString(string:${1:String}), attributes:${2:[String }))" },{ "trigger": "NSCondition \t NSCondition", "contents": "NSCondition" },{ "trigger": "weekOfMonth \t Int", "contents": "weekOfMonth" },{ "trigger": "NSMacOSRomanStringEncoding \t UInt", "contents": "NSMacOSRomanStringEncoding" },{ "trigger": "NSAttributedString) \t string:" , "contents": "NSAttributedString(string:${1:String}))" },{ "trigger": "NSPersonNameComponentsFormatter) \t coder:" , "contents": "NSPersonNameComponentsFormatter(${1:NSCoder}))" },{ "trigger": "elementsForLocalName) \t func NSXMLElement -> [NSXMLElement]" , "contents": "elementsForLocalName(${1:String}), URI:${2:String?}))" },{ "trigger": "NSURLErrorCannotCloseFile \t Int", "contents": "NSURLErrorCannotCloseFile" },{ "trigger": "versionForClassName) \t func NSCoder -> Int" , "contents": "versionForClassName(${1:String}))" },{ "trigger": "NSPostingStyle \t NSPostingStyle", "contents": "NSPostingStyle" },{ "trigger": "distantFuture) \t class NSDate -> NSDate" , "contents": "distantFuture(${1:}))" },{ "trigger": "dateFormat \t String", "contents": "dateFormat" },{ "trigger": "==) \t func unknown -> Bool" , "contents": "==(${1:NSObject}), rhs:${2:NSObject}))" },{ "trigger": "NSProgress) \t totalUnitCount:" , "contents": "NSProgress(totalUnitCount:${1:Int64}))" },{ "trigger": "URLByStandardizingPath \t NSURL", "contents": "URLByStandardizingPath" },{ "trigger": "componentsToDisplayForPath) \t func NSFileManager -> [String]?" , "contents": "componentsToDisplayForPath(${1:String}))" },{ "trigger": "NSHeight) \t func unknown -> CGFloat" , "contents": "NSHeight(${1:NSRect}))" },{ "trigger": "NSSearchPathForDirectoriesInDomains) \t func unknown -> [String]" , "contents": "NSSearchPathForDirectoriesInDomains(${1:NSSearchPathDirectory}), _:${2:NSSearchPathDomainMask}), _:${3:Bool}))" },{ "trigger": "NSCountedSet) \t set:" , "contents": "NSCountedSet(${1:SetNSObject}))" },{ "trigger": "dateByAddingTimeInterval) \t func NSDate -> NSDate" , "contents": "dateByAddingTimeInterval(${1:NSTimeInterval}))" },{ "trigger": "NSURLSessionStreamTask \t NSURLSessionStreamTask", "contents": "NSURLSessionStreamTask" },{ "trigger": "previousSibling \t NSXMLNode", "contents": "previousSibling" },{ "trigger": "NSDecimalNumber) \t mantissa: exponent: isNegative:" , "contents": "NSDecimalNumber(${1:UInt64}), exponent:${2:Int16}), isNegative:${3:Bool}))" },{ "trigger": "NSOrderedSet) \t array: copyItems:" , "contents": "NSOrderedSet(array:${1:[AnyObject]}), copyItems:${2:Bool}))" },{ "trigger": "failWithError) \t func NSCoder -> void" , "contents": "failWithError(${1:NSError}))" },{ "trigger": "generate) \t func NSIndexSet -> Generator" , "contents": "generate(${1:}))" },{ "trigger": "components) \t func NSCalendar -> NSDateComponents" , "contents": "components(${1:NSCalendarUnit}), fromDate:${2:NSDate}), toDate:${3:NSDate}), options:${4:NSCalendarOptions}))" },{ "trigger": "NSURLAuthenticationChallenge) \t authenticationChallenge:" , "contents": "NSURLAuthenticationChallenge(authenticationChallenge:${1:NSURLAuthenticationChallenge}))" },{ "trigger": "anyObject) \t func NSSet -> AnyObject?" , "contents": "anyObject(${1:}))" },{ "trigger": "predefinedEntityDeclarationForName) \t class NSXMLDTD -> NSXMLDTDNode?" , "contents": "predefinedEntityDeclarationForName(${1:String}))" },{ "trigger": "supportsSecureCoding) \t func NSSortDescriptor -> Bool" , "contents": "supportsSecureCoding(${1:}))" },{ "trigger": "NSURLCache \t NSURLCache", "contents": "NSURLCache" },{ "trigger": "preferredLanguages) \t class NSLocale -> [String]" , "contents": "preferredLanguages(${1:}))" },{ "trigger": "hasPrefix) \t func String -> Bool" , "contents": "hasPrefix(${1:String}))" },{ "trigger": "canBeConvertedToEncoding) \t func String -> Bool" , "contents": "canBeConvertedToEncoding(${1:NSStringEncoding}))" },{ "trigger": "fileHandleWithNullDevice) \t class NSFileHandle -> NSFileHandle" , "contents": "fileHandleWithNullDevice(${1:}))" },{ "trigger": "minute \t Int", "contents": "minute" },{ "trigger": "NSRunLoopCommonModes \t String", "contents": "NSRunLoopCommonModes" },{ "trigger": "sortUsingComparator) \t func NSMutableArray -> void" , "contents": "sortUsingComparator(${1:NSComparator}))" },{ "trigger": "NSDateComponentsFormatter \t NSDateComponentsFormatter", "contents": "NSDateComponentsFormatter" },{ "trigger": "scaleXBy) \t func NSAffineTransform -> void" , "contents": "scaleXBy(${1:CGFloat}), yBy:${2:CGFloat}))" },{ "trigger": "NSURLSessionTask) \t :" , "contents": "NSURLSessionTask(${1:}))" },{ "trigger": "encodeWithCoder) \t func NSCachedURLResponse -> void" , "contents": "encodeWithCoder(${1:NSCoder}))" },{ "trigger": "addCharactersInRange) \t func NSMutableCharacterSet -> void" , "contents": "addCharactersInRange(${1:NSRange}))" },{ "trigger": "NSIndexPath) \t indexes: length:" , "contents": "NSIndexPath(${1:UnsafePointerInt}), length:${2:Int}))" },{ "trigger": "objectEnumerator) \t func NSOrderedSet -> NSEnumerator" , "contents": "objectEnumerator(${1:}))" },{ "trigger": "removeNamespaceForPrefix) \t func NSXMLElement -> void" , "contents": "removeNamespaceForPrefix(${1:String}))" },{ "trigger": "JSONObjectWithStream) \t class NSJSONSerialization -> AnyObject" , "contents": "JSONObjectWithStream(${1:NSInputStream}), options:${2:NSJSONReadingOptions}))" },{ "trigger": "nextNode \t NSXMLNode", "contents": "nextNode" },{ "trigger": "mutableCopyWithZone) \t func NSAttributedString -> AnyObject" , "contents": "mutableCopyWithZone(${1:NSZone}))" },{ "trigger": "NSURLProtectionSpaceHTTPS \t String", "contents": "NSURLProtectionSpaceHTTPS" },{ "trigger": "NSByteCountFormatterCountStyle \t NSByteCountFormatterCountStyle", "contents": "NSByteCountFormatterCountStyle" },{ "trigger": "currentCalendar) \t class NSCalendar -> NSCalendar" , "contents": "currentCalendar(${1:}))" },{ "trigger": "secondsFromGMT \t Int", "contents": "secondsFromGMT" },{ "trigger": "NSHTTPCookiePort \t String", "contents": "NSHTTPCookiePort" },{ "trigger": "stopSecureConnection) \t func NSURLSessionStreamTask -> void" , "contents": "stopSecureConnection(${1:}))" },{ "trigger": "NSProgress \t NSProgress", "contents": "NSProgress" },{ "trigger": "scanFloat) \t func NSScanner -> Bool" , "contents": "scanFloat(${1:UnsafeMutablePointerFloat}))" },{ "trigger": "exchangeObjectAtIndex) \t func NSMutableArray -> void" , "contents": "exchangeObjectAtIndex(${1:Int}), withObjectAtIndex:${2:Int}))" },{ "trigger": "minorVersion \t Int", "contents": "minorVersion" },{ "trigger": "NSFormatter) \t coder:" , "contents": "NSFormatter(${1:NSCoder}))" },{ "trigger": "close) \t func NSStream -> void" , "contents": "close(${1:}))" },{ "trigger": "priority \t Float", "contents": "priority" },{ "trigger": "NSPersonNameComponents \t NSPersonNameComponents", "contents": "NSPersonNameComponents" },{ "trigger": "minimumFractionDigits \t Int", "contents": "minimumFractionDigits" },{ "trigger": "NSPersonNameComponentPrefix \t String", "contents": "NSPersonNameComponentPrefix" },{ "trigger": "NSURLProtectionSpace \t NSURLProtectionSpace", "contents": "NSURLProtectionSpace" },{ "trigger": "NSURLAuthenticationMethodServerTrust \t String", "contents": "NSURLAuthenticationMethodServerTrust" },{ "trigger": "NSMutableData) \t length:" , "contents": "NSMutableData(${1:Int}))" },{ "trigger": "NSXMLParser) \t data:" , "contents": "NSXMLParser(${1:NSData}))" },{ "trigger": "NSXMLParser) \t stream:" , "contents": "NSXMLParser(${1:NSInputStream}))" },{ "trigger": "addCharactersInString) \t func NSMutableCharacterSet -> void" , "contents": "addCharactersInString(${1:String}))" },{ "trigger": "ISOLanguageCodes) \t class NSLocale -> [String]" , "contents": "ISOLanguageCodes(${1:}))" },{ "trigger": "NSCalendarIdentifierCoptic \t String", "contents": "NSCalendarIdentifierCoptic" },{ "trigger": "autoupdatingCurrentCalendar) \t class NSCalendar -> NSCalendar" , "contents": "autoupdatingCurrentCalendar(${1:}))" },{ "trigger": "NSData) \t bytesNoCopy: length: deallocator: Int:" , "contents": "NSData(bytesNoCopy:${1:UnsafeMutablePointerVoid}), length:${2:Int}), deallocator:${3:UnsafeMutablePointerVoid}), Int:${4:}))" },{ "trigger": "NSLocale) \t coder:" , "contents": "NSLocale(coder:${1:NSCoder}))" },{ "trigger": "NSTextCheckingResult) \t coder:" , "contents": "NSTextCheckingResult(coder:${1:NSCoder}))" },{ "trigger": "insertChild) \t func NSXMLDTD -> void" , "contents": "insertChild(${1:NSXMLNode}), atIndex:${2:Int}))" },{ "trigger": "NSXMLNodeOptionsNone \t NSXMLNodeOptionRawType", "contents": "NSXMLNodeOptionsNone" },{ "trigger": "finishEncoding) \t func NSKeyedArchiver -> void" , "contents": "finishEncoding(${1:}))" },{ "trigger": "NSExpressionType \t NSExpressionType", "contents": "NSExpressionType" },{ "trigger": "intValue \t Int", "contents": "intValue" },{ "trigger": "NSFileOwnerAccountID \t String", "contents": "NSFileOwnerAccountID" },{ "trigger": "indexesInRange) \t func NSIndexSet -> Bool)" , "contents": "indexesInRange(${1:NSRange}), options:${2:NSEnumerationOptions}), passingTest:${3:Int}), UnsafeMutablePointerObjCBool:${4:}))" },{ "trigger": "NSJapaneseEUCStringEncoding \t UInt", "contents": "NSJapaneseEUCStringEncoding" },{ "trigger": "NSFileHandleReadToEndOfFileCompletionNotification \t String", "contents": "NSFileHandleReadToEndOfFileCompletionNotification" },{ "trigger": "localizedName \t String", "contents": "localizedName" },{ "trigger": "decodeInt64ForKey) \t func NSCoder -> Int64" , "contents": "decodeInt64ForKey(${1:String}))" },{ "trigger": "NSDecimal) \t _exponent: _length: _isNegative: _isCompact: _reserved: _mantissa: UInt16: UInt16: UInt16: UInt16: UInt16: UInt16: UInt16:" , "contents": "NSDecimal(${1:Int32}), _length:${2:UInt32}), _isNegative:${3:UInt32}), _isCompact:${4:UInt32}), _reserved:${5:UInt32}), _mantissa:${6:UInt16}), UInt16:${7:}), UInt16:${8:}), UInt16:${9:}), UInt16:${10:}), UInt16:${11:}), UInt16:${12:}), UInt16:${13:}))" },{ "trigger": "XMLData \t NSData", "contents": "XMLData" },{ "trigger": "sortedArrayUsingFunction) \t func Generator -> Int," , "contents": "sortedArrayUsingFunction(comparator:${1:@conventionc AnyObject}), AnyObject:${2:}), UnsafeMutablePointerVoid:${3:}), context:${4:UnsafeMutablePointerVoid}), hint:${5:NSData?}))" },{ "trigger": "attributesAtIndex) \t func NSAttributedString -> [String" , "contents": "attributesAtIndex(${1:Int}), longestEffectiveRange:${2:NSRangePointer}), inRange:${3:NSRange}))" },{ "trigger": "enumerateIndexesWithOptions) \t func NSIndexSet -> Void)" , "contents": "enumerateIndexesWithOptions(${1:NSEnumerationOptions}), usingBlock:${2:Int}), UnsafeMutablePointerObjCBool:${3:}))" },{ "trigger": "NSBinarySearchingOptions) \t rawValue:" , "contents": "NSBinarySearchingOptions(${1:UInt}))" },{ "trigger": "doubleValue \t Double", "contents": "doubleValue" },{ "trigger": "NSOrderedSet) \t arrayLiteral:" , "contents": "NSOrderedSet(arrayLiteral:${1:AnyObject...}))" },{ "trigger": "NSRecursiveLock \t NSRecursiveLock", "contents": "NSRecursiveLock" },{ "trigger": "NSStringEncodingConversionOptions \t NSStringEncodingConversionOptions", "contents": "NSStringEncodingConversionOptions" },{ "trigger": "lengthOfBytesUsingEncoding) \t func NSString -> Int" , "contents": "lengthOfBytesUsingEncoding(${1:UInt}))" },{ "trigger": "objectByApplyingXSLTString) \t func NSXMLDocument -> AnyObject" , "contents": "objectByApplyingXSLTString(${1:String}), arguments:${2:[String }))" },{ "trigger": "NSCompoundPredicate) \t type: subpredicates:" , "contents": "NSCompoundPredicate(${1:NSCompoundPredicateType}), subpredicates:${2:[NSPredicate]}))" },{ "trigger": "NSSortDescriptor) \t key: ascending:" , "contents": "NSSortDescriptor(${1:String?}), ascending:${2:Bool}))" },{ "trigger": "NSNotificationQueue \t NSNotificationQueue", "contents": "NSNotificationQueue" },{ "trigger": "NSHTTPCookieMaximumAge \t String", "contents": "NSHTTPCookieMaximumAge" },{ "trigger": "enumerateRangesWithOptions) \t func NSIndexSet -> Void)" , "contents": "enumerateRangesWithOptions(${1:NSEnumerationOptions}), usingBlock:${2:NSRange}), UnsafeMutablePointerObjCBool:${3:}))" },{ "trigger": "executing \t Bool", "contents": "executing" },{ "trigger": "substringToIndex) \t func NSString -> String" , "contents": "substringToIndex(${1:Int}))" },{ "trigger": "===) \t func unknown -> Bool" , "contents": "===(${1:AnyClass}), rhs:${2:AnyClass}))" },{ "trigger": "suggestedFilename \t String", "contents": "suggestedFilename" },{ "trigger": "tryLockWhenCondition) \t func NSConditionLock -> Bool" , "contents": "tryLockWhenCondition(${1:Int}))" },{ "trigger": "NSBlockOperation) \t block:" , "contents": "NSBlockOperation(${1: - Void}))" },{ "trigger": "intersectSet) \t func NSMutableOrderedSet -> void" , "contents": "intersectSet(${1:SetNSObject}))" },{ "trigger": "containsValueForKey) \t func NSCoder -> Bool" , "contents": "containsValueForKey(${1:String}))" },{ "trigger": "persistentDomainForName) \t func NSUserDefaults -> [String" , "contents": "persistentDomainForName(${1:String}))" },{ "trigger": "closeFile) \t func NSFileHandle -> void" , "contents": "closeFile(${1:}))" },{ "trigger": "NSData) \t base64EncodedData: options:" , "contents": "NSData(base64EncodedData:${1:NSData}), options:${2:NSDataBase64DecodingOptions}))" },{ "trigger": "rangeOfFragment \t NSRange", "contents": "rangeOfFragment" },{ "trigger": "NSFileGroupOwnerAccountID \t String", "contents": "NSFileGroupOwnerAccountID" },{ "trigger": "tryLock) \t func NSLock -> Bool" , "contents": "tryLock(${1:}))" },{ "trigger": "standardError \t AnyObject", "contents": "standardError" },{ "trigger": "URLQueryAllowedCharacterSet) \t class NSCharacterSet -> NSCharacterSet" , "contents": "URLQueryAllowedCharacterSet(${1:}))" },{ "trigger": "resetBytesInRange) \t func NSMutableData -> void" , "contents": "resetBytesInRange(${1:NSRange}))" },{ "trigger": "NSCharacterSet) \t charactersInString:" , "contents": "NSCharacterSet(charactersInString:${1:String}))" },{ "trigger": "NSZone) \t nilLiteral:" , "contents": "NSZone(${1:}))" },{ "trigger": "qualityOfService \t NSQualityOfService", "contents": "qualityOfService" },{ "trigger": "NSURLErrorZeroByteResource \t Int", "contents": "NSURLErrorZeroByteResource" },{ "trigger": "NSIndexSet) \t index:" , "contents": "NSIndexSet(index:${1:Int}))" },{ "trigger": "containsIndexesInRange) \t func NSIndexSet -> Bool" , "contents": "containsIndexesInRange(${1:NSRange}))" },{ "trigger": "mutableCopy) \t func NSObject -> AnyObject" , "contents": "mutableCopy(${1:}))" },{ "trigger": "suspend) \t func NSURLSessionTask -> void" , "contents": "suspend(${1:}))" },{ "trigger": "setInteger) \t func NSUserDefaults -> void" , "contents": "setInteger(${1:Int}), forKey:${2:String}))" },{ "trigger": "insertChildren) \t func NSXMLDTD -> void" , "contents": "insertChildren(${1:[NSXMLNode]}), atIndex:${2:Int}))" },{ "trigger": "lastObject \t AnyObject", "contents": "lastObject" },{ "trigger": "NSXMLElement) \t XMLString:" , "contents": "NSXMLElement(XMLString:${1:String}))" },{ "trigger": "NSXMLNodeUseDoubleQuotes \t NSXMLNodeOptionRawType", "contents": "NSXMLNodeUseDoubleQuotes" },{ "trigger": "setUserInfoValueProviderForDomain) \t class NSError -> AnyObject?)?)" , "contents": "setUserInfoValueProviderForDomain(${1:String}), provider:${2:NSError}), String:${3:}))" },{ "trigger": "firstWeekday \t Int", "contents": "firstWeekday" },{ "trigger": "externalEntityResolvingPolicy \t NSXMLParserExternalEntityResolvingPolicy", "contents": "externalEntityResolvingPolicy" },{ "trigger": "predicate \t NSPredicate", "contents": "predicate" },{ "trigger": "isDate) \t func NSCalendar -> Bool" , "contents": "isDate(${1:NSDate}), inSameDayAsDate:${2:NSDate}))" },{ "trigger": "NSPersonNameComponentFamilyName \t String", "contents": "NSPersonNameComponentFamilyName" },{ "trigger": "commentWithStringValue) \t class NSXMLNode -> AnyObject" , "contents": "commentWithStringValue(${1:String}))" },{ "trigger": "isSubsetOfSet) \t func NSSet -> Bool" , "contents": "isSubsetOfSet(${1:SetNSObject}))" },{ "trigger": "countForObject) \t func NSCountedSet -> Int" , "contents": "countForObject(${1:AnyObject}))" },{ "trigger": "NSMouseInRect) \t func unknown -> Bool" , "contents": "NSMouseInRect(${1:NSPoint}), _:${2:NSRect}), _:${3:Bool}))" },{ "trigger": "wait) \t func NSCondition -> void" , "contents": "wait(${1:}))" },{ "trigger": "NSAffineTransformStruct \t NSAffineTransformStruct", "contents": "NSAffineTransformStruct" },{ "trigger": "substringWithRange) \t func NSString -> String" , "contents": "substringWithRange(${1:NSRange}))" },{ "trigger": "NSDateFormatter \t NSDateFormatter", "contents": "NSDateFormatter" },{ "trigger": "hasSpaceAvailable \t Bool", "contents": "hasSpaceAvailable" },{ "trigger": "encodeValueOfObjCType) \t func NSCoder -> void" , "contents": "encodeValueOfObjCType(${1:UnsafePointerInt8}), at:${2:UnsafePointerVoid}))" },{ "trigger": "NSCompoundPredicateType \t NSCompoundPredicateType", "contents": "NSCompoundPredicateType" },{ "trigger": "setData) \t func NSMutableData -> void" , "contents": "setData(${1:NSData}))" },{ "trigger": "NSProgressEstimatedTimeRemainingKey \t String", "contents": "NSProgressEstimatedTimeRemainingKey" },{ "trigger": "detachNewThread) \t class NSThread -> Void)" , "contents": "detachNewThread(${1:Void - Void}))" },{ "trigger": "uploadTaskWithRequest) \t func NSURLSession -> Void)" , "contents": "uploadTaskWithRequest(${1:NSURLRequest}), fromFile:${2:NSURL}), completionHandler:${3:NSData?}), NSURLResponse?:${4:}), NSError?:${5:}))" },{ "trigger": "NSPropertyListMutabilityOptions) \t rawValue:" , "contents": "NSPropertyListMutabilityOptions(${1:UInt}))" },{ "trigger": "letterCharacterSet) \t class NSCharacterSet -> NSCharacterSet" , "contents": "letterCharacterSet(${1:}))" },{ "trigger": "NSXMLDocument) \t XMLString: options:" , "contents": "NSXMLDocument(XMLString:${1:String}), options:${2:Int}))" },{ "trigger": "NSLocaleVariantCode \t String", "contents": "NSLocaleVariantCode" },{ "trigger": "NSStreamNetworkServiceTypeVoIP \t String", "contents": "NSStreamNetworkServiceTypeVoIP" },{ "trigger": "NSTimer) \t fireDate: interval: repeats: fire:" , "contents": "NSTimer(${1:NSDate}), interval:${2:NSTimeInterval}), repeats:${3:Bool}), fire:${4:NSTimer - Void }))" },{ "trigger": "authenticationMethod \t String", "contents": "authenticationMethod" },{ "trigger": "NSHTTPCookieValue \t String", "contents": "NSHTTPCookieValue" },{ "trigger": "supportsSecureCoding) \t static NSString -> Bool" , "contents": "supportsSecureCoding(${1:}))" },{ "trigger": "rangeOfCharacterFromSet) \t func NSString -> NSRange" , "contents": "rangeOfCharacterFromSet(${1:NSCharacterSet}), options:${2:NSStringCompareOptions}), range:${3:NSRange}))" },{ "trigger": "HTTPCookieStorage \t NSHTTPCookieStorage", "contents": "HTTPCookieStorage" },{ "trigger": "decimalNumberByMultiplyingByPowerOf10) \t func NSDecimalNumber -> NSDecimalNumber" , "contents": "decimalNumberByMultiplyingByPowerOf10(${1:Int16}), withBehavior:${2:NSDecimalNumberBehaviors?}))" },{ "trigger": "NSString) \t bytesNoCopy: length: encoding: freeWhenDone:" , "contents": "NSString(bytesNoCopy:${1:UnsafeMutablePointerVoid}), length:${2:Int}), encoding:${3:UInt}), freeWhenDone:${4:Bool}))" },{ "trigger": "copyWithZone) \t func NSNotification -> AnyObject" , "contents": "copyWithZone(${1:NSZone}))" },{ "trigger": "NSUnionRange) \t func unknown -> NSRange" , "contents": "NSUnionRange(${1:NSRange}), _:${2:NSRange}))" },{ "trigger": "NSEnergyFormatterUnit \t NSEnergyFormatterUnit", "contents": "NSEnergyFormatterUnit" },{ "trigger": "NSLengthFormatter \t NSLengthFormatter", "contents": "NSLengthFormatter" },{ "trigger": "timeIntervalSinceNow \t NSTimeInterval", "contents": "timeIntervalSinceNow" },{ "trigger": "NSURLErrorCannotFindHost \t Int", "contents": "NSURLErrorCannotFindHost" },{ "trigger": "NSFileSystemSize \t String", "contents": "NSFileSystemSize" },{ "trigger": "NSMutableArray) \t contentsOfURL:" , "contents": "NSMutableArray(contentsOfURL:${1:NSURL}))" },{ "trigger": "canInitWithRequest) \t class NSURLProtocol -> Bool" , "contents": "canInitWithRequest(${1:NSURLRequest}))" },{ "trigger": "standardUserDefaults) \t class NSUserDefaults -> NSUserDefaults" , "contents": "standardUserDefaults(${1:}))" },{ "trigger": "truncateFileAtOffset) \t func NSFileHandle -> void" , "contents": "truncateFileAtOffset(${1:UInt64}))" },{ "trigger": "NSCondition) \t :" , "contents": "NSCondition(${1:}))" },{ "trigger": "pathsForResourcesOfType) \t class NSBundle -> [String]" , "contents": "pathsForResourcesOfType(${1:String?}), inDirectory:${2:String}))" },{ "trigger": "writeJSONObject) \t class NSJSONSerialization -> Int" , "contents": "writeJSONObject(${1:AnyObject}), toStream:${2:NSOutputStream}), options:${3:NSJSONWritingOptions}))" },{ "trigger": "resourceSpecifier \t String", "contents": "resourceSpecifier" },{ "trigger": "NSDateIntervalFormatterStyle \t NSDateIntervalFormatterStyle", "contents": "NSDateIntervalFormatterStyle" },{ "trigger": "regularExpressionCheckingResultWithRanges) \t class NSTextCheckingResult -> NSTextCheckingResult" , "contents": "regularExpressionCheckingResultWithRanges(${1:NSRangePointer}), count:${2:Int}), regularExpression:${3:NSRegularExpression}))" },{ "trigger": "setProperty) \t func NSStream -> Bool" , "contents": "setProperty(${1:AnyObject?}), forKey:${2:String}))" },{ "trigger": "controlCharacterSet) \t class NSCharacterSet -> NSCharacterSet" , "contents": "controlCharacterSet(${1:}))" },{ "trigger": "defaultDecimalNumberHandler) \t class NSDecimalNumberHandler -> NSDecimalNumberHandler{" , "contents": "defaultDecimalNumberHandler(${1:}))" },{ "trigger": "middleName \t String", "contents": "middleName" },{ "trigger": "dataUsingEncoding) \t func NSString -> NSData?" , "contents": "dataUsingEncoding(${1:UInt}), allowLossyConversion:${2:Bool}))" },{ "trigger": "NSEdgeInsets) \t top: left: bottom: right:" , "contents": "NSEdgeInsets(${1:CGFloat}), left:${2:CGFloat}), bottom:${3:CGFloat}), right:${4:CGFloat}))" },{ "trigger": "NSOperatingSystemVersion \t NSOperatingSystemVersion", "contents": "NSOperatingSystemVersion" },{ "trigger": "NSPersonNameComponentMiddleName \t String", "contents": "NSPersonNameComponentMiddleName" },{ "trigger": "NSSet) \t set: copyItems:" , "contents": "NSSet(${1:SetNSObject}), copyItems:${2:Bool}))" },{ "trigger": "hasSuffix) \t func String -> Bool" , "contents": "hasSuffix(${1:String}))" },{ "trigger": "NSFileManagerItemReplacementOptions \t NSFileManagerItemReplacementOptions", "contents": "NSFileManagerItemReplacementOptions" },{ "trigger": "NSHTTPCookieStorage) \t :" , "contents": "NSHTTPCookieStorage(${1:}))" },{ "trigger": "unarchiveTopLevelObjectWithData) \t class NSKeyedUnarchiver -> AnyObject?" , "contents": "unarchiveTopLevelObjectWithData(${1:NSData}))" },{ "trigger": "isDateInWeekend) \t func NSCalendar -> Bool" , "contents": "isDateInWeekend(${1:NSDate}))" },{ "trigger": "NSNull) \t :" , "contents": "NSNull(${1:}))" },{ "trigger": "deleteCharactersInRange) \t func NSMutableString -> void" , "contents": "deleteCharactersInRange(${1:NSRange}))" },{ "trigger": "allowedUnits \t NSCalendarUnit", "contents": "allowedUnits" },{ "trigger": "percentSymbol \t String", "contents": "percentSymbol" },{ "trigger": "NSTask \t NSTask", "contents": "NSTask" },{ "trigger": "abbreviation \t String", "contents": "abbreviation" },{ "trigger": "NSNotification) \t coder:" , "contents": "NSNotification(coder:${1:NSCoder}))" },{ "trigger": "NSEqualRects) \t func unknown -> Bool" , "contents": "NSEqualRects(${1:NSRect}), _:${2:NSRect}))" },{ "trigger": "componentsSeparatedByCharactersInSet) \t func NSString -> [String]" , "contents": "componentsSeparatedByCharactersInSet(${1:NSCharacterSet}))" },{ "trigger": "NSDateInterval) \t start: interval:" , "contents": "NSDateInterval(${1:NSDate}), interval:${2:NSTimeInterval}))" },{ "trigger": "sharedFrameworksPath \t String", "contents": "sharedFrameworksPath" },{ "trigger": "encodeWithCoder) \t func NSURLProtectionSpace -> void" , "contents": "encodeWithCoder(${1:NSCoder}))" },{ "trigger": "interval \t NSTimeInterval", "contents": "interval" },{ "trigger": "NSXMLNodeLoadExternalEntitiesAlways \t NSXMLNodeOptionRawType", "contents": "NSXMLNodeLoadExternalEntitiesAlways" },{ "trigger": "CGPoint) \t :" , "contents": "CGPoint(${1:}))" },{ "trigger": "NSNotificationCoalescing) \t rawValue:" , "contents": "NSNotificationCoalescing(${1:UInt}))" },{ "trigger": "includesActualByteCount \t Bool", "contents": "includesActualByteCount" },{ "trigger": "startLoading) \t func NSURLProtocol -> void" , "contents": "startLoading(${1:}))" },{ "trigger": "removeObjectsInRange) \t func NSMutableArray -> void" , "contents": "removeObjectsInRange(${1:NSRange}))" },{ "trigger": "decomposedStringWithCanonicalMapping \t String", "contents": "decomposedStringWithCanonicalMapping" },{ "trigger": "indexWithOptions) \t func NSIndexSet -> Bool)" , "contents": "indexWithOptions(${1:NSEnumerationOptions}), passingTest:${2:Int}), UnsafeMutablePointerObjCBool:${3:}))" },{ "trigger": "sessionOnly \t Bool", "contents": "sessionOnly" },{ "trigger": "NSPort \t NSPort", "contents": "NSPort" },{ "trigger": "fileSystemRepresentation \t UnsafePointer", "contents": "fileSystemRepresentation" },{ "trigger": "NSURLAuthenticationChallenge) \t coder:" , "contents": "NSURLAuthenticationChallenge(coder:${1:NSCoder}))" },{ "trigger": "copyWithZone) \t func NSIndexPath -> AnyObject" , "contents": "copyWithZone(${1:NSZone}))" },{ "trigger": "NSProgress) \t parent: userInfo:" , "contents": "NSProgress(parent:${1:NSProgress?}), userInfo:${2:[NSObject }))" },{ "trigger": "NSDirectoryEnumerationOptions) \t rawValue:" , "contents": "NSDirectoryEnumerationOptions(${1:UInt}))" },{ "trigger": "unknown) \t unicodeScalarLiteral:" , "contents": "unknown(unicodeScalarLiteral:${1:UnicodeScalar}))" },{ "trigger": "NSURLComponents) \t :" , "contents": "NSURLComponents(${1:}))" },{ "trigger": "lenient \t Bool", "contents": "lenient" },{ "trigger": "variable \t String", "contents": "variable" },{ "trigger": "replacementObjectForKeyedArchiver) \t func NSObject -> AnyObject?" , "contents": "replacementObjectForKeyedArchiver(${1:NSKeyedArchiver}))" },{ "trigger": "charactersToBeSkipped \t NSCharacterSet", "contents": "charactersToBeSkipped" },{ "trigger": "volatileDomainForName) \t func NSUserDefaults -> [String" , "contents": "volatileDomainForName(${1:String}))" },{ "trigger": "removeChildAtIndex) \t func NSXMLElement -> void" , "contents": "removeChildAtIndex(${1:Int}))" },{ "trigger": "NSXMLNodeCompactEmptyElement \t NSXMLNodeOptionRawType", "contents": "NSXMLNodeCompactEmptyElement" },{ "trigger": "comment \t String", "contents": "comment" },{ "trigger": "NSNumberFormatterRoundingMode \t NSNumberFormatterRoundingMode", "contents": "NSNumberFormatterRoundingMode" },{ "trigger": "NSURLErrorBadURL \t Int", "contents": "NSURLErrorBadURL" },{ "trigger": "NSURLAuthenticationMethodNegotiate \t String", "contents": "NSURLAuthenticationMethodNegotiate" },{ "trigger": "rightExpression \t NSExpression", "contents": "rightExpression" },{ "trigger": "indexAtPosition) \t func NSIndexPath -> Int" , "contents": "indexAtPosition(${1:Int}))" },{ "trigger": "NSString) \t string:" , "contents": "NSString(string:${1:String}))" },{ "trigger": "NSStreamSocketSecurityLevelKey \t String", "contents": "NSStreamSocketSecurityLevelKey" },{ "trigger": "_bridgeToObject) \t func Bool -> NSNumber" , "contents": "_bridgeToObject(${1:}))" },{ "trigger": "isExecutableError \t Bool", "contents": "isExecutableError" },{ "trigger": "appendAttributedString) \t func NSMutableAttributedString -> void" , "contents": "appendAttributedString(${1:NSAttributedString}))" },{ "trigger": "defaultDate \t NSDate", "contents": "defaultDate" },{ "trigger": "decodeBytesForKey) \t func NSCoder -> UnsafePointer UInt8 " , "contents": "decodeBytesForKey(${1:String}), returnedLength:${2:UnsafeMutablePointerInt}))" },{ "trigger": "encodeRect) \t func NSCoder -> void" , "contents": "encodeRect(${1:NSRect}))" },{ "trigger": "NSXMLElement) \t name: stringValue:" , "contents": "NSXMLElement(${1:String}), stringValue:${2:String?}))" },{ "trigger": "documentWithRootElement) \t class NSXMLNode -> AnyObject" , "contents": "documentWithRootElement(${1:NSXMLElement}))" },{ "trigger": "NSXMLNodeUseSingleQuotes \t NSXMLNodeOptionRawType", "contents": "NSXMLNodeUseSingleQuotes" },{ "trigger": "NSXMLNodePreserveDTD \t NSXMLNodeOptionRawType", "contents": "NSXMLNodePreserveDTD" },{ "trigger": "descriptionWithLocale) \t func NSDecimalNumber -> String" , "contents": "descriptionWithLocale(${1:AnyObject?}))" },{ "trigger": "options \t NSRegularExpressionOptions", "contents": "options" },{ "trigger": "invalidateAndCancel) \t func NSURLSession -> void" , "contents": "invalidateAndCancel(${1:}))" },{ "trigger": "localizedRecoverySuggestion \t String", "contents": "localizedRecoverySuggestion" },{ "trigger": "NSPOSIXErrorDomain \t String", "contents": "NSPOSIXErrorDomain" },{ "trigger": "lowercaseStringWithLocale) \t func NSString -> String" , "contents": "lowercaseStringWithLocale(${1:NSLocale?}))" },{ "trigger": "NSDate) \t timeIntervalSinceReferenceDate:" , "contents": "NSDate(timeIntervalSinceReferenceDate:${1:NSTimeInterval}))" },{ "trigger": "availableLocaleIdentifiers) \t class NSLocale -> [String]" , "contents": "availableLocaleIdentifiers(${1:}))" },{ "trigger": "NSURLSessionTask \t NSURLSessionTask", "contents": "NSURLSessionTask" },{ "trigger": "state \t NSURLSessionTaskState", "contents": "state" },{ "trigger": "formIntersectionWithCharacterSet) \t func NSMutableCharacterSet -> void" , "contents": "formIntersectionWithCharacterSet(${1:NSCharacterSet}))" },{ "trigger": "NSTimeZone) \t forSecondsFromGMT:" , "contents": "NSTimeZone(forSecondsFromGMT:${1:Int}))" },{ "trigger": "NSSearchPathDirectory \t NSSearchPathDirectory", "contents": "NSSearchPathDirectory" },{ "trigger": "attribute) \t func NSAttributedString -> AnyObject?" , "contents": "attribute(${1:String}), atIndex:${2:Int}), effectiveRange:${3:NSRangePointer}))" },{ "trigger": "isDateInYesterday) \t func NSCalendar -> Bool" , "contents": "isDateInYesterday(${1:NSDate}))" },{ "trigger": "isEqualToHost) \t func NSHost -> Bool" , "contents": "isEqualToHost(${1:NSHost}))" },{ "trigger": "rotateByDegrees) \t func NSAffineTransform -> void" , "contents": "rotateByDegrees(${1:CGFloat}))" },{ "trigger": "NSCachedURLResponse) \t response: data:" , "contents": "NSCachedURLResponse(${1:NSURLResponse}), data:${2:NSData}))" },{ "trigger": "hasMemberInPlane) \t func NSCharacterSet -> Bool" , "contents": "hasMemberInPlane(${1:UInt8}))" },{ "trigger": "supportsSecureCoding) \t static NSURLQueryItem -> Bool" , "contents": "supportsSecureCoding(${1:}))" },{ "trigger": "waitForDataInBackgroundAndNotify) \t func NSFileHandle -> void" , "contents": "waitForDataInBackgroundAndNotify(${1:}))" },{ "trigger": "NSFileHandleReadCompletionNotification \t String", "contents": "NSFileHandleReadCompletionNotification" },{ "trigger": "NSURLSessionDownloadTaskResumeData \t String", "contents": "NSURLSessionDownloadTaskResumeData" },{ "trigger": "setChildren) \t func NSXMLDTD -> void" , "contents": "setChildren(${1:[NSXMLNode]?}))" },{ "trigger": "NSXMLDTD) \t contentsOfURL: options:" , "contents": "NSXMLDTD(contentsOfURL:${1:NSURL}), options:${2:Int}))" },{ "trigger": "copyWithZone) \t func NSURLCredential -> AnyObject" , "contents": "copyWithZone(${1:NSZone}))" },{ "trigger": "rangeOfUser \t NSRange", "contents": "rangeOfUser" },{ "trigger": "NSPropertyListMutabilityOptions \t NSPropertyListMutabilityOptions", "contents": "NSPropertyListMutabilityOptions" },{ "trigger": "replaceBytesInRange) \t func NSMutableData -> void" , "contents": "replaceBytesInRange(${1:NSRange}), withBytes:${2:UnsafePointerVoid}))" },{ "trigger": "debugDescription \t String", "contents": "debugDescription" },{ "trigger": "NSURLErrorKey \t String", "contents": "NSURLErrorKey" },{ "trigger": "size \t CGSize", "contents": "size" },{ "trigger": "processIdentifier \t Int", "contents": "processIdentifier" },{ "trigger": "evaluateWithObject) \t func NSPredicate -> Bool" , "contents": "evaluateWithObject(${1:AnyObject?}), substitutionVariables:${2:[String }))" },{ "trigger": "destinationOfSymbolicLinkAtPath) \t func NSFileManager -> String" , "contents": "destinationOfSymbolicLinkAtPath(${1:String}))" },{ "trigger": "objectsPassingTest) \t func NSSet -> Bool)" , "contents": "objectsPassingTest(${1:AnyObject}), UnsafeMutablePointerObjCBool:${2:}))" },{ "trigger": "URLByDeletingPathExtension \t NSURL", "contents": "URLByDeletingPathExtension" },{ "trigger": "encodeWithCoder) \t func NSSortDescriptor -> void" , "contents": "encodeWithCoder(${1:NSCoder}))" },{ "trigger": "NSURLErrorUnknown \t Int", "contents": "NSURLErrorUnknown" },{ "trigger": "NSURLErrorUserAuthenticationRequired \t Int", "contents": "NSURLErrorUserAuthenticationRequired" },{ "trigger": "HTTPShouldUsePipelining \t Bool", "contents": "HTTPShouldUsePipelining" },{ "trigger": "NSUserDefaults) \t :" , "contents": "NSUserDefaults(${1:}))" },{ "trigger": "NSCalendarOptions) \t rawValue:" , "contents": "NSCalendarOptions(${1:UInt}))" },{ "trigger": "createDirectoryAtURL) \t func NSFileManager -> void" , "contents": "createDirectoryAtURL(${1:NSURL}), withIntermediateDirectories:${2:Bool}), attributes:${3:[String }))" },{ "trigger": "countOfIndexesInRange) \t func NSIndexSet -> Int" , "contents": "countOfIndexesInRange(${1:NSRange}))" },{ "trigger": "NSXMLDocument) \t data: options:" , "contents": "NSXMLDocument(${1:NSData}), options:${2:Int}))" },{ "trigger": "currentMode \t String", "contents": "currentMode" },{ "trigger": "dateByAddingComponents) \t func NSCalendar -> NSDate?" , "contents": "dateByAddingComponents(${1:NSDateComponents}), toDate:${2:NSDate}), options:${3:NSCalendarOptions}))" },{ "trigger": "NSDateComponentsFormatterUnitsStyle \t NSDateComponentsFormatterUnitsStyle", "contents": "NSDateComponentsFormatterUnitsStyle" },{ "trigger": "XMLString \t String", "contents": "XMLString" },{ "trigger": "decimalNumberByMultiplyingBy) \t func NSDecimalNumber -> NSDecimalNumber" , "contents": "decimalNumberByMultiplyingBy(${1:NSDecimalNumber}), withBehavior:${2:NSDecimalNumberBehaviors?}))" },{ "trigger": "childAtIndex) \t func NSXMLNode -> NSXMLNode?" , "contents": "childAtIndex(${1:Int}))" },{ "trigger": "localNameForName) \t class NSXMLNode -> String" , "contents": "localNameForName(${1:String}))" },{ "trigger": "indexesOfObjectsAtIndexes) \t func Generator -> Bool)" , "contents": "indexesOfObjectsAtIndexes(${1:NSIndexSet}), options:${2:NSEnumerationOptions}), passingTest:${3:AnyObject}), Int:${4:}), UnsafeMutablePointerObjCBool:${5:}))" },{ "trigger": "encodeWithCoder) \t func NSURLResponse -> void" , "contents": "encodeWithCoder(${1:NSCoder}))" },{ "trigger": "supportsSecureCoding) \t func NSAttributedString -> Bool" , "contents": "supportsSecureCoding(${1:}))" },{ "trigger": "NSURLRelationship \t NSURLRelationship", "contents": "NSURLRelationship" },{ "trigger": "NSFileHandle) \t coder:" , "contents": "NSFileHandle(${1:NSCoder}))" },{ "trigger": "NSSocketPort \t NSSocketPort", "contents": "NSSocketPort" },{ "trigger": "lastPathComponent \t String", "contents": "lastPathComponent" },{ "trigger": "changeCurrentDirectoryPath) \t func NSFileManager -> Bool" , "contents": "changeCurrentDirectoryPath(${1:String}))" },{ "trigger": "lineNumber \t Int", "contents": "lineNumber" },{ "trigger": "NSURLErrorUserCancelledAuthentication \t Int", "contents": "NSURLErrorUserCancelledAuthentication" },{ "trigger": "attributesOfItemAtPath) \t func NSFileManager -> [String" , "contents": "attributesOfItemAtPath(${1:String}))" },{ "trigger": "attributeForName) \t func NSXMLElement -> NSXMLNode?" , "contents": "attributeForName(${1:String}))" },{ "trigger": "Generator) \t contentsOfURL:" , "contents": "Generator(contentsOfURL:${1:NSURL}))" },{ "trigger": "nilSymbol \t String", "contents": "nilSymbol" },{ "trigger": "roundingBehavior \t NSDecimalNumberHandler", "contents": "roundingBehavior" },{ "trigger": "escapedTemplateForString) \t class NSRegularExpression -> String" , "contents": "escapedTemplateForString(${1:String}))" },{ "trigger": "scanHexLongLong) \t func NSScanner -> UInt64?" , "contents": "scanHexLongLong(${1:}))" },{ "trigger": "writeToURL) \t func NSString -> void" , "contents": "writeToURL(${1:NSURL}), atomically:${2:Bool}), encoding:${3:UInt}))" },{ "trigger": "sleepUntilDate) \t class NSThread -> void" , "contents": "sleepUntilDate(${1:NSDate}))" },{ "trigger": "NSCompoundPredicate) \t andPredicateWithSubpredicates:" , "contents": "NSCompoundPredicate(andPredicateWithSubpredicates:${1:[NSPredicate]}))" },{ "trigger": "NSFileSystemFreeSize \t String", "contents": "NSFileSystemFreeSize" },{ "trigger": "percentEncodedFragment \t String", "contents": "percentEncodedFragment" },{ "trigger": "NSURLErrorCannotConnectToHost \t Int", "contents": "NSURLErrorCannotConnectToHost" },{ "trigger": "encodeWithCoder) \t func NSURLRequest -> void" , "contents": "encodeWithCoder(${1:NSCoder}))" },{ "trigger": "decodeBoolForKey) \t func NSCoder -> Bool" , "contents": "decodeBoolForKey(${1:String}))" },{ "trigger": "resume) \t func NSURLSessionTask -> void" , "contents": "resume(${1:}))" },{ "trigger": "URLForKey) \t func NSUserDefaults -> NSURL?" , "contents": "URLForKey(${1:String}))" },{ "trigger": "addSuiteNamed) \t func NSUserDefaults -> void" , "contents": "addSuiteNamed(${1:String}))" },{ "trigger": "filteredOrderedSetUsingPredicate) \t func NSOrderedSet -> NSOrderedSet" , "contents": "filteredOrderedSetUsingPredicate(${1:NSPredicate}))" },{ "trigger": "bridge) \t func Set -> NSSet" , "contents": "bridge(${1:}))" },{ "trigger": "elementWithName) \t class NSXMLNode -> AnyObject" , "contents": "elementWithName(${1:String}))" },{ "trigger": "containsIndex) \t func NSIndexSet -> Bool" , "contents": "containsIndex(${1:Int}))" },{ "trigger": "downloadTaskWithURL) \t func NSURLSession -> Void)" , "contents": "downloadTaskWithURL(${1:NSURL}), completionHandler:${2:NSURL?}), NSURLResponse?:${3:}), NSError?:${4:}))" },{ "trigger": "copyWithZone) \t func NSURLRequest -> AnyObject" , "contents": "copyWithZone(${1:NSZone}))" },{ "trigger": "mainBundle) \t class NSBundle -> NSBundle" , "contents": "mainBundle(${1:}))" },{ "trigger": "isEqualToSet) \t func NSSet -> Bool" , "contents": "isEqualToSet(${1:SetNSObject}))" },{ "trigger": "cancelled \t Bool", "contents": "cancelled" },{ "trigger": "NSString) \t format: locale: arguments:" , "contents": "NSString(${1:String}), locale:${2:AnyObject?}), arguments:${3:CVaListPointer}))" },{ "trigger": "documentContentKind \t NSXMLDocumentContentKind", "contents": "documentContentKind" },{ "trigger": "NSURLErrorFailingURLPeerTrustErrorKey \t String", "contents": "NSURLErrorFailingURLPeerTrustErrorKey" },{ "trigger": "NSLocale \t NSLocale", "contents": "NSLocale" },{ "trigger": "descriptionInStringsFileFormat \t String", "contents": "descriptionInStringsFileFormat" },{ "trigger": "numberFormatter \t NSNumberFormatter", "contents": "numberFormatter" },{ "trigger": "sendPort \t NSPort", "contents": "sendPort" },{ "trigger": "NSLocale) \t localeIdentifier:" , "contents": "NSLocale(localeIdentifier:${1:String}))" },{ "trigger": "NSStream) \t :" , "contents": "NSStream(${1:}))" },{ "trigger": "cancel) \t func NSURLSessionTask -> void" , "contents": "cancel(${1:}))" },{ "trigger": "locale \t NSLocale", "contents": "locale" },{ "trigger": "cancel) \t func NSProgress -> void" , "contents": "cancel(${1:}))" },{ "trigger": "CGFloat \t CGFloat", "contents": "CGFloat" },{ "trigger": "numberFromString) \t func NSNumberFormatter -> NSNumber?" , "contents": "numberFromString(${1:String}))" },{ "trigger": "NSDateInterval \t NSDateInterval", "contents": "NSDateInterval" },{ "trigger": "terminate) \t func NSTask -> void" , "contents": "terminate(${1:}))" },{ "trigger": "setFloat) \t func NSUserDefaults -> void" , "contents": "setFloat(${1:Float}), forKey:${2:String}))" },{ "trigger": "sharedFrameworksURL \t NSURL", "contents": "sharedFrameworksURL" },{ "trigger": "NSURLResponse \t NSURLResponse", "contents": "NSURLResponse" },{ "trigger": "maximumSignificantDigits \t Int", "contents": "maximumSignificantDigits" },{ "trigger": "enumerateMatchesInString) \t func NSRegularExpression -> Void)" , "contents": "enumerateMatchesInString(${1:String}), options:${2:NSMatchingOptions}), range:${3:NSRange}), usingBlock:${4:NSTextCheckingResult?}), NSMatchingFlags:${5:}), UnsafeMutablePointerObjCBool:${6:}))" },{ "trigger": "statusCode \t Int", "contents": "statusCode" },{ "trigger": "NSInsetRect) \t func unknown -> NSRect" , "contents": "NSInsetRect(${1:NSRect}), _:${2:CGFloat}), _:${3:CGFloat}))" },{ "trigger": "replacementClassForClass) \t class NSXMLDocument -> AnyClass" , "contents": "replacementClassForClass(${1:AnyClass}))" },{ "trigger": "host \t String", "contents": "host" },{ "trigger": "NSStreamSocketSecurityLevelNegotiatedSSL \t String", "contents": "NSStreamSocketSecurityLevelNegotiatedSSL" },{ "trigger": "NSPointInRect) \t func unknown -> Bool" , "contents": "NSPointInRect(${1:NSPoint}), _:${2:NSRect}))" },{ "trigger": "NSXMLElement) \t kind: options:" , "contents": "NSXMLElement(${1:NSXMLNodeKind}), options:${2:Int}))" },{ "trigger": "isEqual) \t func NSObject -> Bool" , "contents": "isEqual(${1:AnyObject?}))" },{ "trigger": "sharedSupportPath \t String", "contents": "sharedSupportPath" },{ "trigger": "NSStreamEvent) \t rawValue:" , "contents": "NSStreamEvent(${1:UInt}))" },{ "trigger": "captureStreams) \t func NSURLSessionStreamTask -> void" , "contents": "captureStreams(${1:}))" },{ "trigger": "compare) \t func NSNumber -> NSComparisonResult" , "contents": "compare(${1:NSNumber}))" },{ "trigger": "NSUUID \t NSUUID", "contents": "NSUUID" },{ "trigger": "completePathIntoString) \t func NSString -> Int" , "contents": "completePathIntoString(inout:${1:NSString?}), caseSensitive:${2:Bool}), inout:${3:[NSString]}), filterTypes:${4:[String]?}))" },{ "trigger": "Generator) \t contentsOfFile:" , "contents": "Generator(contentsOfFile:${1:String}))" },{ "trigger": "removeObjectIdenticalTo) \t func NSMutableArray -> void" , "contents": "removeObjectIdenticalTo(${1:AnyObject}))" },{ "trigger": "setValue) \t func NSDateComponents -> void" , "contents": "setValue(${1:Int}), forComponent:${2:NSCalendarUnit}))" },{ "trigger": "NSLocaleCountryCode \t String", "contents": "NSLocaleCountryCode" },{ "trigger": "lowercaseLetterCharacterSet) \t class NSCharacterSet -> NSCharacterSet" , "contents": "lowercaseLetterCharacterSet(${1:}))" },{ "trigger": "removeAllObjects) \t func NSMutableSet -> void" , "contents": "removeAllObjects(${1:}))" },{ "trigger": "mutableCopyWithZone) \t func NSSet -> AnyObject" , "contents": "mutableCopyWithZone(${1:NSZone}))" },{ "trigger": "setByAddingObjectsFromArray) \t func NSSet -> Set NSObject " , "contents": "setByAddingObjectsFromArray(${1:[AnyObject]}))" },{ "trigger": "writeToFile) \t func NSString -> void" , "contents": "writeToFile(${1:String}), atomically:${2:Bool}), encoding:${3:UInt}))" },{ "trigger": "NSURLErrorNetworkConnectionLost \t Int", "contents": "NSURLErrorNetworkConnectionLost" },{ "trigger": "encodeWithCoder) \t func NSUUID -> void" , "contents": "encodeWithCoder(${1:NSCoder}))" },{ "trigger": "NSXMLParserError \t NSXMLParserError", "contents": "NSXMLParserError" },{ "trigger": "objectIsForcedForKey) \t func NSUserDefaults -> Bool" , "contents": "objectIsForcedForKey(${1:String}), inDomain:${2:String}))" },{ "trigger": "NSNumber) \t unsignedInteger:" , "contents": "NSNumber(unsignedInteger:${1:UInt}))" },{ "trigger": "NSLocalizedRecoveryOptionsErrorKey \t String", "contents": "NSLocalizedRecoveryOptionsErrorKey" },{ "trigger": "scanLongLong) \t func NSScanner -> Bool" , "contents": "scanLongLong(${1:UnsafeMutablePointerInt64}))" },{ "trigger": "NSMutableSet) \t :" , "contents": "NSMutableSet(${1:}))" },{ "trigger": "recoveryAttempter \t AnyObject", "contents": "recoveryAttempter" },{ "trigger": "NSOperationQueueDefaultMaxConcurrentOperationCount \t Int", "contents": "NSOperationQueueDefaultMaxConcurrentOperationCount" },{ "trigger": "paragraphRangeForRange) \t func NSString -> NSRange" , "contents": "paragraphRangeForRange(${1:NSRange}))" },{ "trigger": "NSCalendarOptions \t NSCalendarOptions", "contents": "NSCalendarOptions" },{ "trigger": "NSIntersectionRect) \t func unknown -> NSRect" , "contents": "NSIntersectionRect(${1:NSRect}), _:${2:NSRect}))" },{ "trigger": "absolutePath \t Bool", "contents": "absolutePath" },{ "trigger": "invalidate) \t func NSPort -> void" , "contents": "invalidate(${1:}))" },{ "trigger": "NSXMLNodePreserveNamespaceOrder \t NSXMLNodeOptionRawType", "contents": "NSXMLNodePreserveNamespaceOrder" },{ "trigger": "CGRect) \t origin: size:" , "contents": "CGRect(${1:CGPoint}), size:${2:CGSize}))" },{ "trigger": "NSFileHandle) \t forWritingToURL:" , "contents": "NSFileHandle(forWritingToURL:${1:NSURL}))" },{ "trigger": "perMillSymbol \t String", "contents": "perMillSymbol" },{ "trigger": "NSOperation) \t :" , "contents": "NSOperation(${1:}))" },{ "trigger": "removeObjectsAtIndexes) \t func NSMutableOrderedSet -> void" , "contents": "removeObjectsAtIndexes(${1:NSIndexSet}))" },{ "trigger": "removeIndexes) \t func NSMutableIndexSet -> void" , "contents": "removeIndexes(${1:NSIndexSet}))" },{ "trigger": "==) \t func unknown -> Bool" , "contents": "==(${1:CGRect}), rhs:${2:CGRect}))" },{ "trigger": "CGRect) \t :" , "contents": "CGRect(${1:}))" },{ "trigger": "countOfBytesSent \t Int", "contents": "countOfBytesSent" },{ "trigger": "rangeOfQuery \t NSRange", "contents": "rangeOfQuery" },{ "trigger": "NSMatchingFlags) \t rawValue:" , "contents": "NSMatchingFlags(${1:UInt}))" },{ "trigger": "NSDate) \t timeIntervalSinceNow:" , "contents": "NSDate(timeIntervalSinceNow:${1:NSTimeInterval}))" },{ "trigger": "developmentLocalization \t String", "contents": "developmentLocalization" },{ "trigger": "date \t NSDate", "contents": "date" },{ "trigger": "decimalNumberByAdding) \t func NSDecimalNumber -> NSDecimalNumber" , "contents": "decimalNumberByAdding(${1:NSDecimalNumber}))" },{ "trigger": "-) \t func unknown -> CGFloat" , "contents": "-(${1:CGFloat}), rhs:${2:CGFloat}))" },{ "trigger": "NSLengthFormatterUnit \t NSLengthFormatterUnit", "contents": "NSLengthFormatterUnit" },{ "trigger": "stopLoading) \t func NSURLProtocol -> void" , "contents": "stopLoading(${1:}))" },{ "trigger": "allowedExternalEntityURLs \t Set", "contents": "allowedExternalEntityURLs" },{ "trigger": "NSFilePathErrorKey \t String", "contents": "NSFilePathErrorKey" },{ "trigger": "data \t NSData", "contents": "data" },{ "trigger": "NSDateIntervalFormatter) \t :" , "contents": "NSDateIntervalFormatter(${1:}))" },{ "trigger": "setVolatileDomain) \t func NSUserDefaults -> void" , "contents": "setVolatileDomain(${1:[String }), forName:${2:String}))" },{ "trigger": "supportsSecureCoding) \t static NSIndexSet -> Bool" , "contents": "supportsSecureCoding(${1:}))" },{ "trigger": "CGPoint) \t x: y:" , "contents": "CGPoint(${1:CGFloat}), y:${2:CGFloat}))" },{ "trigger": "evictsObjectsWithDiscardedContent \t Bool", "contents": "evictsObjectsWithDiscardedContent" },{ "trigger": "encodeWithCoder) \t func NSDateComponents -> void" , "contents": "encodeWithCoder(${1:NSCoder}))" },{ "trigger": "sizeValue \t NSSize", "contents": "sizeValue" },{ "trigger": "bridge) \t func NSSet -> Set NSObject " , "contents": "bridge(${1:}))" },{ "trigger": "unlock) \t func NSRecursiveLock -> void" , "contents": "unlock(${1:}))" },{ "trigger": "NSCalendar) \t coder:" , "contents": "NSCalendar(coder:${1:NSCoder}))" },{ "trigger": "NSDateFormatterStyle \t NSDateFormatterStyle", "contents": "NSDateFormatterStyle" },{ "trigger": "sortUsingDescriptors) \t func NSMutableOrderedSet -> void" , "contents": "sortUsingDescriptors(${1:[NSSortDescriptor]}))" },{ "trigger": "NSMinY) \t func unknown -> CGFloat" , "contents": "NSMinY(${1:NSRect}))" },{ "trigger": "NSMassFormatter \t NSMassFormatter", "contents": "NSMassFormatter" },{ "trigger": "nextDateAfterDate) \t func NSCalendar -> NSDate?" , "contents": "nextDateAfterDate(${1:NSDate}), matchingUnit:${2:NSCalendarUnit}), value:${3:Int}), options:${4:NSCalendarOptions}))" },{ "trigger": "addChild) \t func NSProgress -> void" , "contents": "addChild(${1:NSProgress}), withPendingUnitCount:${2:Int64}))" },{ "trigger": "reversedOrderedSet \t NSOrderedSet", "contents": "reversedOrderedSet" },{ "trigger": "waitForDataInBackgroundAndNotifyForModes) \t func NSFileHandle -> void" , "contents": "waitForDataInBackgroundAndNotifyForModes(${1:[String]?}))" },{ "trigger": "NSDecimalNumberOverflowException \t String", "contents": "NSDecimalNumberOverflowException" },{ "trigger": "NSURLErrorServerCertificateUntrusted \t Int", "contents": "NSURLErrorServerCertificateUntrusted" },{ "trigger": "date) \t func NSCalendar -> Bool" , "contents": "date(${1:NSDate}), matchesComponents:${2:NSDateComponents}))" },{ "trigger": "`self`) \t func NSObject -> Self" , "contents": "`self`(${1:}))" },{ "trigger": "NSLocaleDecimalSeparator \t String", "contents": "NSLocaleDecimalSeparator" },{ "trigger": "copyWithZone) \t func NSLocale -> AnyObject" , "contents": "copyWithZone(${1:NSZone}))" },{ "trigger": "enumerateObjectsAtIndexes) \t func NSOrderedSet -> Void)" , "contents": "enumerateObjectsAtIndexes(${1:NSIndexSet}), options:${2:NSEnumerationOptions}), usingBlock:${3:AnyObject}), Int:${4:}), UnsafeMutablePointerObjCBool:${5:}))" },{ "trigger": "NSOrderedSet) \t orderedSet: range: copyItems:" , "contents": "NSOrderedSet(orderedSet:${1:NSOrderedSet}), range:${2:NSRange}), copyItems:${3:Bool}))" },{ "trigger": "NSPersonNameComponentDelimiter \t String", "contents": "NSPersonNameComponentDelimiter" },{ "trigger": "NSMutableArray \t NSMutableArray", "contents": "NSMutableArray" },{ "trigger": "writeToFile) \t func Generator -> Bool" , "contents": "writeToFile(${1:String}), atomically:${2:Bool}))" },{ "trigger": "_forceBridgeFromObject) \t static Bool -> void" , "contents": "_forceBridgeFromObject(${1:NSNumber}), inout:${2:Bool?}))" },{ "trigger": "NSDecimalNoScale \t Int", "contents": "NSDecimalNoScale" },{ "trigger": "removeObject) \t func NSMutableArray -> void" , "contents": "removeObject(${1:AnyObject}))" },{ "trigger": "classForKeyedUnarchiver) \t class NSObject -> AnyClass" , "contents": "classForKeyedUnarchiver(${1:}))" },{ "trigger": "y \t CGFloat", "contents": "y" },{ "trigger": "enumerateSubstringsInRange) \t func NSString -> Void)" , "contents": "enumerateSubstringsInRange(${1:NSRange}), options:${2:NSStringEnumerationOptions}), usingBlock:${3:String?}), NSRange:${4:}), NSRange:${5:}), UnsafeMutablePointerObjCBool:${6:}))" },{ "trigger": "regularExpression \t NSRegularExpression", "contents": "regularExpression" },{ "trigger": "NSURLSessionAuthChallengeDisposition \t NSURLSessionAuthChallengeDisposition", "contents": "NSURLSessionAuthChallengeDisposition" },{ "trigger": "mutableCopyWithZone) \t func NSCharacterSet -> AnyObject" , "contents": "mutableCopyWithZone(${1:NSZone}))" },{ "trigger": "NSFileBusy \t String", "contents": "NSFileBusy" },{ "trigger": "NSURLSessionTransferSizeUnknown \t Int", "contents": "NSURLSessionTransferSizeUnknown" },{ "trigger": "index \t Int", "contents": "index" },{ "trigger": "getFileSystemRepresentation) \t func NSURL -> Bool" , "contents": "getFileSystemRepresentation(${1:UnsafeMutablePointerInt8}), maxLength:${2:Int}))" },{ "trigger": "attributedStringForNotANumber \t NSAttributedString", "contents": "attributedStringForNotANumber" },{ "trigger": "newlineCharacterSet) \t class NSCharacterSet -> NSCharacterSet" , "contents": "newlineCharacterSet(${1:}))" },{ "trigger": "expressionValueWithObject) \t func NSExpression -> AnyObject" , "contents": "expressionValueWithObject(${1:AnyObject?}), context:${2:NSMutableDictionary?}))" },{ "trigger": "queuePriority \t NSOperationQueuePriority", "contents": "queuePriority" },{ "trigger": "supportsSecureCoding) \t static NSAffineTransform -> Bool" , "contents": "supportsSecureCoding(${1:}))" },{ "trigger": "hostName \t String", "contents": "hostName" },{ "trigger": "compare) \t func String -> NSComparisonResult" , "contents": "compare(${1:String}), options:${2:NSStringCompareOptions = []}), range:${3:NSRange? = nil}), locale:${4:NSLocale? = nil}))" },{ "trigger": "NSData) \t bytes: length:" , "contents": "NSData(${1:UnsafePointerVoid}), length:${2:Int}))" },{ "trigger": "abbreviationDictionary) \t class NSTimeZone -> [String" , "contents": "abbreviationDictionary(${1:}))" },{ "trigger": "NSUUID) \t :" , "contents": "NSUUID(${1:}))" },{ "trigger": "unsignedCharValue \t UInt", "contents": "unsignedCharValue" },{ "trigger": "NSXMLDocument \t NSXMLDocument", "contents": "NSXMLDocument" },{ "trigger": "NSFileSystemFreeNodes \t String", "contents": "NSFileSystemFreeNodes" },{ "trigger": "indexInRange) \t func NSIndexSet -> Bool)" , "contents": "indexInRange(${1:NSRange}), options:${2:NSEnumerationOptions}), passingTest:${3:Int}), UnsafeMutablePointerObjCBool:${4:}))" },{ "trigger": "contentsAtPath) \t func NSFileManager -> NSData?" , "contents": "contentsAtPath(${1:String}))" },{ "trigger": "NSUserDefaults) \t suiteName:" , "contents": "NSUserDefaults(suiteName:${1:String?}))" },{ "trigger": "NSOffsetRect) \t func unknown -> NSRect" , "contents": "NSOffsetRect(${1:NSRect}), _:${2:CGFloat}), _:${3:CGFloat}))" },{ "trigger": "scheduledTimer) \t class NSTimer -> Void)" , "contents": "scheduledTimer(${1:NSTimeInterval}), repeats:${2:Bool}), fire:${3:NSTimer - Void}))" },{ "trigger": "dataTaskWithRequest) \t func NSURLSession -> NSURLSessionDataTask" , "contents": "dataTaskWithRequest(${1:NSURLRequest}))" },{ "trigger": "NSURLCredentialStorageChangedNotification \t String", "contents": "NSURLCredentialStorageChangedNotification" },{ "trigger": "encodeSize) \t func NSCoder -> void" , "contents": "encodeSize(${1:NSSize}))" },{ "trigger": "hashValue \t Int", "contents": "hashValue" },{ "trigger": "enumerateKeysAndObjectsUsingBlock) \t func Generator -> Void)" , "contents": "enumerateKeysAndObjectsUsingBlock(${1:NSObject}), AnyObject:${2:}), UnsafeMutablePointerObjCBool:${3:}))" },{ "trigger": "replaceMatchesInString) \t func NSRegularExpression -> Int" , "contents": "replaceMatchesInString(${1:NSMutableString}), options:${2:NSMatchingOptions}), range:${3:NSRange}), withTemplate:${4:String}))" },{ "trigger": "addObjectsFromArray) \t func NSMutableOrderedSet -> void" , "contents": "addObjectsFromArray(${1:[AnyObject]}))" },{ "trigger": "NSFileTypeCharacterSpecial \t String", "contents": "NSFileTypeCharacterSpecial" },{ "trigger": "NSString) \t charactersNoCopy: length: freeWhenDone:" , "contents": "NSString(charactersNoCopy:${1:UnsafeMutablePointerunichar}), length:${2:Int}), freeWhenDone:${3:Bool}))" },{ "trigger": "encodeDataObject) \t func NSCoder -> void" , "contents": "encodeDataObject(${1:NSData}))" },{ "trigger": "NSDecimalNumberDivideByZeroException \t String", "contents": "NSDecimalNumberDivideByZeroException" },{ "trigger": "cachedResponse \t NSCachedURLResponse", "contents": "cachedResponse" },{ "trigger": "URLForResource) \t func NSBundle -> NSURL?" , "contents": "URLForResource(${1:String?}), withExtension:${2:String?}))" },{ "trigger": "subpathsAtPath) \t func NSFileManager -> [String]?" , "contents": "subpathsAtPath(${1:String}))" },{ "trigger": "NSURLErrorInternationalRoamingOff \t Int", "contents": "NSURLErrorInternationalRoamingOff" },{ "trigger": "NSDecimalNumber) \t booleanLiteral:" , "contents": "NSDecimalNumber(booleanLiteral:${1:Bool}))" },{ "trigger": "NSURLCache) \t memoryCapacity: diskCapacity: diskPath:" , "contents": "NSURLCache(${1:Int}), diskCapacity:${2:Int}), diskPath:${3:String?}))" },{ "trigger": "NSStreamSOCKSProxyConfigurationKey \t String", "contents": "NSStreamSOCKSProxyConfigurationKey" },{ "trigger": "nameSuffix \t String", "contents": "nameSuffix" },{ "trigger": "daylightSavingTimeOffsetForDate) \t func NSTimeZone -> NSTimeInterval" , "contents": "daylightSavingTimeOffsetForDate(${1:NSDate}))" },{ "trigger": "classFallbacksForKeyedArchiver) \t class NSObject -> [String]" , "contents": "classFallbacksForKeyedArchiver(${1:}))" },{ "trigger": "commentURL \t NSURL", "contents": "commentURL" },{ "trigger": "NSNonLossyASCIIStringEncoding \t UInt", "contents": "NSNonLossyASCIIStringEncoding" },{ "trigger": "NSXMLDTDNode) \t XMLString:" , "contents": "NSXMLDTDNode(XMLString:${1:String}))" },{ "trigger": "URLRelativeToURL) \t func NSURLComponents -> NSURL?" , "contents": "URLRelativeToURL(${1:NSURL?}))" },{ "trigger": "NSValue) \t edgeInsets:" , "contents": "NSValue(edgeInsets:${1:NSEdgeInsets}))" },{ "trigger": "objectValue) \t func NSNumberFormatter -> AnyObject?" , "contents": "objectValue(${1:String}), inout:${2:NSRange}))" },{ "trigger": "reverseObjectEnumerator) \t func NSOrderedSet -> NSEnumerator" , "contents": "reverseObjectEnumerator(${1:}))" },{ "trigger": "Generator) \t dictionaryLiteral: AnyObject...:" , "contents": "Generator(dictionaryLiteral:${1:NSObject}), AnyObject...:${2:}))" },{ "trigger": "NSDirectoryEnumerationOptions \t NSDirectoryEnumerationOptions", "contents": "NSDirectoryEnumerationOptions" },{ "trigger": "setBool) \t func NSUserDefaults -> void" , "contents": "setBool(${1:Bool}), forKey:${2:String}))" },{ "trigger": "caseSensitive \t Bool", "contents": "caseSensitive" },{ "trigger": "currentDiskUsage \t Int", "contents": "currentDiskUsage" },{ "trigger": "postNotification) \t func NSNotificationCenter -> void" , "contents": "postNotification(${1:NSNotification}))" },{ "trigger": "readToEndOfFileInBackgroundAndNotifyForModes) \t func NSFileHandle -> void" , "contents": "readToEndOfFileInBackgroundAndNotifyForModes(${1:[String]?}))" },{ "trigger": "NSScanner \t NSScanner", "contents": "NSScanner" },{ "trigger": "load) \t func NSBundle -> Bool" , "contents": "load(${1:}))" },{ "trigger": "unarchiveObjectWithData) \t class NSKeyedUnarchiver -> AnyObject?" , "contents": "unarchiveObjectWithData(${1:NSData}))" },{ "trigger": "enumerateIndexesUsingBlock) \t func NSIndexSet -> Void)" , "contents": "enumerateIndexesUsingBlock(${1:Int}), UnsafeMutablePointerObjCBool:${2:}))" },{ "trigger": "NSPersonNameComponents) \t coder:" , "contents": "NSPersonNameComponents(coder:${1:NSCoder}))" },{ "trigger": "unitStringFromJoules) \t func NSEnergyFormatter -> String" , "contents": "unitStringFromJoules(${1:Double}), usedUnit:${2:UnsafeMutablePointerNSEnergyFormatterUnit}))" },{ "trigger": "filterUsingPredicate) \t func NSMutableSet -> void" , "contents": "filterUsingPredicate(${1:NSPredicate}))" },{ "trigger": "NSEdgeInsets \t NSEdgeInsets", "contents": "NSEdgeInsets" },{ "trigger": "NSSet) \t object:" , "contents": "NSSet(${1:AnyObject}))" },{ "trigger": "removeObserver) \t func NSNotificationCenter -> void" , "contents": "removeObserver(${1:AnyObject}))" },{ "trigger": "unsignedLongValue \t UInt", "contents": "unsignedLongValue" },{ "trigger": "finished \t Bool", "contents": "finished" },{ "trigger": "unload) \t func NSBundle -> Bool" , "contents": "unload(${1:}))" },{ "trigger": "NSCalendarIdentifierIslamicUmmAlQura \t String", "contents": "NSCalendarIdentifierIslamicUmmAlQura" },{ "trigger": "PMSymbol \t String", "contents": "PMSymbol" },{ "trigger": "stringFromValue) \t func NSMassFormatter -> String" , "contents": "stringFromValue(${1:Double}), unit:${2:NSMassFormatterUnit}))" },{ "trigger": "_conditionallyBridgeFromObject) \t static Float -> Bool" , "contents": "_conditionallyBridgeFromObject(${1:NSNumber}), inout:${2:Float?}))" },{ "trigger": "contentsOfDirectoryAtPath) \t func NSFileManager -> [String]" , "contents": "contentsOfDirectoryAtPath(${1:String}))" },{ "trigger": "NSIndexSet \t NSIndexSet", "contents": "NSIndexSet" },{ "trigger": "NSPersonNameComponentsFormatterOptions \t NSPersonNameComponentsFormatterOptions", "contents": "NSPersonNameComponentsFormatterOptions" },{ "trigger": "NSURLSessionTaskState \t NSURLSessionTaskState", "contents": "NSURLSessionTaskState" },{ "trigger": "dateFromComponents) \t func NSCalendar -> NSDate?" , "contents": "dateFromComponents(${1:NSDateComponents}))" },{ "trigger": "insertObject) \t func NSMutableArray -> void" , "contents": "insertObject(${1:AnyObject}), atIndex:${2:Int}))" },{ "trigger": "NSByteCountFormatter) \t :" , "contents": "NSByteCountFormatter(${1:}))" },{ "trigger": "copyWithZone) \t func NSNull -> AnyObject" , "contents": "copyWithZone(${1:NSZone}))" },{ "trigger": "enumerateObjectsUsingBlock) \t func NSOrderedSet -> Void)" , "contents": "enumerateObjectsUsingBlock(${1:AnyObject}), Int:${2:}), UnsafeMutablePointerObjCBool:${3:}))" },{ "trigger": "defaultCredentialForProtectionSpace) \t func NSURLCredentialStorage -> NSURLCredential?" , "contents": "defaultCredentialForProtectionSpace(${1:NSURLProtectionSpace}))" },{ "trigger": "NSURLErrorDownloadDecodingFailedToComplete \t Int", "contents": "NSURLErrorDownloadDecodingFailedToComplete" },{ "trigger": "pathForResource) \t class NSBundle -> String?" , "contents": "pathForResource(${1:String?}), ofType:${2:String?}), inDirectory:${3:String}))" },{ "trigger": "NSURLAuthenticationMethodHTMLForm \t String", "contents": "NSURLAuthenticationMethodHTMLForm" },{ "trigger": "replaceObjectsInRange) \t func NSMutableArray -> void" , "contents": "replaceObjectsInRange(${1:NSRange}), withObjectsFromArray:${2:[AnyObject]}))" },{ "trigger": "encodeRect) \t func NSCoder -> void" , "contents": "encodeRect(${1:NSRect}), forKey:${2:String}))" },{ "trigger": "NSLocaleCollationIdentifier \t String", "contents": "NSLocaleCollationIdentifier" },{ "trigger": "defaultTimeZone) \t class NSTimeZone -> NSTimeZone" , "contents": "defaultTimeZone(${1:}))" },{ "trigger": "NSURLComponents) \t URL: resolvingAgainstBaseURL:" , "contents": "NSURLComponents(URL:${1:NSURL}), resolvingAgainstBaseURL:${2:Bool}))" },{ "trigger": "NSProgressFileURLKey \t String", "contents": "NSProgressFileURLKey" },{ "trigger": "NSConditionLock) \t :" , "contents": "NSConditionLock(${1:}))" },{ "trigger": "NSURLCredential \t NSURLCredential", "contents": "NSURLCredential" },{ "trigger": "encodeWithCoder) \t func NSDate -> void" , "contents": "encodeWithCoder(${1:NSCoder}))" },{ "trigger": "NSMutableCharacterSet \t NSMutableCharacterSet", "contents": "NSMutableCharacterSet" },{ "trigger": "addIndex) \t func NSMutableIndexSet -> void" , "contents": "addIndex(${1:Int}))" },{ "trigger": "NSURLErrorCallIsActive \t Int", "contents": "NSURLErrorCallIsActive" },{ "trigger": "NSXMLNodePreserveAll \t NSXMLNodeOptionRawType", "contents": "NSXMLNodePreserveAll" },{ "trigger": "encodeWithCoder) \t func NSExpression -> void" , "contents": "encodeWithCoder(${1:NSCoder}))" },{ "trigger": "defaultCStringEncoding) \t class NSString -> UInt" , "contents": "defaultCStringEncoding(${1:}))" },{ "trigger": "processName \t String", "contents": "processName" },{ "trigger": "memoryCapacity \t Int", "contents": "memoryCapacity" },{ "trigger": "length \t Int", "contents": "length" },{ "trigger": "addPort) \t func NSRunLoop -> void" , "contents": "addPort(${1:NSPort}), forMode:${2:String}))" },{ "trigger": "NSHelpAnchorErrorKey \t String", "contents": "NSHelpAnchorErrorKey" },{ "trigger": "NSError) \t domain: code: userInfo:" , "contents": "NSError(${1:String}), code:${2:Int}), userInfo:${3:[String }))" },{ "trigger": "decimalNumberBySubtracting) \t func NSDecimalNumber -> NSDecimalNumber" , "contents": "decimalNumberBySubtracting(${1:NSDecimalNumber}), withBehavior:${2:NSDecimalNumberBehaviors?}))" },{ "trigger": "NSDecimalNumberUnderflowException \t String", "contents": "NSDecimalNumberUnderflowException" },{ "trigger": "NSMassFormatter) \t coder:" , "contents": "NSMassFormatter(${1:NSCoder}))" },{ "trigger": "attributedStringForZero \t NSAttributedString", "contents": "attributedStringForZero" },{ "trigger": "NSCachedURLResponse) \t response: data: userInfo: storagePolicy:" , "contents": "NSCachedURLResponse(${1:NSURLResponse}), data:${2:NSData}), userInfo:${3:[NSObject }), storagePolicy:${4:NSURLCacheStoragePolicy}))" },{ "trigger": "signal) \t func NSCondition -> void" , "contents": "signal(${1:}))" },{ "trigger": "encodeWithCoder) \t func NSError -> void" , "contents": "encodeWithCoder(${1:NSCoder}))" },{ "trigger": "copyItemAtURL) \t func NSFileManager -> void" , "contents": "copyItemAtURL(${1:NSURL}), toURL:${2:NSURL}))" },{ "trigger": "function \t String", "contents": "function" },{ "trigger": "getObjects) \t func Generator -> void" , "contents": "getObjects(inout:${1:[AnyObject]}), inout:${2:[AnyObject]}), count:${3:Int}))" },{ "trigger": "NSDecimalNumber) \t string:" , "contents": "NSDecimalNumber(string:${1:String?}))" },{ "trigger": "helpAnchor \t String", "contents": "helpAnchor" },{ "trigger": "formatWidth \t Int", "contents": "formatWidth" },{ "trigger": "isValidationError \t Bool", "contents": "isValidationError" },{ "trigger": "stringWithFileSystemRepresentation) \t func NSFileManager -> String" , "contents": "stringWithFileSystemRepresentation(${1:UnsafePointerInt8}), length:${2:Int}))" },{ "trigger": "getIndexes) \t func NSIndexSet -> Int" , "contents": "getIndexes(${1:UnsafeMutablePointerInt}), maxCount:${2:Int}), inIndexRange:${3:NSRangePointer}))" },{ "trigger": "_forceBridgeFromObject) \t static String -> void" , "contents": "_forceBridgeFromObject(${1:NSString}), inout:${2:String?}))" },{ "trigger": "unitStyle \t NSFormattingUnitStyle", "contents": "unitStyle" },{ "trigger": "NSURLCredential) \t forTrust:" , "contents": "NSURLCredential(forTrust:${1:SecTrust}))" },{ "trigger": "NSXMLNode \t NSXMLNode", "contents": "NSXMLNode" },{ "trigger": "NSSet) \t coder:" , "contents": "NSSet(coder:${1:NSCoder}))" },{ "trigger": "NSXMLDocumentTidyXML \t NSXMLNodeOptionRawType", "contents": "NSXMLDocumentTidyXML" },{ "trigger": "NSPredicate) \t value:" , "contents": "NSPredicate(${1:Bool}))" },{ "trigger": "NSPredicate) \t format: argumentArray:" , "contents": "NSPredicate(format:${1:String}), argumentArray:${2:[AnyObject]?}))" },{ "trigger": "NSXMLNodeLoadExternalEntitiesNever \t NSXMLNodeOptionRawType", "contents": "NSXMLNodeLoadExternalEntitiesNever" },{ "trigger": "getCachedResponseForDataTask) \t func NSURLCache -> Void)" , "contents": "getCachedResponseForDataTask(${1:NSURLSessionDataTask}), completionHandler:${2:NSCachedURLResponse? - Void}))" },{ "trigger": "invertedSet \t NSCharacterSet", "contents": "invertedSet" },{ "trigger": "unionSet) \t func NSMutableSet -> void" , "contents": "unionSet(${1:SetNSObject}))" },{ "trigger": "NSFormatter \t NSFormatter", "contents": "NSFormatter" },{ "trigger": "rangeOfComposedCharacterSequencesForRange) \t func NSString -> NSRange" , "contents": "rangeOfComposedCharacterSequencesForRange(${1:NSRange}))" },{ "trigger": "dictionaryRepresentation) \t func NSUserDefaults -> [String" , "contents": "dictionaryRepresentation(${1:}))" },{ "trigger": "gregorianStartDate \t NSDate", "contents": "gregorianStartDate" },{ "trigger": "NSAttributedStringEnumerationOptions) \t rawValue:" , "contents": "NSAttributedStringEnumerationOptions(${1:UInt}))" },{ "trigger": "UInt) \t _:" , "contents": "UInt(_:${1:NSNumber}))" },{ "trigger": "appendBytes) \t func NSMutableData -> void" , "contents": "appendBytes(${1:UnsafePointerVoid}), length:${2:Int}))" },{ "trigger": "NSFilePosixPermissions \t String", "contents": "NSFilePosixPermissions" },{ "trigger": "NSQualityOfService \t NSQualityOfService", "contents": "NSQualityOfService" },{ "trigger": "NSFileHandleDataAvailableNotification \t String", "contents": "NSFileHandleDataAvailableNotification" },{ "trigger": "localizedStringFromPersonNameComponents) \t class NSPersonNameComponentsFormatter -> String" , "contents": "localizedStringFromPersonNameComponents(${1:NSPersonNameComponents}), style:${2:NSPersonNameComponentsFormatterStyle}), options:${3:NSPersonNameComponentsFormatterOptions}))" },{ "trigger": "unitStringFromValue) \t func NSLengthFormatter -> String" , "contents": "unitStringFromValue(${1:Double}), unit:${2:NSLengthFormatterUnit}))" },{ "trigger": "mutableCopyWithZone) \t func NSURLRequest -> AnyObject" , "contents": "mutableCopyWithZone(${1:NSZone}))" },{ "trigger": "encodeWithCoder) \t func NSValue -> void" , "contents": "encodeWithCoder(${1:NSCoder}))" },{ "trigger": "nextDateAfterDate) \t func NSCalendar -> NSDate?" , "contents": "nextDateAfterDate(${1:NSDate}), matchingHour:${2:Int}), minute:${3:Int}), second:${4:Int}), options:${5:NSCalendarOptions}))" },{ "trigger": "dateStyle \t NSDateIntervalFormatterStyle", "contents": "dateStyle" },{ "trigger": "NSMutableDictionary) \t contentsOfURL:" , "contents": "NSMutableDictionary(contentsOfURL:${1:NSURL}))" },{ "trigger": "Double) \t _:" , "contents": "Double(_:${1:CGFloat}))" },{ "trigger": "isDateInToday) \t func NSCalendar -> Bool" , "contents": "isDateInToday(${1:NSDate}))" },{ "trigger": "compare) \t func NSIndexPath -> NSComparisonResult" , "contents": "compare(${1:NSIndexPath}))" },{ "trigger": "msgid \t UInt", "contents": "msgid" },{ "trigger": "NSStringFromSize) \t func unknown -> String" , "contents": "NSStringFromSize(${1:NSSize}))" },{ "trigger": "NSCalendarIdentifierIslamicCivil \t String", "contents": "NSCalendarIdentifierIslamicCivil" },{ "trigger": "resetStandardUserDefaults) \t class NSUserDefaults -> void" , "contents": "resetStandardUserDefaults(${1:}))" },{ "trigger": "NSDecimalIsNotANumber) \t func unknown -> Bool" , "contents": "NSDecimalIsNotANumber(${1:UnsafePointerNSDecimal}))" },{ "trigger": "mutableCopy) \t func NSMutableCopying -> AnyObject" , "contents": "mutableCopy(${1:}))" },{ "trigger": "NSURLErrorDataNotAllowed \t Int", "contents": "NSURLErrorDataNotAllowed" },{ "trigger": "scanDouble) \t func NSScanner -> Bool" , "contents": "scanDouble(${1:UnsafeMutablePointerDouble}))" },{ "trigger": "NSHTTPCookieCommentURL \t String", "contents": "NSHTTPCookieCommentURL" },{ "trigger": "archiveRootObject) \t class NSKeyedArchiver -> Bool" , "contents": "archiveRootObject(${1:AnyObject}), toFile:${2:String}))" },{ "trigger": "NSLocaleExemplarCharacterSet \t String", "contents": "NSLocaleExemplarCharacterSet" },{ "trigger": "getEra) \t func NSCalendar -> void" , "contents": "getEra(${1:UnsafeMutablePointerInt}), year:${2:UnsafeMutablePointerInt}), month:${3:UnsafeMutablePointerInt}), day:${4:UnsafeMutablePointerInt}), fromDate:${5:NSDate}))" },{ "trigger": "NSHost \t NSHost", "contents": "NSHost" },{ "trigger": "Bool) \t _:" , "contents": "Bool(_:${1:NSNumber}))" },{ "trigger": "NSHost) \t name:" , "contents": "NSHost(${1:String?}))" },{ "trigger": "NSFileType \t String", "contents": "NSFileType" },{ "trigger": "NSXMLDTDNode \t NSXMLDTDNode", "contents": "NSXMLDTDNode" },{ "trigger": "NSURLErrorUnsupportedURL \t Int", "contents": "NSURLErrorUnsupportedURL" },{ "trigger": "user \t String", "contents": "user" },{ "trigger": "addExecutionBlock) \t func NSBlockOperation -> Void)" , "contents": "addExecutionBlock(${1: - Void}))" },{ "trigger": "fileURLWithPathComponents) \t class NSURL -> NSURL?" , "contents": "fileURLWithPathComponents(${1:[String]}))" },{ "trigger": "NSRegularExpressionOptions) \t rawValue:" , "contents": "NSRegularExpressionOptions(${1:UInt}))" },{ "trigger": "writeToURL) \t func Generator -> Bool" , "contents": "writeToURL(${1:NSURL}), atomically:${2:Bool}))" },{ "trigger": "decodeRect) \t func NSCoder -> NSRect" , "contents": "decodeRect(${1:}))" },{ "trigger": "timeInterval \t NSTimeInterval", "contents": "timeInterval" },{ "trigger": "copyWithZone) \t func NSURLQueryItem -> AnyObject" , "contents": "copyWithZone(${1:NSZone}))" },{ "trigger": "launch) \t func NSTask -> void" , "contents": "launch(${1:}))" },{ "trigger": "executableURL \t NSURL", "contents": "executableURL" },{ "trigger": "scanInt) \t func NSScanner -> Bool" , "contents": "scanInt(${1:UnsafeMutablePointerInt32}))" },{ "trigger": "NSLock \t NSLock", "contents": "NSLock" },{ "trigger": "encodeArrayOfObjCType) \t func NSCoder -> void" , "contents": "encodeArrayOfObjCType(${1:UnsafePointerInt8}), count:${2:Int}), at:${3:UnsafePointerVoid}))" },{ "trigger": "NSLocationInRange) \t func unknown -> Bool" , "contents": "NSLocationInRange(${1:Int}), _:${2:NSRange}))" },{ "trigger": "finishDecoding) \t func NSKeyedUnarchiver -> void" , "contents": "finishDecoding(${1:}))" },{ "trigger": "currentQueue) \t class NSOperationQueue -> NSOperationQueue?" , "contents": "currentQueue(${1:}))" },{ "trigger": "setDefaultCredential) \t func NSURLCredentialStorage -> void" , "contents": "setDefaultCredential(${1:NSURLCredential}), forProtectionSpace:${2:NSURLProtectionSpace}), task:${3:NSURLSessionTask}))" },{ "trigger": "NSCurrentLocaleDidChangeNotification \t String", "contents": "NSCurrentLocaleDidChangeNotification" },{ "trigger": "characterAtIndex) \t func NSString -> unichar" , "contents": "characterAtIndex(${1:Int}))" },{ "trigger": "getFileSystemRepresentation) \t func NSString -> Bool" , "contents": "getFileSystemRepresentation(${1:UnsafeMutablePointerInt8}), maxLength:${2:Int}))" },{ "trigger": "resume) \t func NSTask -> Bool" , "contents": "resume(${1:}))" },{ "trigger": "NSFileHandleConnectionAcceptedNotification \t String", "contents": "NSFileHandleConnectionAcceptedNotification" },{ "trigger": "getObjects) \t func Generator -> void" , "contents": "getObjects(inout:${1:[AnyObject]}), range:${2:NSRange}))" },{ "trigger": "NSValue) \t point:" , "contents": "NSValue(${1:NSPoint}))" },{ "trigger": "decimalNumberByDividingBy) \t func NSDecimalNumber -> NSDecimalNumber" , "contents": "decimalNumberByDividingBy(${1:NSDecimalNumber}), withBehavior:${2:NSDecimalNumberBehaviors?}))" },{ "trigger": "NSFileOwnerAccountName \t String", "contents": "NSFileOwnerAccountName" },{ "trigger": "copyWithZone) \t func NSAttributedString -> AnyObject" , "contents": "copyWithZone(${1:NSZone}))" },{ "trigger": "NSProgressThroughputKey \t String", "contents": "NSProgressThroughputKey" },{ "trigger": "builtInPlugInsPath \t String", "contents": "builtInPlugInsPath" },{ "trigger": "Double) \t _:" , "contents": "Double(_:${1:NSNumber}))" },{ "trigger": "NSURLAuthenticationChallenge) \t protectionSpace: proposedCredential: previousFailureCount: failureResponse: error:" , "contents": "NSURLAuthenticationChallenge(protectionSpace:${1:NSURLProtectionSpace}), proposedCredential:${2:NSURLCredential?}), previousFailureCount:${3:Int}), failureResponse:${4:NSURLResponse?}), error:${5:NSError?}))" },{ "trigger": "description \t String", "contents": "description" },{ "trigger": "readDataToEndOfFile) \t func NSFileHandle -> NSData" , "contents": "readDataToEndOfFile(${1:}))" },{ "trigger": "name \t String", "contents": "name" },{ "trigger": "constantValue \t AnyObject", "contents": "constantValue" },{ "trigger": "NSFileTypeSymbolicLink \t String", "contents": "NSFileTypeSymbolicLink" },{ "trigger": "NSString) \t bytes: length: encoding:" , "contents": "NSString(${1:UnsafePointerVoid}), length:${2:Int}), encoding:${3:UInt}))" },{ "trigger": "encodeConditionalObject) \t func NSCoder -> void" , "contents": "encodeConditionalObject(${1:AnyObject?}))" },{ "trigger": "moveItemAtURL) \t func NSFileManager -> void" , "contents": "moveItemAtURL(${1:NSURL}), toURL:${2:NSURL}))" },{ "trigger": "downloadTaskWithURL) \t func NSURLSession -> NSURLSessionDownloadTask" , "contents": "downloadTaskWithURL(${1:NSURL}))" },{ "trigger": "dataForKey) \t func NSUserDefaults -> NSData?" , "contents": "dataForKey(${1:String}))" },{ "trigger": "enqueueNotification) \t func NSNotificationQueue -> void" , "contents": "enqueueNotification(${1:NSNotification}), postingStyle:${2:NSPostingStyle}))" },{ "trigger": "NSUUID) \t UUIDBytes:" , "contents": "NSUUID(UUIDBytes:${1:UnsafePointerUInt8}))" },{ "trigger": "ISOCountryCodes) \t class NSLocale -> [String]" , "contents": "ISOCountryCodes(${1:}))" },{ "trigger": "copyWithZone) \t func NSPersonNameComponents -> AnyObject" , "contents": "copyWithZone(${1:NSZone}))" },{ "trigger": "asynchronous \t Bool", "contents": "asynchronous" },{ "trigger": "NSNumberFormatter \t NSNumberFormatter", "contents": "NSNumberFormatter" },{ "trigger": "localizedCompare) \t func NSString -> NSComparisonResult" , "contents": "localizedCompare(${1:String}))" },{ "trigger": "NSNumber) \t floatLiteral:" , "contents": "NSNumber(floatLiteral:${1:Double}))" },{ "trigger": "plusSign \t String", "contents": "plusSign" },{ "trigger": "twoDigitStartDate \t NSDate", "contents": "twoDigitStartDate" },{ "trigger": "cancelAllOperations) \t func NSOperationQueue -> void" , "contents": "cancelAllOperations(${1:}))" },{ "trigger": "code \t Int", "contents": "code" },{ "trigger": "NSEqualPoints) \t func unknown -> Bool" , "contents": "NSEqualPoints(${1:NSPoint}), _:${2:NSPoint}))" },{ "trigger": "NSPropertyListSerialization \t NSPropertyListSerialization", "contents": "NSPropertyListSerialization" },{ "trigger": "addIndexes) \t func NSMutableIndexSet -> void" , "contents": "addIndexes(${1:NSIndexSet}))" },{ "trigger": "paused \t Bool", "contents": "paused" },{ "trigger": "invert) \t func NSMutableCharacterSet -> void" , "contents": "invert(${1:}))" },{ "trigger": "ephemeralSessionConfiguration) \t class NSURLSessionConfiguration -> NSURLSessionConfiguration" , "contents": "ephemeralSessionConfiguration(${1:}))" },{ "trigger": "setAttributedString) \t func NSMutableAttributedString -> void" , "contents": "setAttributedString(${1:NSAttributedString}))" },{ "trigger": "allowEvaluation) \t func NSPredicate -> void" , "contents": "allowEvaluation(${1:}))" },{ "trigger": "NSConditionLock) \t condition:" , "contents": "NSConditionLock(${1:Int}))" },{ "trigger": "supportsSecureCoding) \t func NSURLCredential -> Bool" , "contents": "supportsSecureCoding(${1:}))" },{ "trigger": "pointValue \t NSPoint", "contents": "pointValue" },{ "trigger": "indeterminate \t Bool", "contents": "indeterminate" },{ "trigger": "nickname \t String", "contents": "nickname" },{ "trigger": "predicateFormat \t String", "contents": "predicateFormat" },{ "trigger": "invert) \t func NSAffineTransform -> void" , "contents": "invert(${1:}))" },{ "trigger": "descriptionWithLocale) \t func NSOrderedSet -> String" , "contents": "descriptionWithLocale(${1:AnyObject?}))" },{ "trigger": "NSFileHandleOperationException \t String", "contents": "NSFileHandleOperationException" },{ "trigger": "NSHTTPCookieName \t String", "contents": "NSHTTPCookieName" },{ "trigger": "deleteCharactersInRange) \t func NSMutableAttributedString -> void" , "contents": "deleteCharactersInRange(${1:NSRange}))" },{ "trigger": "_conditionallyBridgeFromObject) \t static Int -> Bool" , "contents": "_conditionallyBridgeFromObject(${1:NSNumber}), inout:${2:Int?}))" },{ "trigger": "maximumDecimalNumber) \t class NSDecimalNumber -> NSDecimalNumber" , "contents": "maximumDecimalNumber(${1:}))" },{ "trigger": "lineRangeForRange) \t func NSString -> NSRange" , "contents": "lineRangeForRange(${1:NSRange}))" },{ "trigger": "NSMutableOrderedSet) \t capacity:" , "contents": "NSMutableOrderedSet(capacity:${1:Int}))" },{ "trigger": "NSEdgeInsets) \t :" , "contents": "NSEdgeInsets(${1:}))" },{ "trigger": "NSURLResponse) \t URL: MIMEType: expectedContentLength: textEncodingName:" , "contents": "NSURLResponse(${1:NSURL}), MIMEType:${2:String?}), expectedContentLength:${3:Int}), textEncodingName:${4:String?}))" },{ "trigger": "NSLocaleLanguageCode \t String", "contents": "NSLocaleLanguageCode" },{ "trigger": "NSThread \t NSThread", "contents": "NSThread" },{ "trigger": "objectValue) \t func NSDateFormatter -> AnyObject?" , "contents": "objectValue(${1:String}), range:${2:UnsafeMutablePointerNSRange}))" },{ "trigger": "indexPathByRemovingLastIndex) \t func NSIndexPath -> NSIndexPath" , "contents": "indexPathByRemovingLastIndex(${1:}))" },{ "trigger": "registerClass) \t class NSURLProtocol -> Bool" , "contents": "registerClass(${1:AnyClass}))" },{ "trigger": "version \t String", "contents": "version" },{ "trigger": "scanCharactersFromSet) \t func NSScanner -> String?" , "contents": "scanCharactersFromSet(${1:NSCharacterSet}))" },{ "trigger": "NSXMLElement \t NSXMLElement", "contents": "NSXMLElement" },{ "trigger": "unitsStyle \t NSDateComponentsFormatterUnitsStyle", "contents": "unitsStyle" },{ "trigger": "numberOfMatchesInString) \t func NSRegularExpression -> Int" , "contents": "numberOfMatchesInString(${1:String}), options:${2:NSMatchingOptions}), range:${3:NSRange}))" },{ "trigger": "descriptionWithLocale) \t func Generator -> String" , "contents": "descriptionWithLocale(${1:AnyObject?}))" },{ "trigger": "stringByPaddingToLength) \t func NSString -> String" , "contents": "stringByPaddingToLength(${1:Int}), withString:${2:String}), startingAtIndex:${3:Int}))" },{ "trigger": "NSCache \t NSCache", "contents": "NSCache" },{ "trigger": "==T:) \t func unknown -> Bool" , "contents": "==T:(${1:T}), rhs:${2:T}))" },{ "trigger": "NSNotificationCenter) \t :" , "contents": "NSNotificationCenter(${1:}))" },{ "trigger": "zeroSymbol \t String", "contents": "zeroSymbol" },{ "trigger": "NSPersonNameComponentsFormatter \t NSPersonNameComponentsFormatter", "contents": "NSPersonNameComponentsFormatter" },{ "trigger": "NSLocalizedFailureReasonErrorKey \t String", "contents": "NSLocalizedFailureReasonErrorKey" },{ "trigger": "getUUIDBytes) \t func NSUUID -> void" , "contents": "getUUIDBytes(${1:UnsafeMutablePointerUInt8}))" },{ "trigger": "setChildren) \t func NSXMLDocument -> void" , "contents": "setChildren(${1:[NSXMLNode]?}))" },{ "trigger": "document) \t class NSXMLNode -> AnyObject" , "contents": "document(${1:}))" },{ "trigger": "filterUsingPredicate) \t func NSMutableOrderedSet -> void" , "contents": "filterUsingPredicate(${1:NSPredicate}))" },{ "trigger": "encodeWithCoder) \t func NSAttributedString -> void" , "contents": "encodeWithCoder(${1:NSCoder}))" },{ "trigger": "collapsesLargestUnit \t Bool", "contents": "collapsesLargestUnit" },{ "trigger": "NSNull \t NSNull", "contents": "NSNull" },{ "trigger": "partialStringValidationEnabled \t Bool", "contents": "partialStringValidationEnabled" },{ "trigger": "resourcePath \t String", "contents": "resourcePath" },{ "trigger": "enumerateObjectsWithOptions) \t func NSOrderedSet -> Void)" , "contents": "enumerateObjectsWithOptions(${1:NSEnumerationOptions}), usingBlock:${2:AnyObject}), Int:${3:}), UnsafeMutablePointerObjCBool:${4:}))" },{ "trigger": "setDefaultCredential) \t func NSURLCredentialStorage -> void" , "contents": "setDefaultCredential(${1:NSURLCredential}), forProtectionSpace:${2:NSURLProtectionSpace}))" },{ "trigger": "parse) \t func NSXMLParser -> Bool" , "contents": "parse(${1:}))" },{ "trigger": "NSError \t NSError", "contents": "NSError" },{ "trigger": "NSMakePoint) \t func unknown -> NSPoint" , "contents": "NSMakePoint(${1:CGFloat}), _:${2:CGFloat}))" },{ "trigger": "NSEdgeInsetsMake) \t func unknown -> NSEdgeInsets" , "contents": "NSEdgeInsetsMake(${1:CGFloat}), _:${2:CGFloat}), _:${3:CGFloat}), _:${4:CGFloat}))" },{ "trigger": "NSURLAuthenticationMethodDefault \t String", "contents": "NSURLAuthenticationMethodDefault" },{ "trigger": "replaceChildAtIndex) \t func NSXMLDTD -> void" , "contents": "replaceChildAtIndex(${1:Int}), withNode:${2:NSXMLNode}))" },{ "trigger": "NSCalendarUnit \t NSCalendarUnit", "contents": "NSCalendarUnit" },{ "trigger": "earlierDate) \t func NSDate -> NSDate" , "contents": "earlierDate(${1:NSDate}))" },{ "trigger": "NSDecimalNumberExactnessException \t String", "contents": "NSDecimalNumberExactnessException" },{ "trigger": "encodeWithCoder) \t func NSFileHandle -> void" , "contents": "encodeWithCoder(${1:NSCoder}))" },{ "trigger": "attributedStringForNil \t NSAttributedString", "contents": "attributedStringForNil" },{ "trigger": "getBytes) \t func NSData -> void" , "contents": "getBytes(${1:UnsafeMutablePointerVoid}), length:${2:Int}))" },{ "trigger": "stringByReplacingOccurrencesOfString) \t func NSString -> String" , "contents": "stringByReplacingOccurrencesOfString(${1:String}), withString:${2:String}), options:${3:NSStringCompareOptions}), range:${4:NSRange}))" },{ "trigger": "unsignedIntValue \t UInt", "contents": "unsignedIntValue" },{ "trigger": "loadAndReturnError) \t func NSBundle -> void" , "contents": "loadAndReturnError(${1:}))" },{ "trigger": "-) \t func unknown -> CGFloat" , "contents": "-(${1:CGFloat}))" },{ "trigger": "rangeOfPort \t NSRange", "contents": "rangeOfPort" },{ "trigger": "NSSocketPort) \t remoteWithProtocolFamily: socketType: `protocol`: address:" , "contents": "NSSocketPort(remoteWithProtocolFamily:${1:Int32}), socketType:${2:Int32}), `protocol`:${3:Int32}), address:${4:NSData}))" },{ "trigger": "previousNode \t NSXMLNode", "contents": "previousNode" },{ "trigger": "NSXMLNode) \t kind: options:" , "contents": "NSXMLNode(${1:NSXMLNodeKind}), options:${2:Int}))" },{ "trigger": "NSXMLNodeNeverEscapeContents \t NSXMLNodeOptionRawType", "contents": "NSXMLNodeNeverEscapeContents" },{ "trigger": "enumerateDatesStartingAfterDate) \t func NSCalendar -> Void)" , "contents": "enumerateDatesStartingAfterDate(${1:NSDate}), matchingComponents:${2:NSDateComponents}), options:${3:NSCalendarOptions}), usingBlock:${4:NSDate?}), Bool:${5:}), UnsafeMutablePointerObjCBool:${6:}))" },{ "trigger": "running \t Bool", "contents": "running" },{ "trigger": "NSCharacterSet) \t bitmapRepresentation:" , "contents": "NSCharacterSet(bitmapRepresentation:${1:NSData}))" },{ "trigger": "getBytes) \t func NSString -> Bool" , "contents": "getBytes(${1:UnsafeMutablePointerVoid}), maxLength:${2:Int}), usedLength:${3:UnsafeMutablePointerInt}), encoding:${4:UInt}), options:${5:NSStringEncodingConversionOptions}), range:${6:NSRange}), remainingRange:${7:NSRangePointer}))" },{ "trigger": "supportsSecureCoding) \t static NSIndexPath -> Bool" , "contents": "supportsSecureCoding(${1:}))" },{ "trigger": "NSURLRequestNetworkServiceType \t NSURLRequestNetworkServiceType", "contents": "NSURLRequestNetworkServiceType" },{ "trigger": "NSPredicateOperatorType \t NSPredicateOperatorType", "contents": "NSPredicateOperatorType" },{ "trigger": "NSURLSessionResponseDisposition \t NSURLSessionResponseDisposition", "contents": "NSURLSessionResponseDisposition" },{ "trigger": "interrupt) \t func NSTask -> void" , "contents": "interrupt(${1:}))" },{ "trigger": "resume) \t func NSProgress -> void" , "contents": "resume(${1:}))" },{ "trigger": "rangeOfCharacterFromSet) \t func NSString -> NSRange" , "contents": "rangeOfCharacterFromSet(${1:NSCharacterSet}), options:${2:NSStringCompareOptions}))" },{ "trigger": "NSEnumerator \t NSEnumerator", "contents": "NSEnumerator" },{ "trigger": "NSPersonNameComponentsFormatterStyle \t NSPersonNameComponentsFormatterStyle", "contents": "NSPersonNameComponentsFormatterStyle" },{ "trigger": "propertyListWithData) \t class NSPropertyListSerialization -> Any" , "contents": "propertyListWithData(${1:NSData}), options:${2:NSPropertyListReadOptions}), format:${3:UnsafeMutablePointerNSPropertyListFormat}))" },{ "trigger": "defaultCenter) \t class NSNotificationCenter -> NSNotificationCenter" , "contents": "defaultCenter(${1:}))" },{ "trigger": "URL \t NSURL", "contents": "URL" },{ "trigger": "NSDateComponents) \t coder:" , "contents": "NSDateComponents(coder:${1:NSCoder}))" },{ "trigger": "contentsEqualAtPath) \t func NSFileManager -> Bool" , "contents": "contentsEqualAtPath(${1:String}), andPath:${2:String}))" },{ "trigger": "namePrefix \t String", "contents": "namePrefix" },{ "trigger": "URLFragmentAllowedCharacterSet) \t class NSCharacterSet -> NSCharacterSet" , "contents": "URLFragmentAllowedCharacterSet(${1:}))" },{ "trigger": "NSTimeZoneNameStyle \t NSTimeZoneNameStyle", "contents": "NSTimeZoneNameStyle" },{ "trigger": "uploadTaskWithRequest) \t func NSURLSession -> NSURLSessionUploadTask" , "contents": "uploadTaskWithRequest(${1:NSURLRequest}), fromData:${2:NSData}))" },{ "trigger": "style \t NSPersonNameComponentsFormatterStyle", "contents": "style" },{ "trigger": "includesCount \t Bool", "contents": "includesCount" },{ "trigger": "fileHandleForReading \t NSFileHandle", "contents": "fileHandleForReading" },{ "trigger": "supportsSecureCoding) \t static NSUUID -> Bool" , "contents": "supportsSecureCoding(${1:}))" },{ "trigger": "unlock) \t func NSLock -> void" , "contents": "unlock(${1:}))" },{ "trigger": "runMode) \t func NSRunLoop -> Bool" , "contents": "runMode(${1:String}), beforeDate:${2:NSDate}))" },{ "trigger": "Generator \t Generator", "contents": "Generator" },{ "trigger": "annotatedStringFromPersonNameComponents) \t func NSPersonNameComponentsFormatter -> NSAttributedString" , "contents": "annotatedStringFromPersonNameComponents(${1:NSPersonNameComponents}))" },{ "trigger": "NSCompoundPredicate) \t orPredicateWithSubpredicates:" , "contents": "NSCompoundPredicate(orPredicateWithSubpredicates:${1:[NSPredicate]}))" },{ "trigger": "setString) \t func NSMutableString -> void" , "contents": "setString(${1:String}))" },{ "trigger": "writeData) \t func NSFileHandle -> void" , "contents": "writeData(${1:NSData}))" },{ "trigger": "isDaylightSavingTimeForDate) \t func NSTimeZone -> Bool" , "contents": "isDaylightSavingTimeForDate(${1:NSDate}))" },{ "trigger": "localizedCaseInsensitiveCompare) \t func NSString -> NSComparisonResult" , "contents": "localizedCaseInsensitiveCompare(${1:String}))" },{ "trigger": "roundingMode) \t func NSDecimalNumberHandler -> NSRoundingMode" , "contents": "roundingMode(${1:}))" },{ "trigger": "calendar \t NSCalendar", "contents": "calendar" },{ "trigger": "NSMutableDictionary) \t contentsOfFile:" , "contents": "NSMutableDictionary(contentsOfFile:${1:String}))" },{ "trigger": "replaceObjectAtIndex) \t func NSMutableOrderedSet -> void" , "contents": "replaceObjectAtIndex(${1:Int}), withObject:${2:AnyObject}))" },{ "trigger": "kind \t String", "contents": "kind" },{ "trigger": "standardOutput \t AnyObject", "contents": "standardOutput" },{ "trigger": "component) \t func NSCalendar -> Int" , "contents": "component(${1:NSCalendarUnit}), fromDate:${2:NSDate}))" },{ "trigger": "copyWithZone) \t func NSPort -> AnyObject" , "contents": "copyWithZone(${1:NSZone}))" },{ "trigger": "localTimeZone) \t class NSTimeZone -> NSTimeZone" , "contents": "localTimeZone(${1:}))" },{ "trigger": "NSXMLDocumentContentKind \t NSXMLDocumentContentKind", "contents": "NSXMLDocumentContentKind" },{ "trigger": "predefinedNamespaceForPrefix) \t class NSXMLNode -> NSXMLNode?" , "contents": "predefinedNamespaceForPrefix(${1:String}))" },{ "trigger": "NSHTTPCookieAcceptPolicy \t NSHTTPCookieAcceptPolicy", "contents": "NSHTTPCookieAcceptPolicy" },{ "trigger": "NSURLErrorRedirectToNonExistentLocation \t Int", "contents": "NSURLErrorRedirectToNonExistentLocation" },{ "trigger": "NSXMLDTDNodeKind \t NSXMLDTDNodeKind", "contents": "NSXMLDTDNodeKind" },{ "trigger": "doesRelativeDateFormatting \t Bool", "contents": "doesRelativeDateFormatting" },{ "trigger": "storeCachedResponse) \t func NSURLCache -> void" , "contents": "storeCachedResponse(${1:NSCachedURLResponse}), forRequest:${2:NSURLRequest}))" },{ "trigger": "NSMachErrorDomain \t String", "contents": "NSMachErrorDomain" },{ "trigger": "removeObjectForKey) \t func NSUserDefaults -> void" , "contents": "removeObjectForKey(${1:String}))" },{ "trigger": "prefixForName) \t class NSXMLNode -> String?" , "contents": "prefixForName(${1:String}))" },{ "trigger": "removeAllCachedResponses) \t func NSURLCache -> void" , "contents": "removeAllCachedResponses(${1:}))" },{ "trigger": "copyWithZone) \t func NSCharacterSet -> AnyObject" , "contents": "copyWithZone(${1:NSZone}))" },{ "trigger": "NSDecimalNumber) \t string: locale:" , "contents": "NSDecimalNumber(string:${1:String?}), locale:${2:AnyObject?}))" },{ "trigger": "Generator) \t dictionary: copyItems:" , "contents": "Generator(${1:[NSObject }), copyItems:${2:Bool}))" },{ "trigger": "pathForResource) \t func NSBundle -> String?" , "contents": "pathForResource(${1:String?}), ofType:${2:String?}), inDirectory:${3:String?}), forLocalization:${4:String?}))" },{ "trigger": "NSURL) \t string: relativeToURL:" , "contents": "NSURL(string:${1:String}), relativeToURL:${2:NSURL?}))" },{ "trigger": "HTTPShouldSetCookies \t Bool", "contents": "HTTPShouldSetCookies" },{ "trigger": "copyWithZone) \t func NSCalendar -> AnyObject" , "contents": "copyWithZone(${1:NSZone}))" },{ "trigger": "indexOfObjectAtIndexes) \t func Generator -> Bool)" , "contents": "indexOfObjectAtIndexes(${1:NSIndexSet}), options:${2:NSEnumerationOptions}), passingTest:${3:AnyObject}), Int:${4:}), UnsafeMutablePointerObjCBool:${5:}))" },{ "trigger": "paddingCharacter \t String", "contents": "paddingCharacter" },{ "trigger": "isEqualToOrderedSet) \t func NSOrderedSet -> Bool" , "contents": "isEqualToOrderedSet(${1:NSOrderedSet}))" },{ "trigger": "NSCalendarIdentifierBuddhist \t String", "contents": "NSCalendarIdentifierBuddhist" },{ "trigger": "fileExistsAtPath) \t func NSFileManager -> Bool" , "contents": "fileExistsAtPath(${1:String}))" },{ "trigger": "stringByDeletingPathExtension \t String", "contents": "stringByDeletingPathExtension" },{ "trigger": "createFileAtPath) \t func NSFileManager -> Bool" , "contents": "createFileAtPath(${1:String}), contents:${2:NSData?}), attributes:${3:[String }))" },{ "trigger": "decodeValueOfObjCType) \t func NSCoder -> void" , "contents": "decodeValueOfObjCType(${1:UnsafePointerInt8}), at:${2:UnsafeMutablePointerVoid}))" },{ "trigger": "NSStreamSOCKSErrorDomain \t String", "contents": "NSStreamSOCKSErrorDomain" },{ "trigger": "port \t NSNumber", "contents": "port" },{ "trigger": "localizedUppercaseString \t String", "contents": "localizedUppercaseString" },{ "trigger": "createSymbolicLinkAtPath) \t func NSFileManager -> void" , "contents": "createSymbolicLinkAtPath(${1:String}), withDestinationPath:${2:String}))" },{ "trigger": "NSIndexPath) \t :" , "contents": "NSIndexPath(${1:}))" },{ "trigger": "broadcast) \t func NSCondition -> void" , "contents": "broadcast(${1:}))" },{ "trigger": "negativePrefix \t String", "contents": "negativePrefix" },{ "trigger": "getCharacters) \t func NSString -> void" , "contents": "getCharacters(${1:UnsafeMutablePointerunichar}), range:${2:NSRange}))" },{ "trigger": "secondaryGroupingSize \t Int", "contents": "secondaryGroupingSize" },{ "trigger": "NSShiftJISStringEncoding \t UInt", "contents": "NSShiftJISStringEncoding" },{ "trigger": "NSKeyedUnarchiver) \t forReadingWithData:" , "contents": "NSKeyedUnarchiver(forReadingWithData:${1:NSData}))" },{ "trigger": "condition \t Int", "contents": "condition" },{ "trigger": "generatesDecimalNumbers \t Bool", "contents": "generatesDecimalNumbers" },{ "trigger": "NSObject \t NSObject", "contents": "NSObject" },{ "trigger": "NSCachedURLResponse \t NSCachedURLResponse", "contents": "NSCachedURLResponse" },{ "trigger": "systemID \t String", "contents": "systemID" },{ "trigger": "normalizeAdjacentTextNodesPreservingCDATA) \t func NSXMLElement -> void" , "contents": "normalizeAdjacentTextNodesPreservingCDATA(${1:Bool}))" },{ "trigger": "NSLocaleIdentifier \t String", "contents": "NSLocaleIdentifier" },{ "trigger": "dateFromString) \t func NSDateFormatter -> NSDate?" , "contents": "dateFromString(${1:String}))" },{ "trigger": "rangeOfPath \t NSRange", "contents": "rangeOfPath" },{ "trigger": "NSDecimalSubtract) \t func unknown -> NSCalculationError" , "contents": "NSDecimalSubtract(${1:UnsafeMutablePointerNSDecimal}), _:${2:UnsafePointerNSDecimal}), _:${3:UnsafePointerNSDecimal}), _:${4:NSRoundingMode}))" },{ "trigger": "NSHTTPCookieStorage \t NSHTTPCookieStorage", "contents": "NSHTTPCookieStorage" },{ "trigger": "unlockWithCondition) \t func NSConditionLock -> void" , "contents": "unlockWithCondition(${1:Int}))" },{ "trigger": "NSNumber) \t integerLiteral:" , "contents": "NSNumber(integerLiteral:${1:Int}))" },{ "trigger": "encodeFloat) \t func NSCoder -> void" , "contents": "encodeFloat(${1:Float}), forKey:${2:String}))" },{ "trigger": "fileHandleForWriting \t NSFileHandle", "contents": "fileHandleForWriting" },{ "trigger": "copyWithZone) \t func NSSet -> AnyObject" , "contents": "copyWithZone(${1:NSZone}))" },{ "trigger": "percentEncodedPassword \t String", "contents": "percentEncodedPassword" },{ "trigger": "replaceOccurrencesOfString) \t func NSMutableString -> Int" , "contents": "replaceOccurrencesOfString(${1:String}), withString:${2:String}), options:${3:NSStringCompareOptions}), range:${4:NSRange}))" },{ "trigger": "smallestEncoding \t UInt", "contents": "smallestEncoding" },{ "trigger": "NSData) \t contentsOfFile: options:" , "contents": "NSData(contentsOfFile:${1:String}), options:${2:NSDataReadingOptions}))" },{ "trigger": "fileHandleWithStandardInput) \t class NSFileHandle -> NSFileHandle" , "contents": "fileHandleWithStandardInput(${1:}))" },{ "trigger": "bridge) \t func NSArray -> Array AnyObject " , "contents": "bridge(${1:}))" },{ "trigger": "supportsSecureCoding) \t func NSURL -> Bool" , "contents": "supportsSecureCoding(${1:}))" },{ "trigger": "leftExpression \t NSExpression", "contents": "leftExpression" },{ "trigger": "collection \t AnyObject", "contents": "collection" },{ "trigger": "HTTPOnly \t Bool", "contents": "HTTPOnly" },{ "trigger": "forPersonMassUse \t Bool", "contents": "forPersonMassUse" },{ "trigger": "replacementStringForResult) \t func NSRegularExpression -> String" , "contents": "replacementStringForResult(${1:NSTextCheckingResult}), inString:${2:String}), offset:${3:Int}), template:${4:String}))" },{ "trigger": "NSDate) \t coder:" , "contents": "NSDate(coder:${1:NSCoder}))" },{ "trigger": "supportsSecureCoding) \t static NSFileHandle -> Bool" , "contents": "supportsSecureCoding(${1:}))" },{ "trigger": "baseURL \t NSURL", "contents": "baseURL" },{ "trigger": "TLSMinimumSupportedProtocol \t SSLProtocol", "contents": "TLSMinimumSupportedProtocol" },{ "trigger": "encodeWithCoder) \t func Generator -> void" , "contents": "encodeWithCoder(${1:NSCoder}))" },{ "trigger": "storagePolicy \t NSURLCacheStoragePolicy", "contents": "storagePolicy" },{ "trigger": "isValidJSONObject) \t class NSJSONSerialization -> Bool" , "contents": "isValidJSONObject(${1:Any}))" },{ "trigger": "string \t String", "contents": "string" },{ "trigger": "one) \t class NSDecimalNumber -> NSDecimalNumber" , "contents": "one(${1:}))" },{ "trigger": "addChild) \t func NSXMLElement -> void" , "contents": "addChild(${1:NSXMLNode}))" },{ "trigger": "stringValue \t String", "contents": "stringValue" },{ "trigger": "enumerateKeysAndObjectsWithOptions) \t func Generator -> Void)" , "contents": "enumerateKeysAndObjectsWithOptions(${1:NSEnumerationOptions}), usingBlock:${2:NSObject}), AnyObject:${3:}), UnsafeMutablePointerObjCBool:${4:}))" },{ "trigger": "setClassName) \t class NSKeyedArchiver -> void" , "contents": "setClassName(${1:String?}), forClass:${2:AnyClass}))" },{ "trigger": "fileHandleWithStandardOutput) \t class NSFileHandle -> NSFileHandle" , "contents": "fileHandleWithStandardOutput(${1:}))" },{ "trigger": "NSEnumerationOptions \t NSEnumerationOptions", "contents": "NSEnumerationOptions" },{ "trigger": "applyTransform) \t func NSMutableString -> Bool" , "contents": "applyTransform(${1:String}), reverse:${2:Bool}), range:${3:NSRange}), updatedRange:${4:NSRangePointer}))" },{ "trigger": "range \t NSRange", "contents": "range" },{ "trigger": "URI \t String", "contents": "URI" },{ "trigger": "requiresSecureCoding \t Bool", "contents": "requiresSecureCoding" },{ "trigger": "allowsNonnumericFormatting \t Bool", "contents": "allowsNonnumericFormatting" },{ "trigger": "NSValue) \t size:" , "contents": "NSValue(${1:NSSize}))" },{ "trigger": "NSOrderedSet) \t array: range: copyItems:" , "contents": "NSOrderedSet(array:${1:[AnyObject]}), range:${2:NSRange}), copyItems:${3:Bool}))" },{ "trigger": "URLCredentialStorage \t NSURLCredentialStorage", "contents": "URLCredentialStorage" },{ "trigger": "removeCachedResponseForDataTask) \t func NSURLCache -> void" , "contents": "removeCachedResponseForDataTask(${1:NSURLSessionDataTask}))" },{ "trigger": "NSXMLParser \t NSXMLParser", "contents": "NSXMLParser" },{ "trigger": "processorCount \t Int", "contents": "processorCount" },{ "trigger": "timeIntervalSinceDate) \t func NSDate -> NSTimeInterval" , "contents": "timeIntervalSinceDate(${1:NSDate}))" },{ "trigger": "NSSocketPort) \t remoteWithTCPPort: host:" , "contents": "NSSocketPort(remoteWithTCPPort:${1:UInt16}), host:${2:String?}))" },{ "trigger": "NSXMLNodePreserveCharacterReferences \t NSXMLNodeOptionRawType", "contents": "NSXMLNodePreserveCharacterReferences" },{ "trigger": "NSComparisonResult \t NSComparisonResult", "contents": "NSComparisonResult" },{ "trigger": "NSTask) \t :" , "contents": "NSTask(${1:}))" },{ "trigger": "systemLocale) \t class NSLocale -> NSLocale" , "contents": "systemLocale(${1:}))" },{ "trigger": "decodeTopLevelObject) \t func NSCoder -> AnyObject?" , "contents": "decodeTopLevelObject(${1:}))" },{ "trigger": "nextDaylightSavingTimeTransitionAfterDate) \t func NSTimeZone -> NSDate?" , "contents": "nextDaylightSavingTimeTransitionAfterDate(${1:NSDate}))" },{ "trigger": "hasPassword \t Bool", "contents": "hasPassword" },{ "trigger": "distantPast) \t class NSDate -> NSDate" , "contents": "distantPast(${1:}))" },{ "trigger": "insertObjects) \t func NSMutableArray -> void" , "contents": "insertObjects(${1:[AnyObject]}), atIndexes:${2:NSIndexSet}))" },{ "trigger": "NSMutableArray) \t objects: count:" , "contents": "NSMutableArray(${1:UnsafePointerAnyObject?}), count:${2:Int}))" },{ "trigger": "sendBeforeDate) \t func NSPortMessage -> Bool" , "contents": "sendBeforeDate(${1:NSDate}))" },{ "trigger": "discreteProgressWithTotalUnitCount) \t class NSProgress -> NSProgress" , "contents": "discreteProgressWithTotalUnitCount(${1:Int64}))" },{ "trigger": "NSData) \t contentsOfURL:" , "contents": "NSData(contentsOfURL:${1:NSURL}))" },{ "trigger": "currentRequest \t NSURLRequest", "contents": "currentRequest" },{ "trigger": "closeWrite) \t func NSURLSessionStreamTask -> void" , "contents": "closeWrite(${1:}))" },{ "trigger": "NSGlobalDomain \t String", "contents": "NSGlobalDomain" },{ "trigger": "namespaceForPrefix) \t func NSXMLElement -> NSXMLNode?" , "contents": "namespaceForPrefix(${1:String}))" },{ "trigger": "setClassName) \t func NSKeyedArchiver -> void" , "contents": "setClassName(${1:String?}), forClass:${2:AnyClass}))" },{ "trigger": "NSThread) \t _:" , "contents": "NSThread(${1:Void - Void}))" },{ "trigger": "URLByAppendingPathComponent) \t func NSURL -> NSURL?" , "contents": "URLByAppendingPathComponent(${1:String}), isDirectory:${2:Bool}))" },{ "trigger": "indexPathByAddingIndex) \t func NSIndexPath -> NSIndexPath" , "contents": "indexPathByAddingIndex(${1:Int}))" },{ "trigger": "NSLocalizedRecoverySuggestionErrorKey \t String", "contents": "NSLocalizedRecoverySuggestionErrorKey" },{ "trigger": "NSURL) \t fileURLWithPath:" , "contents": "NSURL(fileURLWithPath:${1:String}))" },{ "trigger": "NSOrderedSet) \t orderedSet: copyItems:" , "contents": "NSOrderedSet(orderedSet:${1:NSOrderedSet}), copyItems:${2:Bool}))" },{ "trigger": "NSByteCountFormatterUnits \t NSByteCountFormatterUnits", "contents": "NSByteCountFormatterUnits" },{ "trigger": "encodeBycopyObject) \t func NSCoder -> void" , "contents": "encodeBycopyObject(${1:AnyObject?}))" },{ "trigger": "propertyList) \t class NSPropertyListSerialization -> Bool" , "contents": "propertyList(${1:AnyObject}), isValidForFormat:${2:NSPropertyListFormat}))" },{ "trigger": "NSURLSessionTaskPriorityLow \t Float", "contents": "NSURLSessionTaskPriorityLow" },{ "trigger": "decodeObjectForKey) \t func NSCoder -> AnyObject?" , "contents": "decodeObjectForKey(${1:String}))" },{ "trigger": "scheduleInRunLoop) \t func NSPort -> void" , "contents": "scheduleInRunLoop(${1:NSRunLoop}), forMode:${2:String}))" },{ "trigger": "containsObject) \t func Generator -> Bool" , "contents": "containsObject(${1:AnyObject}))" },{ "trigger": "enumerateAttribute) \t func NSAttributedString -> Void)" , "contents": "enumerateAttribute(${1:String}), inRange:${2:NSRange}), options:${3:NSAttributedStringEnumerationOptions}), usingBlock:${4:AnyObject?}), NSRange:${5:}), UnsafeMutablePointerObjCBool:${6:}))" },{ "trigger": "NSHTTPCookie) \t properties:" , "contents": "NSHTTPCookie(${1:[String }))" },{ "trigger": "caseInsensitiveCompare) \t func NSString -> NSComparisonResult" , "contents": "caseInsensitiveCompare(${1:String}))" },{ "trigger": "NSDecimalString) \t func unknown -> String" , "contents": "NSDecimalString(${1:UnsafePointerNSDecimal}), _:${2:AnyObject?}))" },{ "trigger": "NSStreamEvent \t NSStreamEvent", "contents": "NSStreamEvent" },{ "trigger": "NSURLErrorServerCertificateHasBadDate \t Int", "contents": "NSURLErrorServerCertificateHasBadDate" },{ "trigger": "NSNumber) \t char:" , "contents": "NSNumber(char:${1:Int8}))" },{ "trigger": "_conditionallyBridgeFromObject) \t static String -> Bool" , "contents": "_conditionallyBridgeFromObject(${1:NSString}), inout:${2:String?}))" },{ "trigger": "NSURLAuthenticationChallenge \t NSURLAuthenticationChallenge", "contents": "NSURLAuthenticationChallenge" },{ "trigger": "CGPoint \t CGPoint", "contents": "CGPoint" },{ "trigger": "attributeForLocalName) \t func NSXMLElement -> NSXMLNode?" , "contents": "attributeForLocalName(${1:String}), URI:${2:String?}))" },{ "trigger": "copyWithZone) \t func NSURLProtectionSpace -> AnyObject" , "contents": "copyWithZone(${1:NSZone}))" },{ "trigger": "mutableBytes \t UnsafeMutablePointer", "contents": "mutableBytes" },{ "trigger": "isEqualToTimeZone) \t func NSTimeZone -> Bool" , "contents": "isEqualToTimeZone(${1:NSTimeZone}))" },{ "trigger": "NSUserDefaultsDidChangeNotification \t String", "contents": "NSUserDefaultsDidChangeNotification" },{ "trigger": "indexLessThanOrEqualToIndex) \t func NSIndexSet -> Int" , "contents": "indexLessThanOrEqualToIndex(${1:Int}))" },{ "trigger": "NSOSStatusErrorDomain \t String", "contents": "NSOSStatusErrorDomain" },{ "trigger": "NSMutableData) \t :" , "contents": "NSMutableData(${1:}))" },{ "trigger": "_conditionallyBridgeFromObject) \t static Bool -> Bool" , "contents": "_conditionallyBridgeFromObject(${1:NSNumber}), inout:${2:Bool?}))" },{ "trigger": "NSSortDescriptor) \t key: ascending: comparator:" , "contents": "NSSortDescriptor(${1:String?}), ascending:${2:Bool}), comparator:${3:NSComparator}))" },{ "trigger": "NSLocaleMeasurementSystem \t String", "contents": "NSLocaleMeasurementSystem" },{ "trigger": "compare) \t func NSString -> NSComparisonResult" , "contents": "compare(${1:String}))" },{ "trigger": "NSCachedURLResponse) \t coder:" , "contents": "NSCachedURLResponse(coder:${1:NSCoder}))" },{ "trigger": "firstObjectCommonWithArray) \t func Generator -> AnyObject?" , "contents": "firstObjectCommonWithArray(${1:[AnyObject]}))" },{ "trigger": "generate) \t func NSEnumerator -> Generator" , "contents": "generate(${1:}))" },{ "trigger": "pathExtension \t String", "contents": "pathExtension" },{ "trigger": "reverseObjectEnumerator) \t func Generator -> NSEnumerator" , "contents": "reverseObjectEnumerator(${1:}))" },{ "trigger": "copyWithZone) \t func NSIndexSet -> AnyObject" , "contents": "copyWithZone(${1:NSZone}))" },{ "trigger": "URLByDeletingLastPathComponent \t NSURL", "contents": "URLByDeletingLastPathComponent" },{ "trigger": "supportsSecureCoding) \t func NSCalendar -> Bool" , "contents": "supportsSecureCoding(${1:}))" },{ "trigger": "_bridgeToObject) \t func Array -> NSArray" , "contents": "_bridgeToObject(${1:}))" },{ "trigger": "removeObjectForKey) \t func NSMutableDictionary -> void" , "contents": "removeObjectForKey(${1:AnyObject}))" },{ "trigger": "integerValue \t Int", "contents": "integerValue" },{ "trigger": "NSMessagePort \t NSMessagePort", "contents": "NSMessagePort" },{ "trigger": "decodeDataObject) \t func NSCoder -> NSData?" , "contents": "decodeDataObject(${1:}))" },{ "trigger": "capitalizedStringWithLocale) \t func String -> String" , "contents": "capitalizedStringWithLocale(${1:NSLocale?}))" },{ "trigger": "NSTimeZone) \t coder:" , "contents": "NSTimeZone(coder:${1:NSCoder}))" },{ "trigger": "encodeRootObject) \t func NSCoder -> void" , "contents": "encodeRootObject(${1:AnyObject}))" },{ "trigger": "readInBackgroundAndNotifyForModes) \t func NSFileHandle -> void" , "contents": "readInBackgroundAndNotifyForModes(${1:[String]?}))" },{ "trigger": "NSHTTPURLResponse) \t coder:" , "contents": "NSHTTPURLResponse(coder:${1:NSCoder}))" },{ "trigger": "readToEndOfFileInBackgroundAndNotify) \t func NSFileHandle -> void" , "contents": "readToEndOfFileInBackgroundAndNotify(${1:}))" },{ "trigger": "NSXMLElement) \t name:" , "contents": "NSXMLElement(${1:String}))" },{ "trigger": "NSURLRequest) \t URL:" , "contents": "NSURLRequest(${1:NSURL}))" },{ "trigger": "NSURLCredential) \t trust:" , "contents": "NSURLCredential(${1:SecTrust}))" },{ "trigger": "indexOfObject) \t func NSOrderedSet -> Int" , "contents": "indexOfObject(${1:AnyObject}))" },{ "trigger": "hour \t Int", "contents": "hour" },{ "trigger": "totalCostLimit \t Int", "contents": "totalCostLimit" },{ "trigger": "NSOutputStream) \t URL: append:" , "contents": "NSOutputStream(URL:${1:NSURL}), append:${2:Bool}))" },{ "trigger": "edgeInsetsValue \t NSEdgeInsets", "contents": "edgeInsetsValue" },{ "trigger": "acceptConnectionInBackgroundAndNotify) \t func NSFileHandle -> void" , "contents": "acceptConnectionInBackgroundAndNotify(${1:}))" },{ "trigger": "objectByApplyingXSLT) \t func NSXMLDocument -> AnyObject" , "contents": "objectByApplyingXSLT(${1:NSData}), arguments:${2:[String }))" },{ "trigger": "NSHTTPCookieExpires \t String", "contents": "NSHTTPCookieExpires" },{ "trigger": "encodeWithCoder) \t func NSPredicate -> void" , "contents": "encodeWithCoder(${1:NSCoder}))" },{ "trigger": "NSLocaleAlternateQuotationBeginDelimiterKey \t String", "contents": "NSLocaleAlternateQuotationBeginDelimiterKey" },{ "trigger": "NSPortMessage) \t sendPort: receivePort: components:" , "contents": "NSPortMessage(${1:NSPort?}), receivePort:${2:NSPort?}), components:${3:[AnyObject]?}))" },{ "trigger": "filteredArrayUsingPredicate) \t func NSArray -> [AnyObject]" , "contents": "filteredArrayUsingPredicate(${1:NSPredicate}))" },{ "trigger": "scanHexInt) \t func NSScanner -> Bool" , "contents": "scanHexInt(${1:UnsafeMutablePointerUInt32}))" },{ "trigger": "valueForHTTPHeaderField) \t func NSURLRequest -> String?" , "contents": "valueForHTTPHeaderField(${1:String}))" },{ "trigger": "NSString \t NSString", "contents": "NSString" },{ "trigger": "copyWithZone) \t func NSURLComponents -> AnyObject" , "contents": "copyWithZone(${1:NSZone}))" },{ "trigger": "standardInput \t AnyObject", "contents": "standardInput" },{ "trigger": "expressionForAnyKey) \t class NSExpression -> NSExpression" , "contents": "expressionForAnyKey(${1:}))" },{ "trigger": "defaultBehavior) \t class NSDecimalNumber -> NSDecimalNumberBehaviors" , "contents": "defaultBehavior(${1:}))" },{ "trigger": "NSURLComponents) \t string:" , "contents": "NSURLComponents(string:${1:String}))" },{ "trigger": "copyWithZone) \t func NSTimeZone -> AnyObject" , "contents": "copyWithZone(${1:NSZone}))" },{ "trigger": "getStreamsToHostWithName) \t class NSStream -> void" , "contents": "getStreamsToHostWithName(${1:String}), port:${2:Int}), inputStream:${3:AutoreleasingUnsafeMutablePointerNSInputStream?}), outputStream:${4:AutoreleasingUnsafeMutablePointerNSOutputStream?}))" },{ "trigger": "NSMutableOrderedSet \t NSMutableOrderedSet", "contents": "NSMutableOrderedSet" },{ "trigger": "NSPortDidBecomeInvalidNotification \t String", "contents": "NSPortDidBecomeInvalidNotification" },{ "trigger": "localizedAdditionalDescription \t String", "contents": "localizedAdditionalDescription" },{ "trigger": "run) \t func NSRunLoop -> void" , "contents": "run(${1:}))" },{ "trigger": "copyWithZone) \t func NSURLSessionConfiguration -> AnyObject" , "contents": "copyWithZone(${1:NSZone}))" },{ "trigger": "NSMutableSet) \t capacity:" , "contents": "NSMutableSet(capacity:${1:Int}))" },{ "trigger": "resultByAdjustingRangesWithOffset) \t func NSTextCheckingResult -> NSTextCheckingResult" , "contents": "resultByAdjustingRangesWithOffset(${1:Int}))" },{ "trigger": "NSFileHFSTypeCode \t String", "contents": "NSFileHFSTypeCode" },{ "trigger": "NSHTTPCookieOriginURL \t String", "contents": "NSHTTPCookieOriginURL" },{ "trigger": "NSLocaleScriptCode \t String", "contents": "NSLocaleScriptCode" },{ "trigger": "launchPath \t String", "contents": "launchPath" },{ "trigger": "MIMEType \t String", "contents": "MIMEType" },{ "trigger": "backgroundSessionConfigurationWithIdentifier) \t class NSURLSessionConfiguration -> NSURLSessionConfiguration" , "contents": "backgroundSessionConfigurationWithIdentifier(${1:String}))" },{ "trigger": "address \t String", "contents": "address" },{ "trigger": "NSMutableString) \t characters: length:" , "contents": "NSMutableString(${1:UnsafePointerunichar}), length:${2:Int}))" },{ "trigger": "requestCachePolicy \t NSURLRequestCachePolicy", "contents": "requestCachePolicy" },{ "trigger": "symbolCharacterSet) \t class NSCharacterSet -> NSCharacterSet" , "contents": "symbolCharacterSet(${1:}))" },{ "trigger": "JSONObjectWithData) \t class NSJSONSerialization -> Any" , "contents": "JSONObjectWithData(${1:NSData}), options:${2:NSJSONReadingOptions}))" },{ "trigger": "NSProgressFileOperationKindDownloading \t String", "contents": "NSProgressFileOperationKindDownloading" },{ "trigger": "localizedStandardCompare) \t func NSString -> NSComparisonResult" , "contents": "localizedStandardCompare(${1:String}))" },{ "trigger": "isSubsetOfSet) \t func NSOrderedSet -> Bool" , "contents": "isSubsetOfSet(${1:SetNSObject}))" },{ "trigger": "decodePropertyList) \t func NSCoder -> AnyObject?" , "contents": "decodePropertyList(${1:}))" },{ "trigger": "sleepForTimeInterval) \t class NSThread -> void" , "contents": "sleepForTimeInterval(${1:NSTimeInterval}))" },{ "trigger": "enumerateObjectsAtIndexes) \t func Generator -> Void)" , "contents": "enumerateObjectsAtIndexes(${1:NSIndexSet}), options:${2:NSEnumerationOptions}), usingBlock:${3:AnyObject}), Int:${4:}), UnsafeMutablePointerObjCBool:${5:}))" },{ "trigger": "taskIdentifier \t Int", "contents": "taskIdentifier" },{ "trigger": "minimumDaysInFirstWeek \t Int", "contents": "minimumDaysInFirstWeek" },{ "trigger": "NSURLErrorBadServerResponse \t Int", "contents": "NSURLErrorBadServerResponse" },{ "trigger": "alwaysShowsDecimalSeparator \t Bool", "contents": "alwaysShowsDecimalSeparator" },{ "trigger": "decodeSizeForKey) \t func NSCoder -> NSSize" , "contents": "decodeSizeForKey(${1:String}))" },{ "trigger": "supportsSecureCoding) \t static NSLocale -> Bool" , "contents": "supportsSecureCoding(${1:}))" },{ "trigger": "NSPersonNameComponentGivenName \t String", "contents": "NSPersonNameComponentGivenName" },{ "trigger": "cancel) \t func NSOperation -> void" , "contents": "cancel(${1:}))" },{ "trigger": "pathExtension \t :", "contents": "pathExtension" },{ "trigger": "numberOfCaptureGroups \t Int", "contents": "numberOfCaptureGroups" },{ "trigger": "lockBeforeDate) \t func NSConditionLock -> Bool" , "contents": "lockBeforeDate(${1:NSDate}))" },{ "trigger": "NSAttributedString) \t coder:" , "contents": "NSAttributedString(coder:${1:NSCoder}))" },{ "trigger": "stringByApplyingTransform) \t func NSString -> String?" , "contents": "stringByApplyingTransform(${1:String}), reverse:${2:Bool}))" },{ "trigger": "launchedTaskWithLaunchPath) \t class NSTask -> NSTask" , "contents": "launchedTaskWithLaunchPath(${1:String}), arguments:${2:[String]}))" },{ "trigger": "encodeWithCoder) \t func NSLocale -> void" , "contents": "encodeWithCoder(${1:NSCoder}))" },{ "trigger": "NSScanner) \t string:" , "contents": "NSScanner(${1:String}))" },{ "trigger": "NSMatchingOptions) \t rawValue:" , "contents": "NSMatchingOptions(${1:UInt}))" },{ "trigger": "supportsSecureCoding) \t static Generator -> Bool" , "contents": "supportsSecureCoding(${1:}))" },{ "trigger": "NSHTTPCookie \t NSHTTPCookie", "contents": "NSHTTPCookie" },{ "trigger": "localizedStringForKey) \t func NSBundle -> String" , "contents": "localizedStringForKey(${1:String}), value:${2:String?}), table:${3:String?}))" },{ "trigger": "forFoodEnergyUse \t Bool", "contents": "forFoodEnergyUse" },{ "trigger": "increaseLengthBy) \t func NSMutableData -> void" , "contents": "increaseLengthBy(${1:Int}))" },{ "trigger": "NSStreamSocketSSLErrorDomain \t String", "contents": "NSStreamSocketSSLErrorDomain" },{ "trigger": "NSFileHandle \t NSFileHandle", "contents": "NSFileHandle" },{ "trigger": "NSXMLParserErrorDomain \t String", "contents": "NSXMLParserErrorDomain" },{ "trigger": "scanInteger) \t func NSScanner -> Bool" , "contents": "scanInteger(${1:UnsafeMutablePointerInt}))" },{ "trigger": "Generator) \t array:" , "contents": "Generator(${1:[AnyObject]}))" },{ "trigger": "supportsSecureCoding) \t func NSURLResponse -> Bool" , "contents": "supportsSecureCoding(${1:}))" },{ "trigger": "NSMutableDictionary) \t capacity:" , "contents": "NSMutableDictionary(capacity:${1:Int}))" },{ "trigger": "keysSortedByValueUsingComparator) \t func Generator -> [AnyObject]" , "contents": "keysSortedByValueUsingComparator(${1:NSComparator}))" },{ "trigger": "NSNumber) \t double:" , "contents": "NSNumber(double:${1:Double}))" },{ "trigger": "descriptionWithLocale) \t func NSDate -> String" , "contents": "descriptionWithLocale(${1:AnyObject?}))" },{ "trigger": "canonicalRequestForRequest) \t class NSURLProtocol -> NSURLRequest" , "contents": "canonicalRequestForRequest(${1:NSURLRequest}))" },{ "trigger": "insertChild) \t func NSXMLElement -> void" , "contents": "insertChild(${1:NSXMLNode}), atIndex:${2:Int}))" },{ "trigger": "supportsSecureCoding) \t func NSCachedURLResponse -> Bool" , "contents": "supportsSecureCoding(${1:}))" },{ "trigger": "trueExpression \t NSExpression", "contents": "trueExpression" },{ "trigger": "rootElement) \t func NSXMLDocument -> NSXMLElement?" , "contents": "rootElement(${1:}))" },{ "trigger": "enumeratorAtPath) \t func NSFileManager -> NSDirectoryEnumerator?" , "contents": "enumeratorAtPath(${1:String}))" },{ "trigger": "rangeOfUnit) \t func NSCalendar -> NSRange" , "contents": "rangeOfUnit(${1:NSCalendarUnit}), inUnit:${2:NSCalendarUnit}), forDate:${3:NSDate}))" },{ "trigger": "currentMemoryUsage \t Int", "contents": "currentMemoryUsage" },{ "trigger": "NSURLErrorServerCertificateNotYetValid \t Int", "contents": "NSURLErrorServerCertificateNotYetValid" },{ "trigger": "NSXMLDTD) \t data: options:" , "contents": "NSXMLDTD(${1:NSData}), options:${2:Int}))" },{ "trigger": "scanUnsignedLongLong) \t func NSScanner -> UInt64?" , "contents": "scanUnsignedLongLong(${1:}))" },{ "trigger": "setValue) \t func NSMutableURLRequest -> void" , "contents": "setValue(${1:String?}), forHTTPHeaderField:${2:String}))" },{ "trigger": "addIndexesInRange) \t func NSMutableIndexSet -> void" , "contents": "addIndexesInRange(${1:NSRange}))" },{ "trigger": "NSDataReadingOptions) \t rawValue:" , "contents": "NSDataReadingOptions(${1:UInt}))" },{ "trigger": "supportsSecureCoding) \t static NSDate -> Bool" , "contents": "supportsSecureCoding(${1:}))" },{ "trigger": "URLForDirectory) \t func NSFileManager -> NSURL" , "contents": "URLForDirectory(${1:NSSearchPathDirectory}), inDomain:${2:NSSearchPathDomainMask}), appropriateForURL:${3:NSURL?}), create:${4:Bool}))" },{ "trigger": "scanHexFloat) \t func NSScanner -> Float?" , "contents": "scanHexFloat(${1:}))" },{ "trigger": "copyWithZone) \t func NSString -> AnyObject" , "contents": "copyWithZone(${1:NSZone}))" },{ "trigger": "terminationStatus \t Int", "contents": "terminationStatus" },{ "trigger": "offsetInFile \t UInt", "contents": "offsetInFile" },{ "trigger": "principalClass \t AnyClass", "contents": "principalClass" },{ "trigger": "encodeWithCoder) \t func NSCharacterSet -> void" , "contents": "encodeWithCoder(${1:NSCoder}))" },{ "trigger": "NSDirectoryEnumerator \t NSDirectoryEnumerator", "contents": "NSDirectoryEnumerator" },{ "trigger": "NSOperationQueue \t NSOperationQueue", "contents": "NSOperationQueue" },{ "trigger": "supportsSecureCoding) \t func NSPersonNameComponents -> Bool" , "contents": "supportsSecureCoding(${1:}))" },{ "trigger": "hasDirectoryPath \t Bool", "contents": "hasDirectoryPath" },{ "trigger": "external \t Bool", "contents": "external" },{ "trigger": "NSPipe \t NSPipe", "contents": "NSPipe" },{ "trigger": "scanDouble) \t func NSScanner -> Double?" , "contents": "scanDouble(${1:}))" },{ "trigger": "NSPredicate) \t block: [String:" , "contents": "NSPredicate(${1:AnyObject}), [String:${2:AnyObject]? - Bool}))" },{ "trigger": "NSPropertyListFormat \t NSPropertyListFormat", "contents": "NSPropertyListFormat" },{ "trigger": "setDefaultBehavior) \t class NSDecimalNumber -> void" , "contents": "setDefaultBehavior(${1:NSDecimalNumberBehaviors}))" },{ "trigger": "NSIndexPath \t NSIndexPath", "contents": "NSIndexPath" },{ "trigger": "NSURLErrorTimedOut \t Int", "contents": "NSURLErrorTimedOut" },{ "trigger": "fileExistsAtPath) \t func NSFileManager -> Bool" , "contents": "fileExistsAtPath(${1:String}), isDirectory:${2:UnsafeMutablePointerObjCBool}))" },{ "trigger": "comparisonPredicateModifier \t NSComparisonPredicateModifier", "contents": "comparisonPredicateModifier" },{ "trigger": "scanHexDouble) \t func NSScanner -> Bool" , "contents": "scanHexDouble(${1:UnsafeMutablePointerDouble}))" },{ "trigger": "NSSet) \t set:" , "contents": "NSSet(${1:SetNSObject}))" },{ "trigger": "NSSet) \t objects: count:" , "contents": "NSSet(${1:UnsafePointerAnyObject?}), count:${2:Int}))" },{ "trigger": "NSXMLNodePreserveAttributeOrder \t NSXMLNodeOptionRawType", "contents": "NSXMLNodePreserveAttributeOrder" },{ "trigger": "NSProgressFileOperationKindDecompressingAfterDownloading \t String", "contents": "NSProgressFileOperationKindDecompressingAfterDownloading" },{ "trigger": "compoundPredicateType \t NSCompoundPredicateType", "contents": "compoundPredicateType" },{ "trigger": "replaceCharactersInRange) \t func NSMutableAttributedString -> void" , "contents": "replaceCharactersInRange(${1:NSRange}), withString:${2:String}))" },{ "trigger": "NSStringFromRange) \t func unknown -> String" , "contents": "NSStringFromRange(${1:NSRange}))" },{ "trigger": "fire) \t func NSTimer -> void" , "contents": "fire(${1:}))" },{ "trigger": "NSLocaleQuotationEndDelimiterKey \t String", "contents": "NSLocaleQuotationEndDelimiterKey" },{ "trigger": "enumerateIndexesInRange) \t func NSIndexSet -> Void)" , "contents": "enumerateIndexesInRange(${1:NSRange}), options:${2:NSEnumerationOptions}), usingBlock:${3:Int}), UnsafeMutablePointerObjCBool:${4:}))" },{ "trigger": "tolerance \t NSTimeInterval", "contents": "tolerance" },{ "trigger": "unitStringFromValue) \t func NSEnergyFormatter -> String" , "contents": "unitStringFromValue(${1:Double}), unit:${2:NSEnergyFormatterUnit}))" },{ "trigger": "NSURLErrorCannotParseResponse \t Int", "contents": "NSURLErrorCannotParseResponse" },{ "trigger": "boolValue \t Bool", "contents": "boolValue" },{ "trigger": "percentEncodedUser \t String", "contents": "percentEncodedUser" },{ "trigger": "attributeWithName) \t class NSXMLNode -> AnyObject" , "contents": "attributeWithName(${1:String}), stringValue:${2:String}))" },{ "trigger": "indexOfObject) \t func NSOrderedSet -> Int" , "contents": "indexOfObject(${1:AnyObject}), inSortedRange:${2:NSRange}), options:${3:NSBinarySearchingOptions}), usingComparator:${4:NSComparator}))" },{ "trigger": "currencyDecimalSeparator \t String", "contents": "currencyDecimalSeparator" },{ "trigger": "forPersonHeightUse \t Bool", "contents": "forPersonHeightUse" },{ "trigger": "compare) \t func NSString -> NSComparisonResult" , "contents": "compare(${1:String}), options:${2:NSStringCompareOptions}), range:${3:NSRange}))" },{ "trigger": "NSURLProtectionSpaceFTPProxy \t String", "contents": "NSURLProtectionSpaceFTPProxy" },{ "trigger": "descriptionWithLocale) \t func NSSet -> String" , "contents": "descriptionWithLocale(${1:AnyObject?}))" },{ "trigger": "next) \t func NSEnumerator -> AnyObject?" , "contents": "next(${1:}))" },{ "trigger": "NSURLErrorRequestBodyStreamExhausted \t Int", "contents": "NSURLErrorRequestBodyStreamExhausted" },{ "trigger": "NSFileSystemNodes \t String", "contents": "NSFileSystemNodes" },{ "trigger": "acceptConnectionInBackgroundAndNotifyForModes) \t func NSFileHandle -> void" , "contents": "acceptConnectionInBackgroundAndNotifyForModes(${1:[String]?}))" },{ "trigger": "removeAllObjects) \t func NSMutableOrderedSet -> void" , "contents": "removeAllObjects(${1:}))" },{ "trigger": "isPropertyListError \t Bool", "contents": "isPropertyListError" },{ "trigger": "transformStruct \t NSAffineTransformStruct", "contents": "transformStruct" },{ "trigger": "replaceObjectAtIndex) \t func NSMutableArray -> void" , "contents": "replaceObjectAtIndex(${1:Int}), withObject:${2:AnyObject}))" },{ "trigger": "currentLocale) \t class NSLocale -> NSLocale" , "contents": "currentLocale(${1:}))" },{ "trigger": "appendString) \t func NSMutableString -> void" , "contents": "appendString(${1:String}))" },{ "trigger": "whitespaceCharacterSet) \t class NSCharacterSet -> NSCharacterSet" , "contents": "whitespaceCharacterSet(${1:}))" },{ "trigger": "NSCocoaError \t NSCocoaError", "contents": "NSCocoaError" },{ "trigger": "pathForAuxiliaryExecutable) \t func NSBundle -> String?" , "contents": "pathForAuxiliaryExecutable(${1:String}))" },{ "trigger": "NSDecimalNumber \t NSDecimalNumber", "contents": "NSDecimalNumber" },{ "trigger": "decodeTopLevelObjectForKey) \t func NSCoder -> AnyObject?" , "contents": "decodeTopLevelObjectForKey(${1:String}))" },{ "trigger": "setProperty) \t class NSURLProtocol -> void" , "contents": "setProperty(${1:AnyObject}), forKey:${2:String}), inRequest:${3:NSMutableURLRequest}))" },{ "trigger": "NSIsEmptyRect) \t func unknown -> Bool" , "contents": "NSIsEmptyRect(${1:NSRect}))" },{ "trigger": "allowsKeyedCoding \t Bool", "contents": "allowsKeyedCoding" },{ "trigger": "NSData) \t coder:" , "contents": "NSData(coder:${1:NSCoder}))" },{ "trigger": "NSDate) \t timeInterval: sinceDate:" , "contents": "NSDate(timeInterval:${1:NSTimeInterval}), sinceDate:${2:NSDate}))" },{ "trigger": "encodeWithCoder) \t func NSFormatter -> void" , "contents": "encodeWithCoder(${1:NSCoder}))" },{ "trigger": "NSNumber) \t unsignedLong:" , "contents": "NSNumber(unsignedLong:${1:UInt}))" },{ "trigger": "URLsForResourcesWithExtension) \t class NSBundle -> [NSURL]?" , "contents": "URLsForResourcesWithExtension(${1:String?}), subdirectory:${2:String?}), inBundleWithURL:${3:NSURL}))" },{ "trigger": "decimalValue \t NSDecimal", "contents": "decimalValue" },{ "trigger": "removeItemAtPath) \t func NSFileManager -> void" , "contents": "removeItemAtPath(${1:String}))" },{ "trigger": "objectsAtIndexes) \t func NSOrderedSet -> [AnyObject]{" , "contents": "objectsAtIndexes(${1:NSIndexSet}))" },{ "trigger": "currentRunLoop) \t class NSRunLoop -> NSRunLoop" , "contents": "currentRunLoop(${1:}))" },{ "trigger": "URLByResolvingSymlinksInPath \t NSURL", "contents": "URLByResolvingSymlinksInPath" },{ "trigger": "NSStringEncodingConversionOptions) \t rawValue:" , "contents": "NSStringEncodingConversionOptions(${1:UInt}))" },{ "trigger": "identity \t SecIdentity", "contents": "identity" },{ "trigger": "knownTimeZoneNames) \t class NSTimeZone -> [String]" , "contents": "knownTimeZoneNames(${1:}))" },{ "trigger": "isUserActivityError \t Bool", "contents": "isUserActivityError" },{ "trigger": "resourceIsReachable) \t func NSURL -> Bool" , "contents": "resourceIsReachable(${1:}))" },{ "trigger": "descriptionWithLocale) \t func Generator -> String" , "contents": "descriptionWithLocale(${1:AnyObject?}), indent:${2:Int}))" },{ "trigger": "NSURL) \t fileURLWithPath: relativeToURL:" , "contents": "NSURL(fileURLWithPath:${1:String}), relativeToURL:${2:NSURL?}))" },{ "trigger": "NSDateComponentsFormatter) \t :" , "contents": "NSDateComponentsFormatter(${1:}))" },{ "trigger": "reversedSortDescriptor \t AnyObject", "contents": "reversedSortDescriptor" },{ "trigger": "NSDecimalPower) \t func unknown -> NSCalculationError" , "contents": "NSDecimalPower(${1:UnsafeMutablePointerNSDecimal}), _:${2:UnsafePointerNSDecimal}), _:${3:Int}), _:${4:NSRoundingMode}))" },{ "trigger": "NSFileHandle) \t forReadingFromURL:" , "contents": "NSFileHandle(forReadingFromURL:${1:NSURL}))" },{ "trigger": "NSDecimalCompare) \t func unknown -> NSComparisonResult" , "contents": "NSDecimalCompare(${1:UnsafePointerNSDecimal}), _:${2:UnsafePointerNSDecimal}))" },{ "trigger": "notationName \t String", "contents": "notationName" },{ "trigger": "NSHTTPCookieManagerCookiesChangedNotification \t String", "contents": "NSHTTPCookieManagerCookiesChangedNotification" },{ "trigger": "requestIsCacheEquivalent) \t class NSURLProtocol -> Bool" , "contents": "requestIsCacheEquivalent(${1:NSURLRequest}), toRequest:${2:NSURLRequest}))" },{ "trigger": "NSCalculationError \t NSCalculationError", "contents": "NSCalculationError" },{ "trigger": "isValidDateInCalendar) \t func NSDateComponents -> Bool" , "contents": "isValidDateInCalendar(${1:NSCalendar}))" },{ "trigger": "deleteCookie) \t func NSHTTPCookieStorage -> void" , "contents": "deleteCookie(${1:NSHTTPCookie}))" },{ "trigger": "NSNotificationCoalescing \t NSNotificationCoalescing", "contents": "NSNotificationCoalescing" },{ "trigger": "sortedArrayHint \t NSData", "contents": "sortedArrayHint" },{ "trigger": "timeZone \t NSTimeZone", "contents": "timeZone" },{ "trigger": "NSFormatter) \t :" , "contents": "NSFormatter(${1:}))" },{ "trigger": "NSString) \t data: encoding:" , "contents": "NSString(${1:NSData}), encoding:${2:UInt}))" },{ "trigger": "NSRectToCGRect) \t func unknown -> CGRect" , "contents": "NSRectToCGRect(${1:NSRect}))" },{ "trigger": "NSPortMessage \t NSPortMessage", "contents": "NSPortMessage" },{ "trigger": "indexOfObject) \t func Generator -> Int" , "contents": "indexOfObject(${1:AnyObject}), inRange:${2:NSRange}))" },{ "trigger": "sortedArrayUsingDescriptors) \t func NSArray -> [AnyObject]" , "contents": "sortedArrayUsingDescriptors(${1:[NSSortDescriptor]}))" },{ "trigger": "NSOutputStream \t NSOutputStream", "contents": "NSOutputStream" },{ "trigger": "compare) \t func NSString -> NSComparisonResult" , "contents": "compare(${1:String}), options:${2:NSStringCompareOptions}))" },{ "trigger": "decimalNumberByMultiplyingBy) \t func NSDecimalNumber -> NSDecimalNumber" , "contents": "decimalNumberByMultiplyingBy(${1:NSDecimalNumber}))" },{ "trigger": "NSEnergyFormatter) \t coder:" , "contents": "NSEnergyFormatter(${1:NSCoder}))" },{ "trigger": "width \t CGFloat", "contents": "width" },{ "trigger": "NSMutableString) \t stringLiteral:" , "contents": "NSMutableString(stringLiteral:${1:StaticString}))" },{ "trigger": "URLPasswordAllowedCharacterSet) \t class NSCharacterSet -> NSCharacterSet" , "contents": "URLPasswordAllowedCharacterSet(${1:}))" },{ "trigger": "NSURLErrorNotConnectedToInternet \t Int", "contents": "NSURLErrorNotConnectedToInternet" },{ "trigger": "_conditionallyBridgeFromObject) \t static Set -> Bool" , "contents": "_conditionallyBridgeFromObject(${1:NSSet}), inout:${2:Set?}))" },{ "trigger": "NSXMLDTD \t NSXMLDTD", "contents": "NSXMLDTD" },{ "trigger": "bundleIdentifier \t String", "contents": "bundleIdentifier" },{ "trigger": "lockWhenCondition) \t func NSConditionLock -> void" , "contents": "lockWhenCondition(${1:Int}))" },{ "trigger": "NSFileHandle) \t forUpdatingURL:" , "contents": "NSFileHandle(forUpdatingURL:${1:NSURL}))" },{ "trigger": "countOfBytesReceived \t Int", "contents": "countOfBytesReceived" },{ "trigger": "XMLDataWithOptions) \t func NSXMLDocument -> NSData" , "contents": "XMLDataWithOptions(${1:Int}))" },{ "trigger": "objectForKey) \t func NSLocale -> AnyObject?" , "contents": "objectForKey(${1:String}))" },{ "trigger": "NSURLErrorCannotWriteToFile \t Int", "contents": "NSURLErrorCannotWriteToFile" },{ "trigger": "NSDateFormatter) \t coder:" , "contents": "NSDateFormatter(${1:NSCoder}))" },{ "trigger": "bridge) \t func Array -> NSArray" , "contents": "bridge(${1:}))" },{ "trigger": "stringByReplacingOccurrencesOfString) \t func NSString -> String" , "contents": "stringByReplacingOccurrencesOfString(${1:String}), withString:${2:String}))" },{ "trigger": "usesSignificantDigits \t Bool", "contents": "usesSignificantDigits" },{ "trigger": "NSLocaleCurrencyCode \t String", "contents": "NSLocaleCurrencyCode" },{ "trigger": "NSAttributedString) \t attributedString:" , "contents": "NSAttributedString(attributedString:${1:NSAttributedString}))" },{ "trigger": "removeCredential) \t func NSURLCredentialStorage -> void" , "contents": "removeCredential(${1:NSURLCredential}), forProtectionSpace:${2:NSURLProtectionSpace}), options:${3:[String }))" },{ "trigger": "NSMutableSet) \t coder:" , "contents": "NSMutableSet(${1:NSCoder}))" },{ "trigger": "NSWidth) \t func unknown -> CGFloat" , "contents": "NSWidth(${1:NSRect}))" },{ "trigger": "contentsOfDirectoryAtURL) \t func NSFileManager -> [NSURL]" , "contents": "contentsOfDirectoryAtURL(${1:NSURL}), includingPropertiesForKeys:${2:[String]?}), options:${3:NSDirectoryEnumerationOptions}))" },{ "trigger": "runUntilDate) \t func NSRunLoop -> void" , "contents": "runUntilDate(${1:NSDate}))" },{ "trigger": "shiftIndexesStartingAtIndex) \t func NSMutableIndexSet -> void" , "contents": "shiftIndexesStartingAtIndex(${1:Int}), by:${2:Int}))" },{ "trigger": "rangeOfString) \t func NSString -> NSRange" , "contents": "rangeOfString(${1:String}), options:${2:NSStringCompareOptions}))" },{ "trigger": "dataRepresentation \t NSData", "contents": "dataRepresentation" },{ "trigger": "containsIndexes) \t func NSIndexSet -> Bool" , "contents": "containsIndexes(${1:NSIndexSet}))" },{ "trigger": "removeIndex) \t func NSMutableIndexSet -> void" , "contents": "removeIndex(${1:Int}))" },{ "trigger": "negativeInfinitySymbol \t String", "contents": "negativeInfinitySymbol" },{ "trigger": "getBoundStreamsWithBufferSize) \t class NSStream -> void" , "contents": "getBoundStreamsWithBufferSize(${1:Int}), inputStream:${2:AutoreleasingUnsafeMutablePointerNSInputStream?}), outputStream:${3:AutoreleasingUnsafeMutablePointerNSOutputStream?}))" },{ "trigger": "NSFileHandle) \t fileDescriptor:" , "contents": "NSFileHandle(fileDescriptor:${1:Int32}))" },{ "trigger": "replaceObjectsAtIndexes) \t func NSMutableArray -> void" , "contents": "replaceObjectsAtIndexes(${1:NSIndexSet}), withObjects:${2:[AnyObject]}))" },{ "trigger": "getBuffer) \t func NSInputStream -> Bool" , "contents": "getBuffer(${1:UnsafeMutablePointerUnsafeMutablePointerUInt8}), length:${2:UnsafeMutablePointerInt}))" },{ "trigger": "cookiesWithResponseHeaderFields) \t class NSHTTPCookie -> [NSHTTPCookie]" , "contents": "cookiesWithResponseHeaderFields(${1:[String }), forURL:${2:NSURL}))" },{ "trigger": "_bridgeToObject) \t func String -> NSString" , "contents": "_bridgeToObject(${1:}))" },{ "trigger": "encodeWithCoder) \t func NSTimeZone -> void" , "contents": "encodeWithCoder(${1:NSCoder}))" },{ "trigger": "isXPCConnectionError \t Bool", "contents": "isXPCConnectionError" },{ "trigger": "NSFileHandle) \t forReadingAtPath:" , "contents": "NSFileHandle(forReadingAtPath:${1:String}))" },{ "trigger": "NSMakeRange) \t func unknown -> NSRange" , "contents": "NSMakeRange(${1:Int}), _:${2:Int}))" },{ "trigger": "hasPrefix) \t func NSString -> Bool" , "contents": "hasPrefix(${1:String}))" },{ "trigger": "maximum \t NSNumber", "contents": "maximum" },{ "trigger": "NSURLErrorCannotDecodeContentData \t Int", "contents": "NSURLErrorCannotDecodeContentData" },{ "trigger": "NSURLErrorCannotRemoveFile \t Int", "contents": "NSURLErrorCannotRemoveFile" },{ "trigger": "addObserverForName) \t func NSNotificationCenter -> Void)" , "contents": "addObserverForName(${1:String?}), object:${2:AnyObject?}), queue:${3:NSOperationQueue?}), usingBlock:${4:NSNotification - Void}))" },{ "trigger": "NSNumber) \t int:" , "contents": "NSNumber(int:${1:Int32}))" },{ "trigger": "illegalCharacterSet) \t class NSCharacterSet -> NSCharacterSet" , "contents": "illegalCharacterSet(${1:}))" },{ "trigger": "NSURLErrorFailingURLStringErrorKey \t String", "contents": "NSURLErrorFailingURLStringErrorKey" },{ "trigger": "intersectsOrderedSet) \t func NSOrderedSet -> Bool" , "contents": "intersectsOrderedSet(${1:NSOrderedSet}))" },{ "trigger": "attribute) \t func NSAttributedString -> AnyObject?" , "contents": "attribute(${1:String}), atIndex:${2:Int}), longestEffectiveRange:${3:NSRangePointer}), inRange:${4:NSRange}))" },{ "trigger": "keysOfEntriesPassingTest) \t func Generator -> Bool)" , "contents": "keysOfEntriesPassingTest(${1:AnyObject}), AnyObject:${2:}), UnsafeMutablePointerObjCBool:${3:}))" },{ "trigger": "localizedCapitalizedString \t String", "contents": "localizedCapitalizedString" },{ "trigger": "NSString) \t contentsOfURL: encoding:" , "contents": "NSString(contentsOfURL:${1:NSURL}), encoding:${2:UInt}))" },{ "trigger": "NSXMLNodePreserveCDATA \t NSXMLNodeOptionRawType", "contents": "NSXMLNodePreserveCDATA" },{ "trigger": "NSRectEdge) \t rectEdge:" , "contents": "NSRectEdge(${1:CGRectEdge}))" },{ "trigger": "absoluteString \t String", "contents": "absoluteString" },{ "trigger": "sortedArrayUsingDescriptors) \t func NSOrderedSet -> [AnyObject]" , "contents": "sortedArrayUsingDescriptors(${1:[NSSortDescriptor]}))" },{ "trigger": "_bridgeToObject) \t func Set -> NSSet" , "contents": "_bridgeToObject(${1:}))" },{ "trigger": "moveItemAtPath) \t func NSFileManager -> void" , "contents": "moveItemAtPath(${1:String}), toPath:${2:String}))" },{ "trigger": "NSURLProtectionSpaceHTTPSProxy \t String", "contents": "NSURLProtectionSpaceHTTPSProxy" },{ "trigger": "rangeOfUnit) \t func NSCalendar -> NSDateInterval?" , "contents": "rangeOfUnit(${1:NSCalendarUnit}), forDate:${2:NSDate}))" },{ "trigger": "NSData) \t base64EncodedString: options:" , "contents": "NSData(base64EncodedString:${1:String}), options:${2:NSDataBase64DecodingOptions}))" },{ "trigger": "encodeWithCoder) \t func NSData -> void" , "contents": "encodeWithCoder(${1:NSCoder}))" },{ "trigger": "lock) \t func NSConditionLock -> void" , "contents": "lock(${1:}))" },{ "trigger": "encodeWithCoder) \t func NSNull -> void" , "contents": "encodeWithCoder(${1:NSCoder}))" },{ "trigger": "NSUnderlyingErrorKey \t String", "contents": "NSUnderlyingErrorKey" },{ "trigger": "HTTPMaximumConnectionsPerHost \t Int", "contents": "HTTPMaximumConnectionsPerHost" },{ "trigger": "NSURL) \t string:" , "contents": "NSURL(string:${1:String}))" },{ "trigger": "NSDecimalNumberHandler) \t roundingMode: scale: raiseOnExactness: raiseOnOverflow: raiseOnUnderflow: raiseOnDivideByZero:" , "contents": "NSDecimalNumberHandler(${1:NSRoundingMode}), scale:${2:Int16}), raiseOnExactness:${3:Bool}), raiseOnOverflow:${4:Bool}), raiseOnUnderflow:${5:Bool}), raiseOnDivideByZero:${6:Bool}))" },{ "trigger": "writeToFile) \t func NSData -> Bool" , "contents": "writeToFile(${1:String}), atomically:${2:Bool}))" },{ "trigger": "NSXMLNode) \t kind:" , "contents": "NSXMLNode(${1:NSXMLNodeKind}))" },{ "trigger": "NSData) \t bytesNoCopy: length: freeWhenDone:" , "contents": "NSData(bytesNoCopy:${1:UnsafeMutablePointerVoid}), length:${2:Int}), freeWhenDone:${3:Bool}))" },{ "trigger": "operationCount \t Int", "contents": "operationCount" },{ "trigger": "localizedDescription \t String", "contents": "localizedDescription" },{ "trigger": "copyWithZone) \t func NSExpression -> AnyObject" , "contents": "copyWithZone(${1:NSZone}))" },{ "trigger": "NSURLErrorFileDoesNotExist \t Int", "contents": "NSURLErrorFileDoesNotExist" },{ "trigger": "NSCalendarIdentifierRepublicOfChina \t String", "contents": "NSCalendarIdentifierRepublicOfChina" },{ "trigger": "stringByAppendingString) \t func NSString -> String" , "contents": "stringByAppendingString(${1:String}))" },{ "trigger": "positivePrefix \t String", "contents": "positivePrefix" },{ "trigger": "currencyCode \t String", "contents": "currencyCode" },{ "trigger": "lastIndex \t Int", "contents": "lastIndex" },{ "trigger": "NSCountedSet) \t coder:" , "contents": "NSCountedSet(${1:NSCoder}))" },{ "trigger": "NSConditionLock \t NSConditionLock", "contents": "NSConditionLock" },{ "trigger": "rangeOfString) \t func NSString -> NSRange" , "contents": "rangeOfString(${1:String}), options:${2:NSStringCompareOptions}), range:${3:NSRange}))" },{ "trigger": "invalidate) \t func NSTimer -> void" , "contents": "invalidate(${1:}))" },{ "trigger": "allowsCellularAccess \t Bool", "contents": "allowsCellularAccess" },{ "trigger": "elementsForName) \t func NSXMLElement -> [NSXMLElement]" , "contents": "elementsForName(${1:String}))" },{ "trigger": "unknown) \t _bridgedNSError:" , "contents": "unknown(${1:NSError}))" },{ "trigger": "NSRange) \t _:" , "contents": "NSRange(_:${1:RangeInt}))" },{ "trigger": "lock) \t func NSLock -> void" , "contents": "lock(${1:}))" },{ "trigger": "setAttributesAsDictionary) \t func NSXMLElement -> void" , "contents": "setAttributesAsDictionary(${1:[NSObject }))" },{ "trigger": "rootDocument \t NSXMLDocument", "contents": "rootDocument" },{ "trigger": "weekday \t Int", "contents": "weekday" },{ "trigger": "copyWithZone) \t func NSDate -> AnyObject" , "contents": "copyWithZone(${1:NSZone}))" },{ "trigger": "NSFileSize \t String", "contents": "NSFileSize" },{ "trigger": "copyItemAtPath) \t func NSFileManager -> void" , "contents": "copyItemAtPath(${1:String}), toPath:${2:String}))" },{ "trigger": "NSDecimalNumber) \t decimal:" , "contents": "NSDecimalNumber(decimal:${1:NSDecimal}))" },{ "trigger": "NSOrderedSet) \t orderedSet:" , "contents": "NSOrderedSet(orderedSet:${1:NSOrderedSet}))" },{ "trigger": "query \t String", "contents": "query" },{ "trigger": "NSValue) \t coder:" , "contents": "NSValue(coder:${1:NSCoder}))" },{ "trigger": "sortedArrayUsingDescriptors) \t func NSSet -> [AnyObject]" , "contents": "sortedArrayUsingDescriptors(${1:[NSSortDescriptor]}))" },{ "trigger": "childCount \t Int", "contents": "childCount" },{ "trigger": "firstObject \t AnyObject", "contents": "firstObject" },{ "trigger": "replaceChildAtIndex) \t func NSXMLDocument -> void" , "contents": "replaceChildAtIndex(${1:Int}), withNode:${2:NSXMLNode}))" },{ "trigger": "encodePropertyList) \t func NSCoder -> void" , "contents": "encodePropertyList(${1:AnyObject}))" },{ "trigger": "stringArrayForKey) \t func NSUserDefaults -> [String]?" , "contents": "stringArrayForKey(${1:String}))" },{ "trigger": "usesGroupingSeparator \t Bool", "contents": "usesGroupingSeparator" },{ "trigger": "publicID \t String", "contents": "publicID" },{ "trigger": "dataTaskWithRequest) \t func NSURLSession -> Void)" , "contents": "dataTaskWithRequest(${1:NSURLRequest}), completionHandler:${2:NSData?}), NSURLResponse?:${3:}), NSError?:${4:}))" },{ "trigger": "NSZeroRect \t NSRect", "contents": "NSZeroRect" },{ "trigger": "indexOfObject) \t func Generator -> Int" , "contents": "indexOfObject(${1:AnyObject}))" },{ "trigger": "decimalDigitCharacterSet) \t class NSCharacterSet -> NSCharacterSet" , "contents": "decimalDigitCharacterSet(${1:}))" },{ "trigger": "NSRecursiveLock) \t :" , "contents": "NSRecursiveLock(${1:}))" },{ "trigger": "objectForKey) \t func Generator -> AnyObject?" , "contents": "objectForKey(${1:AnyObject}))" },{ "trigger": "copyWithZone) \t func NSAffineTransform -> AnyObject" , "contents": "copyWithZone(${1:NSZone}))" },{ "trigger": "elementWithName) \t class NSXMLNode -> AnyObject" , "contents": "elementWithName(${1:String}), stringValue:${2:String}))" },{ "trigger": "count \t Int", "contents": "count" },{ "trigger": "zeroFormattingBehavior \t NSDateComponentsFormatterZeroFormattingBehavior", "contents": "zeroFormattingBehavior" },{ "trigger": "top \t CGFloat", "contents": "top" },{ "trigger": "NSRectFromCGRect) \t func unknown -> NSRect" , "contents": "NSRectFromCGRect(${1:CGRect}))" },{ "trigger": "currencyGroupingSeparator \t String", "contents": "currencyGroupingSeparator" },{ "trigger": "NSData) \t bytesNoCopy: length:" , "contents": "NSData(bytesNoCopy:${1:UnsafeMutablePointerVoid}), length:${2:Int}))" },{ "trigger": "NSMutableDictionary \t NSMutableDictionary", "contents": "NSMutableDictionary" },{ "trigger": "getObjects) \t func NSOrderedSet -> void" , "contents": "getObjects(inout:${1:[AnyObject]}), range:${2:NSRange}))" },{ "trigger": "NSOrderedSet) \t set: copyItems:" , "contents": "NSOrderedSet(${1:SetNSObject}), copyItems:${2:Bool}))" },{ "trigger": "localizedScannerWithString) \t class NSScanner -> AnyObject" , "contents": "localizedScannerWithString(${1:String}))" },{ "trigger": "NSString) \t contentsOfFile: usedEncoding:" , "contents": "NSString(contentsOfFile:${1:String}), usedEncoding:${2:UnsafeMutablePointerUInt}))" },{ "trigger": "supportsSecureCoding) \t func NSURLAuthenticationChallenge -> Bool" , "contents": "supportsSecureCoding(${1:}))" },{ "trigger": "protectionSpace \t NSURLProtectionSpace", "contents": "protectionSpace" },{ "trigger": "XMLStringWithOptions) \t func NSXMLNode -> String" , "contents": "XMLStringWithOptions(${1:Int}))" },{ "trigger": "keysSortedByValueWithOptions) \t func Generator -> [AnyObject]" , "contents": "keysSortedByValueWithOptions(${1:NSSortOptions}), usingComparator:${2:NSComparator}))" },{ "trigger": "sortUsingFunction) \t func NSMutableArray -> Int," , "contents": "sortUsingFunction(compare:${1:@conventionc AnyObject}), AnyObject:${2:}), UnsafeMutablePointerVoid:${3:}), context:${4:UnsafeMutablePointerVoid}))" },{ "trigger": "includesUnit \t Bool", "contents": "includesUnit" },{ "trigger": "NSOperation \t NSOperation", "contents": "NSOperation" },{ "trigger": "NSDecimalAdd) \t func unknown -> NSCalculationError" , "contents": "NSDecimalAdd(${1:UnsafeMutablePointerNSDecimal}), _:${2:UnsafePointerNSDecimal}), _:${3:UnsafePointerNSDecimal}), _:${4:NSRoundingMode}))" },{ "trigger": "NSDateFormatter) \t :" , "contents": "NSDateFormatter(${1:}))" },{ "trigger": "currentDirectoryPath \t String", "contents": "currentDirectoryPath" },{ "trigger": "removeAllObjects) \t func NSCache -> void" , "contents": "removeAllObjects(${1:}))" },{ "trigger": "groupingSeparator \t String", "contents": "groupingSeparator" },{ "trigger": "scanUpToString) \t func NSScanner -> String?" , "contents": "scanUpToString(${1:String}))" },{ "trigger": "intersectsSet) \t func NSSet -> Bool" , "contents": "intersectsSet(${1:SetNSObject}))" },{ "trigger": "NSIndexPath) \t coder:" , "contents": "NSIndexPath(coder:${1:NSCoder}))" },{ "trigger": "seekToFileOffset) \t func NSFileHandle -> void" , "contents": "seekToFileOffset(${1:UInt64}))" },{ "trigger": "sendBeforeDate) \t func NSPort -> Bool" , "contents": "sendBeforeDate(${1:NSDate}), msgid:${2:Int}), components:${3:NSMutableArray?}), from:${4:NSPort?}), reserved:${5:Int}))" },{ "trigger": "cStringUsingEncoding) \t func NSString -> UnsafePointer Int8 " , "contents": "cStringUsingEncoding(${1:UInt}))" },{ "trigger": "predicateOperatorType \t NSPredicateOperatorType", "contents": "predicateOperatorType" },{ "trigger": "defaultCStringEncoding) \t static String -> NSStringEncoding" , "contents": "defaultCStringEncoding(${1:}))" },{ "trigger": "preferredLocalizationsFromArray) \t class NSBundle -> [String]" , "contents": "preferredLocalizationsFromArray(${1:[String]}), forPreferences:${2:[String]?}))" },{ "trigger": "NSSearchPathDomainMask \t NSSearchPathDomainMask", "contents": "NSSearchPathDomainMask" },{ "trigger": "NSAttributedStringEnumerationOptions \t NSAttributedStringEnumerationOptions", "contents": "NSAttributedStringEnumerationOptions" },{ "trigger": "NSProgressFileOperationKindKey \t String", "contents": "NSProgressFileOperationKindKey" },{ "trigger": "NSURLSessionUploadTask \t NSURLSessionUploadTask", "contents": "NSURLSessionUploadTask" },{ "trigger": "NSSortOptions \t NSSortOptions", "contents": "NSSortOptions" },{ "trigger": "classNameForClass) \t func NSKeyedArchiver -> String?" , "contents": "classNameForClass(${1:AnyClass}))" },{ "trigger": "NSFileModificationDate \t String", "contents": "NSFileModificationDate" },{ "trigger": "NSPersonNameComponentKey \t String", "contents": "NSPersonNameComponentKey" },{ "trigger": "NSStreamSOCKSProxyPasswordKey \t String", "contents": "NSStreamSOCKSProxyPasswordKey" },{ "trigger": "localizedName) \t func NSTimeZone -> String?" , "contents": "localizedName(${1:NSTimeZoneNameStyle}), locale:${2:NSLocale?}))" },{ "trigger": "removeFromRunLoop) \t func NSPort -> void" , "contents": "removeFromRunLoop(${1:NSRunLoop}), forMode:${2:String}))" },{ "trigger": "NSSet) \t array:" , "contents": "NSSet(${1:[AnyObject]}))" },{ "trigger": "scanHexLongLong) \t func NSScanner -> Bool" , "contents": "scanHexLongLong(${1:UnsafeMutablePointerUInt64}))" },{ "trigger": "ISOCurrencyCodes) \t class NSLocale -> [String]" , "contents": "ISOCurrencyCodes(${1:}))" },{ "trigger": "NSURL) \t absoluteURLWithDataRepresentation: relativeToURL:" , "contents": "NSURL(absoluteURLWithDataRepresentation:${1:NSData}), relativeToURL:${2:NSURL?}))" },{ "trigger": "NSNumber) \t short:" , "contents": "NSNumber(short:${1:Int16}))" },{ "trigger": "nanosecond \t Int", "contents": "nanosecond" },{ "trigger": "pausable \t Bool", "contents": "pausable" },{ "trigger": "NSLocaleUsesMetricSystem \t String", "contents": "NSLocaleUsesMetricSystem" },{ "trigger": "sessionDescription \t String", "contents": "sessionDescription" },{ "trigger": "valueForComponent) \t func NSDateComponents -> Int" , "contents": "valueForComponent(${1:NSCalendarUnit}))" },{ "trigger": "readDataOfLength) \t func NSFileHandle -> NSData" , "contents": "readDataOfLength(${1:Int}))" },{ "trigger": "NSDateIntervalFormatter \t NSDateIntervalFormatter", "contents": "NSDateIntervalFormatter" },{ "trigger": "removeCachedResponsesSinceDate) \t func NSURLCache -> void" , "contents": "removeCachedResponsesSinceDate(${1:NSDate}))" },{ "trigger": "kind \t NSXMLNodeKind", "contents": "kind" },{ "trigger": "stringFromByteCount) \t func NSByteCountFormatter -> String" , "contents": "stringFromByteCount(${1:Int64}))" },{ "trigger": "quarter \t Int", "contents": "quarter" },{ "trigger": "preferredLocalizationsFromArray) \t class NSBundle -> [String]" , "contents": "preferredLocalizationsFromArray(${1:[String]}))" },{ "trigger": "indexOfObjectIdenticalTo) \t func Generator -> Int" , "contents": "indexOfObjectIdenticalTo(${1:AnyObject}), inRange:${2:NSRange}))" },{ "trigger": "copyWithZone) \t func NSSortDescriptor -> AnyObject" , "contents": "copyWithZone(${1:NSZone}))" },{ "trigger": "NSStreamNetworkServiceTypeBackground \t String", "contents": "NSStreamNetworkServiceTypeBackground" },{ "trigger": "moveObjectsAtIndexes) \t func NSMutableOrderedSet -> void" , "contents": "moveObjectsAtIndexes(${1:NSIndexSet}), toIndex:${2:Int}))" },{ "trigger": "shouldResolveExternalEntities \t Bool", "contents": "shouldResolveExternalEntities" },{ "trigger": "decodeArrayOfObjCType) \t func NSCoder -> void" , "contents": "decodeArrayOfObjCType(${1:UnsafePointerInt8}), count:${2:Int}), at:${3:UnsafeMutablePointerVoid}))" },{ "trigger": "getCredentialsForProtectionSpace) \t func NSURLCredentialStorage -> Void)" , "contents": "getCredentialsForProtectionSpace(${1:NSURLProtectionSpace}), task:${2:NSURLSessionTask}), completionHandler:${3:[String }))" },{ "trigger": "removeObjectsInArray) \t func NSMutableOrderedSet -> void" , "contents": "removeObjectsInArray(${1:[AnyObject]}))" },{ "trigger": "NSTaskDidTerminateNotification \t String", "contents": "NSTaskDidTerminateNotification" },{ "trigger": "NSNotification) \t name: object:" , "contents": "NSNotification(name:${1:String}), object:${2:AnyObject?}))" },{ "trigger": "NSIndexSet) \t indexSet:" , "contents": "NSIndexSet(${1:NSIndexSet}))" },{ "trigger": "NSAffineTransform) \t :" , "contents": "NSAffineTransform(${1:}))" },{ "trigger": "bridge) \t func String -> NSString" , "contents": "bridge(${1:}))" },{ "trigger": "NSRegularExpression \t NSRegularExpression", "contents": "NSRegularExpression" },{ "trigger": "addChild) \t func NSXMLDocument -> void" , "contents": "addChild(${1:NSXMLNode}))" },{ "trigger": "NSSearchPathDomainMask) \t rawValue:" , "contents": "NSSearchPathDomainMask(${1:UInt}))" },{ "trigger": "decodeFloatForKey) \t func NSCoder -> Float" , "contents": "decodeFloatForKey(${1:String}))" },{ "trigger": "indexOfObjectAtIndexes) \t func NSOrderedSet -> Bool)" , "contents": "indexOfObjectAtIndexes(${1:NSIndexSet}), options:${2:NSEnumerationOptions}), passingTest:${3:AnyObject}), Int:${4:}), UnsafeMutablePointerObjCBool:${5:}))" },{ "trigger": "setClass) \t class NSKeyedUnarchiver -> void" , "contents": "setClass(${1:AnyClass?}), forClassName:${2:String}))" },{ "trigger": "removePort) \t func NSRunLoop -> void" , "contents": "removePort(${1:NSPort}), forMode:${2:String}))" },{ "trigger": "readDataOfMinLength) \t func NSURLSessionStreamTask -> Void)" , "contents": "readDataOfMinLength(${1:Int}), maxLength:${2:Int}), timeout:${3:NSTimeInterval}), completionHandler:${4:NSData?}), Bool:${5:}), NSError?:${6:}))" },{ "trigger": "NSDecimalNumber) \t coder:" , "contents": "NSDecimalNumber(coder:${1:NSCoder}))" },{ "trigger": "NSPointFromString) \t func unknown -> NSPoint" , "contents": "NSPointFromString(${1:String}))" },{ "trigger": "NSString) \t stringLiteral:" , "contents": "NSString(stringLiteral:${1:StaticString}))" },{ "trigger": "encodeBool) \t func NSCoder -> void" , "contents": "encodeBool(${1:Bool}), forKey:${2:String}))" },{ "trigger": "protocolFamily \t Int", "contents": "protocolFamily" },{ "trigger": "cookiesForURL) \t func NSHTTPCookieStorage -> [NSHTTPCookie]?" , "contents": "cookiesForURL(${1:NSURL}))" },{ "trigger": "numberOfRanges \t Int", "contents": "numberOfRanges" },{ "trigger": "phonetic \t Bool", "contents": "phonetic" },{ "trigger": "_bridgeToObject) \t func Int -> NSNumber" , "contents": "_bridgeToObject(${1:}))" },{ "trigger": "completedUnitCount \t Int", "contents": "completedUnitCount" },{ "trigger": "NSURLComponents \t NSURLComponents", "contents": "NSURLComponents" },{ "trigger": "NSStringCompareOptions \t NSStringCompareOptions", "contents": "NSStringCompareOptions" },{ "trigger": "decimalNumberByRaisingToPower) \t func NSDecimalNumber -> NSDecimalNumber" , "contents": "decimalNumberByRaisingToPower(${1:Int}))" },{ "trigger": "NSSocketPort) \t protocolFamily: socketType: `protocol`: address:" , "contents": "NSSocketPort(protocolFamily:${1:Int32}), socketType:${2:Int32}), `protocol`:${3:Int32}), address:${4:NSData}))" },{ "trigger": "subdataWithRange) \t func NSData -> NSData" , "contents": "subdataWithRange(${1:NSRange}))" },{ "trigger": "isOperatingSystemAtLeastVersion) \t func NSProcessInfo -> Bool" , "contents": "isOperatingSystemAtLeastVersion(${1:NSOperatingSystemVersion}))" },{ "trigger": "shouldProcessNamespaces \t Bool", "contents": "shouldProcessNamespaces" },{ "trigger": "isEqualToData) \t func NSData -> Bool" , "contents": "isEqualToData(${1:NSData}))" },{ "trigger": "processingInstructionWithName) \t class NSXMLNode -> AnyObject" , "contents": "processingInstructionWithName(${1:String}), stringValue:${2:String}))" },{ "trigger": "fileHandleWithStandardError) \t class NSFileHandle -> NSFileHandle" , "contents": "fileHandleWithStandardError(${1:}))" },{ "trigger": "enumerateRangesInRange) \t func NSIndexSet -> Void)" , "contents": "enumerateRangesInRange(${1:NSRange}), options:${2:NSEnumerationOptions}), usingBlock:${3:NSRange}), UnsafeMutablePointerObjCBool:${4:}))" },{ "trigger": "setPersistentDomain) \t func NSUserDefaults -> void" , "contents": "setPersistentDomain(${1:[String }), forName:${2:String}))" },{ "trigger": "NSStreamFileCurrentOffsetKey \t String", "contents": "NSStreamFileCurrentOffsetKey" },{ "trigger": "removeCharactersInRange) \t func NSMutableCharacterSet -> void" , "contents": "removeCharactersInRange(${1:NSRange}))" },{ "trigger": "NSMutableArray) \t capacity:" , "contents": "NSMutableArray(capacity:${1:Int}))" },{ "trigger": "NSMaxRange) \t func unknown -> Int" , "contents": "NSMaxRange(${1:NSRange}))" },{ "trigger": "NSPersonNameComponentNickname \t String", "contents": "NSPersonNameComponentNickname" },{ "trigger": "NSIndexPath) \t index:" , "contents": "NSIndexPath(${1:Int}))" },{ "trigger": "Generator) \t objects: count:" , "contents": "Generator(${1:UnsafePointerAnyObject?}), count:${2:Int}))" },{ "trigger": "maxConcurrentOperationCount \t Int", "contents": "maxConcurrentOperationCount" },{ "trigger": "stringFromByteCount) \t class NSByteCountFormatter -> String" , "contents": "stringFromByteCount(${1:Int64}), countStyle:${2:NSByteCountFormatterCountStyle}))" },{ "trigger": "NSNumber) \t booleanLiteral:" , "contents": "NSNumber(booleanLiteral:${1:Bool}))" },{ "trigger": "allowEvaluation) \t func NSExpression -> void" , "contents": "allowEvaluation(${1:}))" },{ "trigger": "NSFileManager \t NSFileManager", "contents": "NSFileManager" },{ "trigger": "NSDataReadingOptions \t NSDataReadingOptions", "contents": "NSDataReadingOptions" },{ "trigger": "currentHost) \t class NSHost -> NSHost" , "contents": "currentHost(${1:}))" },{ "trigger": "set \t Set", "contents": "set" },{ "trigger": "zeroPadsFractionDigits \t Bool", "contents": "zeroPadsFractionDigits" },{ "trigger": "scanUnsignedLongLong) \t func NSScanner -> Bool" , "contents": "scanUnsignedLongLong(${1:UnsafeMutablePointerUInt64}))" },{ "trigger": "rawValue \t UInt", "contents": "rawValue" },{ "trigger": "NSDate) \t :" , "contents": "NSDate(${1:}))" },{ "trigger": "NSURLErrorNoPermissionsToReadFile \t Int", "contents": "NSURLErrorNoPermissionsToReadFile" },{ "trigger": "leapMonth \t Bool", "contents": "leapMonth" },{ "trigger": "NSHTTPCookieComment \t String", "contents": "NSHTTPCookieComment" },{ "trigger": "mutableCopyWithZone) \t func NSString -> AnyObject" , "contents": "mutableCopyWithZone(${1:NSZone}))" },{ "trigger": "scanLocation \t Int", "contents": "scanLocation" },{ "trigger": "NSStreamNetworkServiceTypeVoice \t String", "contents": "NSStreamNetworkServiceTypeVoice" },{ "trigger": "NSMutableData) \t capacity:" , "contents": "NSMutableData(${1:Int}))" },{ "trigger": "_conditionallyBridgeFromObject) \t static UInt -> Bool" , "contents": "_conditionallyBridgeFromObject(${1:NSNumber}), inout:${2:UInt?}))" },{ "trigger": "componentsFromLocaleIdentifier) \t class NSLocale -> [String" , "contents": "componentsFromLocaleIdentifier(${1:String}))" },{ "trigger": "NSSocketPort) \t :" , "contents": "NSSocketPort(${1:}))" },{ "trigger": "rangeOfCharacterFromSet) \t func NSString -> NSRange" , "contents": "rangeOfCharacterFromSet(${1:NSCharacterSet}))" },{ "trigger": "setObject) \t func NSCache -> void" , "contents": "setObject(${1:AnyObject}), forKey:${2:AnyObject}), cost:${3:Int}))" },{ "trigger": "stringFromValue) \t func NSLengthFormatter -> String" , "contents": "stringFromValue(${1:Double}), unit:${2:NSLengthFormatterUnit}))" },{ "trigger": "previousFailureCount \t Int", "contents": "previousFailureCount" },{ "trigger": "uppercaseString \t String", "contents": "uppercaseString" },{ "trigger": "cookieAcceptPolicy \t NSHTTPCookieAcceptPolicy", "contents": "cookieAcceptPolicy" },{ "trigger": "NSOrderedSet \t NSOrderedSet", "contents": "NSOrderedSet" },{ "trigger": "minusSet) \t func NSMutableOrderedSet -> void" , "contents": "minusSet(${1:SetNSObject}))" },{ "trigger": "getEra) \t func NSCalendar -> void" , "contents": "getEra(${1:UnsafeMutablePointerInt}), yearForWeekOfYear:${2:UnsafeMutablePointerInt}), weekOfYear:${3:UnsafeMutablePointerInt}), weekday:${4:UnsafeMutablePointerInt}), fromDate:${5:NSDate}))" },{ "trigger": "copyWithZone) \t func NSURLResponse -> AnyObject" , "contents": "copyWithZone(${1:NSZone}))" },{ "trigger": "addObject) \t func NSMutableArray -> void" , "contents": "addObject(${1:AnyObject}))" },{ "trigger": "validDate \t Bool", "contents": "validDate" },{ "trigger": "NSJSONWritingOptions) \t rawValue:" , "contents": "NSJSONWritingOptions(${1:UInt}))" },{ "trigger": "URLsForResourcesWithExtension) \t func NSBundle -> [NSURL]?" , "contents": "URLsForResourcesWithExtension(${1:String?}), subdirectory:${2:String?}))" },{ "trigger": "comparator \t NSComparator", "contents": "comparator" },{ "trigger": "enumerateAttributesInRange) \t func NSAttributedString -> Void)" , "contents": "enumerateAttributesInRange(${1:NSRange}), options:${2:NSAttributedStringEnumerationOptions}), usingBlock:${3:[String }), NSRange:${4:}), UnsafeMutablePointerObjCBool:${5:}))" },{ "trigger": "NSMutableString \t NSMutableString", "contents": "NSMutableString" },{ "trigger": "alphanumericCharacterSet) \t class NSCharacterSet -> NSCharacterSet" , "contents": "alphanumericCharacterSet(${1:}))" },{ "trigger": "NSCountedSet) \t array:" , "contents": "NSCountedSet(${1:[AnyObject]}))" },{ "trigger": "punctuationCharacterSet) \t class NSCharacterSet -> NSCharacterSet" , "contents": "punctuationCharacterSet(${1:}))" },{ "trigger": "NSStringEnumerationOptions) \t rawValue:" , "contents": "NSStringEnumerationOptions(${1:UInt}))" },{ "trigger": "encodeBytes) \t func NSCoder -> void" , "contents": "encodeBytes(${1:UnsafePointerUInt8}), length:${2:Int}), forKey:${3:String}))" },{ "trigger": "NSCalendarIdentifierGregorian \t String", "contents": "NSCalendarIdentifierGregorian" },{ "trigger": "setArray) \t func NSMutableArray -> void" , "contents": "setArray(${1:[AnyObject]}))" },{ "trigger": "loaded \t Bool", "contents": "loaded" },{ "trigger": "supportsSecureCoding) \t static NSOrderedSet -> Bool" , "contents": "supportsSecureCoding(${1:}))" },{ "trigger": "objectEnumerator) \t func NSSet -> NSEnumerator" , "contents": "objectEnumerator(${1:}))" },{ "trigger": "minusOrderedSet) \t func NSMutableOrderedSet -> void" , "contents": "minusOrderedSet(${1:NSOrderedSet}))" },{ "trigger": "NSHTTPCookieSecure \t String", "contents": "NSHTTPCookieSecure" },{ "trigger": "URLUserAllowedCharacterSet) \t class NSCharacterSet -> NSCharacterSet" , "contents": "URLUserAllowedCharacterSet(${1:}))" },{ "trigger": "columnNumber \t Int", "contents": "columnNumber" },{ "trigger": "sortedArrayUsingComparator) \t func Generator -> [AnyObject]" , "contents": "sortedArrayUsingComparator(${1:NSComparator}))" },{ "trigger": "NSLocaleAlternateQuotationEndDelimiterKey \t String", "contents": "NSLocaleAlternateQuotationEndDelimiterKey" },{ "trigger": "stringByReplacingMatchesInString) \t func NSRegularExpression -> String" , "contents": "stringByReplacingMatchesInString(${1:String}), options:${2:NSMatchingOptions}), range:${3:NSRange}), withTemplate:${4:String}))" },{ "trigger": "relativePath \t String", "contents": "relativePath" },{ "trigger": "NSDecimalMultiply) \t func unknown -> NSCalculationError" , "contents": "NSDecimalMultiply(${1:UnsafeMutablePointerNSDecimal}), _:${2:UnsafePointerNSDecimal}), _:${3:UnsafePointerNSDecimal}), _:${4:NSRoundingMode}))" },{ "trigger": "NSTimeZone) \t name: data:" , "contents": "NSTimeZone(name:${1:String}), data:${2:NSData?}))" },{ "trigger": "getAllTasksWithCompletionHandler) \t func NSURLSession -> Void)" , "contents": "getAllTasksWithCompletionHandler(${1:[NSURLSessionTask] - Void}))" },{ "trigger": "left \t CGFloat", "contents": "left" },{ "trigger": "NSFileSystemNumber \t String", "contents": "NSFileSystemNumber" },{ "trigger": "NSDecimalNumberHandler \t NSDecimalNumberHandler", "contents": "NSDecimalNumberHandler" },{ "trigger": "NSHTTPCookiePath \t String", "contents": "NSHTTPCookiePath" },{ "trigger": "decodeIntegerForKey) \t func NSCoder -> Int" , "contents": "decodeIntegerForKey(${1:String}))" },{ "trigger": "sortedArrayWithOptions) \t func Generator -> [AnyObject]" , "contents": "sortedArrayWithOptions(${1:NSSortOptions}), usingComparator:${2:NSComparator}))" },{ "trigger": "scheduleInRunLoop) \t func NSStream -> void" , "contents": "scheduleInRunLoop(${1:NSRunLoop}), forMode:${2:String}))" },{ "trigger": "encodeWithCoder) \t func NSAffineTransform -> void" , "contents": "encodeWithCoder(${1:NSCoder}))" },{ "trigger": "copyWithZone) \t func NSData -> AnyObject" , "contents": "copyWithZone(${1:NSZone}))" },{ "trigger": "expressionForEvaluatedObject) \t class NSExpression -> NSExpression" , "contents": "expressionForEvaluatedObject(${1:}))" },{ "trigger": "ascending \t Bool", "contents": "ascending" },{ "trigger": "bridge) \t func NSString -> String" , "contents": "bridge(${1:}))" },{ "trigger": "NSCompoundPredicate) \t notPredicateWithSubpredicate:" , "contents": "NSCompoundPredicate(notPredicateWithSubpredicate:${1:NSPredicate}))" },{ "trigger": "URLPathAllowedCharacterSet) \t class NSCharacterSet -> NSCharacterSet" , "contents": "URLPathAllowedCharacterSet(${1:}))" },{ "trigger": "origin \t CGPoint", "contents": "origin" },{ "trigger": "NSProgressKindFile \t String", "contents": "NSProgressKindFile" },{ "trigger": "NSURLProtectionSpaceHTTP \t String", "contents": "NSURLProtectionSpaceHTTP" },{ "trigger": "NSURLErrorCannotMoveFile \t Int", "contents": "NSURLErrorCannotMoveFile" },{ "trigger": "NSDecimalNumber) \t floatLiteral:" , "contents": "NSDecimalNumber(floatLiteral:${1:Double}))" },{ "trigger": "displayNameAtPath) \t func NSFileManager -> String" , "contents": "displayNameAtPath(${1:String}))" },{ "trigger": "setDictionary) \t func NSMutableDictionary -> void" , "contents": "setDictionary(${1:[NSObject }))" },{ "trigger": "DTD \t NSXMLDTD", "contents": "DTD" },{ "trigger": "NSJSONReadingOptions) \t rawValue:" , "contents": "NSJSONReadingOptions(${1:UInt}))" },{ "trigger": "NSString) \t contentsOfURL: usedEncoding:" , "contents": "NSString(contentsOfURL:${1:NSURL}), usedEncoding:${2:UnsafeMutablePointerUInt}))" },{ "trigger": "indexGreaterThanIndex) \t func NSIndexSet -> Int" , "contents": "indexGreaterThanIndex(${1:Int}))" },{ "trigger": "value \t String", "contents": "value" },{ "trigger": "NSData) \t data:" , "contents": "NSData(${1:NSData}))" },{ "trigger": "availableData \t NSData", "contents": "availableData" },{ "trigger": "objectValue) \t func NSFormatter -> AnyObject?" , "contents": "objectValue(${1:String}))" },{ "trigger": "decodePointForKey) \t func NSCoder -> NSPoint" , "contents": "decodePointForKey(${1:String}))" },{ "trigger": "setCredential) \t func NSURLCredentialStorage -> void" , "contents": "setCredential(${1:NSURLCredential}), forProtectionSpace:${2:NSURLProtectionSpace}))" },{ "trigger": "NSOutputStream) \t toBuffer: capacity:" , "contents": "NSOutputStream(toBuffer:${1:UnsafeMutablePointerUInt8}), capacity:${2:Int}))" },{ "trigger": "standardizedURL \t NSURL", "contents": "standardizedURL" },{ "trigger": "NSCalendarIdentifierIndian \t String", "contents": "NSCalendarIdentifierIndian" },{ "trigger": "UUIDString \t String", "contents": "UUIDString" },{ "trigger": "containsObject) \t func NSSet -> Bool" , "contents": "containsObject(${1:AnyObject}))" },{ "trigger": "NSURL) \t dataRepresentation: relativeToURL:" , "contents": "NSURL(dataRepresentation:${1:NSData}), relativeToURL:${2:NSURL?}))" },{ "trigger": "localizesFormat \t Bool", "contents": "localizesFormat" },{ "trigger": "supportsSecureCoding) \t static NSNull -> Bool" , "contents": "supportsSecureCoding(${1:}))" },{ "trigger": "thousandSeparator \t String", "contents": "thousandSeparator" },{ "trigger": "detach) \t func NSXMLNode -> void" , "contents": "detach(${1:}))" },{ "trigger": "enumerateByteRangesUsingBlock) \t func NSData -> Void)" , "contents": "enumerateByteRangesUsingBlock(${1:UnsafePointerVoid}), NSRange:${2:}), UnsafeMutablePointerBool:${3:}))" },{ "trigger": "CGSize) \t width: height:" , "contents": "CGSize(${1:CGFloat}), height:${2:CGFloat}))" },{ "trigger": "supportsSecureCoding) \t static NSURLRequest -> Bool" , "contents": "supportsSecureCoding(${1:}))" },{ "trigger": "copy) \t func NSCopying -> AnyObject" , "contents": "copy(${1:}))" },{ "trigger": "NSString) \t characters: length:" , "contents": "NSString(${1:UnsafePointerunichar}), length:${2:Int}))" },{ "trigger": "compareObject) \t func NSSortDescriptor -> NSComparisonResult" , "contents": "compareObject(${1:AnyObject}), toObject:${2:AnyObject}))" },{ "trigger": "setDouble) \t func NSUserDefaults -> void" , "contents": "setDouble(${1:Double}), forKey:${2:String}))" },{ "trigger": "removeCharactersInString) \t func NSMutableCharacterSet -> void" , "contents": "removeCharactersInString(${1:String}))" },{ "trigger": "NSHTTPCookieDomain \t String", "contents": "NSHTTPCookieDomain" },{ "trigger": "NSMutableString) \t capacity:" , "contents": "NSMutableString(${1:Int}))" },{ "trigger": "whitespaceAndNewlineCharacterSet) \t class NSCharacterSet -> NSCharacterSet" , "contents": "whitespaceAndNewlineCharacterSet(${1:}))" },{ "trigger": "NSIntersectionRange) \t func unknown -> NSRange" , "contents": "NSIntersectionRange(${1:NSRange}), _:${2:NSRange}))" },{ "trigger": "acceptInputForMode) \t func NSRunLoop -> void" , "contents": "acceptInputForMode(${1:String}), beforeDate:${2:NSDate}))" },{ "trigger": "replaceObjectsInRange) \t func NSMutableOrderedSet -> void" , "contents": "replaceObjectsInRange(${1:NSRange}), withObjects:${2:UnsafePointerAnyObject?}), count:${3:Int}))" },{ "trigger": "waitUntilDate) \t func NSCondition -> Bool" , "contents": "waitUntilDate(${1:NSDate}))" },{ "trigger": "endEditing) \t func NSMutableAttributedString -> void" , "contents": "endEditing(${1:}))" },{ "trigger": "availableStringEncodings) \t class NSString -> UnsafePointer UInt " , "contents": "availableStringEncodings(${1:}))" },{ "trigger": "percentEncodedPath \t String", "contents": "percentEncodedPath" },{ "trigger": "NSXMLNodePreserveEmptyElements \t NSXMLNodeOptionRawType", "contents": "NSXMLNodePreserveEmptyElements" },{ "trigger": "key \t String", "contents": "key" },{ "trigger": "laterDate) \t func NSDate -> NSDate" , "contents": "laterDate(${1:NSDate}))" },{ "trigger": "isFormattingError \t Bool", "contents": "isFormattingError" },{ "trigger": "NSMutableAttributedString \t NSMutableAttributedString", "contents": "NSMutableAttributedString" },{ "trigger": "resourceURL \t NSURL", "contents": "resourceURL" },{ "trigger": "compareDate) \t func NSCalendar -> NSComparisonResult" , "contents": "compareDate(${1:NSDate}), toDate:${2:NSDate}), toUnitGranularity:${3:NSCalendarUnit}))" },{ "trigger": "NSDate) \t timeIntervalSince1970:" , "contents": "NSDate(timeIntervalSince1970:${1:NSTimeInterval}))" },{ "trigger": "NSLocalizedDescriptionKey \t String", "contents": "NSLocalizedDescriptionKey" },{ "trigger": "createSymbolicLinkAtURL) \t func NSFileManager -> void" , "contents": "createSymbolicLinkAtURL(${1:NSURL}), withDestinationURL:${2:NSURL}))" },{ "trigger": "NSDecimalMultiplyByPowerOf10) \t func unknown -> NSCalculationError" , "contents": "NSDecimalMultiplyByPowerOf10(${1:UnsafeMutablePointerNSDecimal}), _:${2:UnsafePointerNSDecimal}), _:${3:Int16}), _:${4:NSRoundingMode}))" },{ "trigger": "==) \t func unknown -> Bool" , "contents": "==(${1:CGFloat}), rhs:${2:CGFloat}))" },{ "trigger": "NSNumber) \t longLong:" , "contents": "NSNumber(longLong:${1:Int64}))" },{ "trigger": "stringByAppendingPathExtension) \t func NSString -> String?" , "contents": "stringByAppendingPathExtension(${1:String}))" },{ "trigger": "sortUsingComparator) \t func NSMutableOrderedSet -> void" , "contents": "sortUsingComparator(${1:NSComparator}))" },{ "trigger": "pathWithComponents) \t static NSString -> String" , "contents": "pathWithComponents(${1:[String]}))" },{ "trigger": "NSMutableArray) \t :" , "contents": "NSMutableArray(${1:}))" },{ "trigger": "_forceBridgeFromObject) \t static Dictionary -> void" , "contents": "_forceBridgeFromObject(${1:NSDictionary}), inout:${2:Dictionary?}))" },{ "trigger": "familyName \t String", "contents": "familyName" },{ "trigger": "NSFileReferenceCount \t String", "contents": "NSFileReferenceCount" },{ "trigger": "==) \t func unknown -> Bool" , "contents": "==(${1:CGPoint}), rhs:${2:CGPoint}))" },{ "trigger": "sortWithOptions) \t func NSMutableArray -> void" , "contents": "sortWithOptions(${1:NSSortOptions}), usingComparator:${2:NSComparator}))" },{ "trigger": "NSProgressFileCompletedCountKey \t String", "contents": "NSProgressFileCompletedCountKey" },{ "trigger": "scanInt) \t func NSScanner -> Int32?" , "contents": "scanInt(${1:}))" },{ "trigger": "expressionType \t NSExpressionType", "contents": "expressionType" },{ "trigger": "NSTextCheckingResult \t NSTextCheckingResult", "contents": "NSTextCheckingResult" },{ "trigger": "stringForObjectValue) \t func NSFormatter -> String?" , "contents": "stringForObjectValue(${1:AnyObject}))" },{ "trigger": "NSCocoaError) \t rawValue:" , "contents": "NSCocoaError(${1:Int}))" },{ "trigger": "unitStringFromKilograms) \t func NSMassFormatter -> String" , "contents": "unitStringFromKilograms(${1:Double}), usedUnit:${2:UnsafeMutablePointerNSMassFormatterUnit}))" },{ "trigger": "rangeAtIndex) \t func NSTextCheckingResult -> NSRange" , "contents": "rangeAtIndex(${1:Int}))" },{ "trigger": "URLsForDirectory) \t func NSFileManager -> [NSURL]" , "contents": "URLsForDirectory(${1:NSSearchPathDirectory}), inDomains:${2:NSSearchPathDomainMask}))" },{ "trigger": "positiveFormat \t String", "contents": "positiveFormat" },{ "trigger": "URLByAppendingPathExtension) \t func NSURL -> NSURL?" , "contents": "URLByAppendingPathExtension(${1:String}))" },{ "trigger": "NSURLQueryItem) \t coder:" , "contents": "NSURLQueryItem(coder:${1:NSCoder}))" },{ "trigger": "diskCapacity \t Int", "contents": "diskCapacity" },{ "trigger": "precomposedStringWithCanonicalMapping \t String", "contents": "precomposedStringWithCanonicalMapping" },{ "trigger": "taskDescription \t String", "contents": "taskDescription" },{ "trigger": "NSString) \t CString: encoding:" , "contents": "NSString(CString:${1:UnsafePointerInt8}), encoding:${2:UInt}))" },{ "trigger": "HTTPCookieAcceptPolicy \t NSHTTPCookieAcceptPolicy", "contents": "HTTPCookieAcceptPolicy" },{ "trigger": "downloadTaskWithRequest) \t func NSURLSession -> NSURLSessionDownloadTask" , "contents": "downloadTaskWithRequest(${1:NSURLRequest}))" },{ "trigger": "removeVolatileDomainForName) \t func NSUserDefaults -> void" , "contents": "removeVolatileDomainForName(${1:String}))" },{ "trigger": "objectIsForcedForKey) \t func NSUserDefaults -> Bool" , "contents": "objectIsForcedForKey(${1:String}))" },{ "trigger": "objectsForXQuery) \t func NSXMLNode -> [AnyObject]" , "contents": "objectsForXQuery(${1:String}))" },{ "trigger": "port \t Int", "contents": "port" },{ "trigger": "sharedKeySetForKeys) \t class NSDictionary -> AnyObject" , "contents": "sharedKeySetForKeys(${1:[NSCopying]}))" },{ "trigger": "isFileError \t Bool", "contents": "isFileError" },{ "trigger": "objectsAtIndexes) \t func Generator -> [AnyObject]" , "contents": "objectsAtIndexes(${1:NSIndexSet}))" },{ "trigger": "systemVersion \t UInt", "contents": "systemVersion" },{ "trigger": "NSHTTPCookieVersion \t String", "contents": "NSHTTPCookieVersion" },{ "trigger": "localizedStringFromDate) \t class NSDateFormatter -> String" , "contents": "localizedStringFromDate(${1:NSDate}), dateStyle:${2:NSDateFormatterStyle}), timeStyle:${3:NSDateFormatterStyle}))" },{ "trigger": "maximumIntegerDigits \t Int", "contents": "maximumIntegerDigits" },{ "trigger": "NSString) \t contentsOfFile: encoding:" , "contents": "NSString(contentsOfFile:${1:String}), encoding:${2:UInt}))" },{ "trigger": "_forceBridgeFromObject) \t static Float -> void" , "contents": "_forceBridgeFromObject(${1:NSNumber}), inout:${2:Float?}))" },{ "trigger": "NSURLErrorCancelledReasonBackgroundUpdatesDisabled \t Int", "contents": "NSURLErrorCancelledReasonBackgroundUpdatesDisabled" },{ "trigger": "NSCalendarDayChangedNotification \t String", "contents": "NSCalendarDayChangedNotification" },{ "trigger": "NSURLErrorBackgroundSessionWasDisconnected \t Int", "contents": "NSURLErrorBackgroundSessionWasDisconnected" },{ "trigger": "NSString) \t unicodeScalarLiteral:" , "contents": "NSString(unicodeScalarLiteral:${1:StaticString}))" },{ "trigger": "absoluteURL \t NSURL", "contents": "absoluteURL" },{ "trigger": "evaluateWithObject) \t func NSPredicate -> Bool" , "contents": "evaluateWithObject(${1:AnyObject?}))" },{ "trigger": "dataTaskWithURL) \t func NSURLSession -> NSURLSessionDataTask" , "contents": "dataTaskWithURL(${1:NSURL}))" },{ "trigger": "NSZone) \t :" , "contents": "NSZone(${1:}))" },{ "trigger": "decodeRectForKey) \t func NSCoder -> NSRect" , "contents": "decodeRectForKey(${1:String}))" },{ "trigger": "downloadTaskWithRequest) \t func NSURLSession -> Void)" , "contents": "downloadTaskWithRequest(${1:NSURLRequest}), completionHandler:${2:NSURL?}), NSURLResponse?:${3:}), NSError?:${4:}))" },{ "trigger": "NSURL) \t coder:" , "contents": "NSURL(coder:${1:NSCoder}))" },{ "trigger": "setSharedURLCache) \t class NSURLCache -> void" , "contents": "setSharedURLCache(${1:NSURLCache}))" },{ "trigger": "outputFormat \t NSPropertyListFormat", "contents": "outputFormat" },{ "trigger": "entityDeclarationForName) \t func NSXMLDTD -> NSXMLDTDNode?" , "contents": "entityDeclarationForName(${1:String}))" },{ "trigger": "transformPoint) \t func NSAffineTransform -> NSPoint" , "contents": "transformPoint(${1:NSPoint}))" },{ "trigger": "NSDateInterval) \t start: end:" , "contents": "NSDateInterval(${1:NSDate}), end:${2:NSDate}))" },{ "trigger": "Generator) \t array: copyItems:" , "contents": "Generator(${1:[AnyObject]}), copyItems:${2:Bool}))" },{ "trigger": "Generator) \t object: forKey:" , "contents": "Generator(${1:AnyObject}), forKey:${2:NSCopying}))" },{ "trigger": "NSComparisonPredicateOptions \t NSComparisonPredicateOptions", "contents": "NSComparisonPredicateOptions" },{ "trigger": "getRelationship) \t func NSFileManager -> void" , "contents": "getRelationship(${1:UnsafeMutablePointerNSURLRelationship}), ofDirectory:${2:NSSearchPathDirectory}), inDomain:${3:NSSearchPathDomainMask}), toItemAtURL:${4:NSURL}))" },{ "trigger": "isEqualToIndexSet) \t func NSIndexSet -> Bool" , "contents": "isEqualToIndexSet(${1:NSIndexSet}))" },{ "trigger": "NSOutputStream) \t toFileAtPath: append:" , "contents": "NSOutputStream(toFileAtPath:${1:String}), append:${2:Bool}))" },{ "trigger": "getDefaultCredentialForProtectionSpace) \t func NSURLCredentialStorage -> Void)" , "contents": "getDefaultCredentialForProtectionSpace(${1:NSURLProtectionSpace}), task:${2:NSURLSessionTask}), completionHandler:${3:NSURLCredential? - Void}))" },{ "trigger": "unionSet) \t func NSMutableOrderedSet -> void" , "contents": "unionSet(${1:SetNSObject}))" },{ "trigger": "NSURLAuthenticationMethodNTLM \t String", "contents": "NSURLAuthenticationMethodNTLM" },{ "trigger": "NSUUID) \t coder:" , "contents": "NSUUID(${1:NSCoder}))" },{ "trigger": "NSSizeToCGSize) \t func unknown -> CGSize" , "contents": "NSSizeToCGSize(${1:NSSize}))" },{ "trigger": "positiveInfinitySymbol \t String", "contents": "positiveInfinitySymbol" },{ "trigger": "setByAddingObjectsFromSet) \t func NSSet -> Set NSObject " , "contents": "setByAddingObjectsFromSet(${1:SetNSObject}))" },{ "trigger": "isProxy) \t func NSObject -> Bool" , "contents": "isProxy(${1:}))" },{ "trigger": "NSTimeZone) \t abbreviation:" , "contents": "NSTimeZone(${1:String}))" },{ "trigger": "NSCalendarIdentifierEthiopicAmeteAlem \t String", "contents": "NSCalendarIdentifierEthiopicAmeteAlem" },{ "trigger": "NSCharacterSet) \t contentsOfFile:" , "contents": "NSCharacterSet(contentsOfFile:${1:String}))" },{ "trigger": "falseExpression \t NSExpression", "contents": "falseExpression" },{ "trigger": "NSStreamSOCKSProxyVersionKey \t String", "contents": "NSStreamSOCKSProxyVersionKey" },{ "trigger": "NSFileGroupOwnerAccountName \t String", "contents": "NSFileGroupOwnerAccountName" },{ "trigger": "defaultQueue) \t class NSNotificationQueue -> NSNotificationQueue" , "contents": "defaultQueue(${1:}))" },{ "trigger": "removeObjectsAtIndexes) \t func NSMutableArray -> void" , "contents": "removeObjectsAtIndexes(${1:NSIndexSet}))" },{ "trigger": "percentEncodedQuery \t String", "contents": "percentEncodedQuery" },{ "trigger": "includesApproximationPhrase \t Bool", "contents": "includesApproximationPhrase" },{ "trigger": "NSFileImmutable \t String", "contents": "NSFileImmutable" },{ "trigger": "parent \t NSXMLNode", "contents": "parent" },{ "trigger": "cachedResponseForRequest) \t func NSURLCache -> NSCachedURLResponse?" , "contents": "cachedResponseForRequest(${1:NSURLRequest}))" },{ "trigger": "encodeWithCoder) \t func NSURLCredential -> void" , "contents": "encodeWithCoder(${1:NSCoder}))" },{ "trigger": "longCharacterIsMember) \t func NSCharacterSet -> Bool" , "contents": "longCharacterIsMember(${1:UTF32Char}))" },{ "trigger": "NSSet) \t :" , "contents": "NSSet(${1:}))" },{ "trigger": "NSUUID) \t UUIDString:" , "contents": "NSUUID(UUIDString:${1:String}))" },{ "trigger": "NSEdgeInsetsZero \t NSEdgeInsets", "contents": "NSEdgeInsetsZero" },{ "trigger": "weekdayOrdinal \t Int", "contents": "weekdayOrdinal" },{ "trigger": "filterUsingPredicate) \t func NSMutableArray -> void" , "contents": "filterUsingPredicate(${1:NSPredicate}))" },{ "trigger": "addValue) \t func NSMutableURLRequest -> void" , "contents": "addValue(${1:String}), forHTTPHeaderField:${2:String}))" },{ "trigger": "NSURLRequestCachePolicy \t NSURLRequestCachePolicy", "contents": "NSURLRequestCachePolicy" },{ "trigger": "encodeInteger) \t func NSCoder -> void" , "contents": "encodeInteger(${1:Int}), forKey:${2:String}))" },{ "trigger": "indexesPassingTest) \t func NSIndexSet -> Bool)" , "contents": "indexesPassingTest(${1:Int}), UnsafeMutablePointerObjCBool:${2:}))" },{ "trigger": "setUserInfoObject) \t func NSProgress -> void" , "contents": "setUserInfoObject(${1:AnyObject?}), forKey:${2:String}))" },{ "trigger": "translateXBy) \t func NSAffineTransform -> void" , "contents": "translateXBy(${1:CGFloat}), yBy:${2:CGFloat}))" },{ "trigger": "HTTPMethod \t String", "contents": "HTTPMethod" },{ "trigger": "x \t CGFloat", "contents": "x" },{ "trigger": "downloadTaskWithResumeData) \t func NSURLSession -> NSURLSessionDownloadTask" , "contents": "downloadTaskWithResumeData(${1:NSData}))" },{ "trigger": "NSMutableData) \t coder:" , "contents": "NSMutableData(coder:${1:NSCoder}))" },{ "trigger": "NSExpression \t NSExpression", "contents": "NSExpression" },{ "trigger": "suspended \t Bool", "contents": "suspended" },{ "trigger": "getLineStart) \t func NSString -> void" , "contents": "getLineStart(${1:UnsafeMutablePointerInt}), end:${2:UnsafeMutablePointerInt}), contentsEnd:${3:UnsafeMutablePointerInt}), forRange:${4:NSRange}))" },{ "trigger": "NSDateComponents) \t :" , "contents": "NSDateComponents(${1:}))" },{ "trigger": "capitalizedString \t String", "contents": "capitalizedString" },{ "trigger": "isWritableFileAtPath) \t func NSFileManager -> Bool" , "contents": "isWritableFileAtPath(${1:String}))" },{ "trigger": "NSNotificationQueue) \t notificationCenter:" , "contents": "NSNotificationQueue(${1:NSNotificationCenter}))" },{ "trigger": "mainRunLoop) \t class NSRunLoop -> NSRunLoop" , "contents": "mainRunLoop(${1:}))" },{ "trigger": "mutableCopyWithZone) \t func NSOrderedSet -> AnyObject" , "contents": "mutableCopyWithZone(${1:NSZone}))" },{ "trigger": "removeObject) \t func NSMutableSet -> void" , "contents": "removeObject(${1:AnyObject}))" },{ "trigger": "addNamespace) \t func NSXMLElement -> void" , "contents": "addNamespace(${1:NSXMLNode}))" },{ "trigger": "URLHostAllowedCharacterSet) \t class NSCharacterSet -> NSCharacterSet" , "contents": "URLHostAllowedCharacterSet(${1:}))" },{ "trigger": "NSURLProtocol) \t task: cachedResponse: client:" , "contents": "NSURLProtocol(${1:NSURLSessionTask}), cachedResponse:${2:NSCachedURLResponse?}), client:${3:NSURLProtocolClient?}))" },{ "trigger": "NSBundle) \t identifier:" , "contents": "NSBundle(${1:String}))" },{ "trigger": "removeIndexesInRange) \t func NSMutableIndexSet -> void" , "contents": "removeIndexesInRange(${1:NSRange}))" },{ "trigger": "reservedSpaceLength \t Int", "contents": "reservedSpaceLength" },{ "trigger": "objectByApplyingXSLTAtURL) \t func NSXMLDocument -> AnyObject" , "contents": "objectByApplyingXSLTAtURL(${1:NSURL}), arguments:${2:[String }))" },{ "trigger": "NSMutableDictionary) \t sharedKeySet:" , "contents": "NSMutableDictionary(sharedKeySet:${1:AnyObject}))" },{ "trigger": "NSURLErrorDataLengthExceedsMaximum \t Int", "contents": "NSURLErrorDataLengthExceedsMaximum" },{ "trigger": "replaceCharactersInRange) \t func NSMutableString -> void" , "contents": "replaceCharactersInRange(${1:NSRange}), withString:${2:String}))" },{ "trigger": "NSXMLNodePrettyPrint \t NSXMLNodeOptionRawType", "contents": "NSXMLNodePrettyPrint" },{ "trigger": "sortedArrayWithOptions) \t func NSOrderedSet -> [AnyObject]" , "contents": "sortedArrayWithOptions(${1:NSSortOptions}), usingComparator:${2:NSComparator}))" },{ "trigger": "stringByFoldingWithOptions) \t func NSString -> String" , "contents": "stringByFoldingWithOptions(${1:NSStringCompareOptions}), locale:${2:NSLocale?}))" },{ "trigger": "NSURLSessionDownloadTask \t NSURLSessionDownloadTask", "contents": "NSURLSessionDownloadTask" },{ "trigger": "setAttributes) \t func NSMutableAttributedString -> void" , "contents": "setAttributes(${1:[String }), range:${2:NSRange}))" },{ "trigger": "NSXMLNodeLoadExternalEntitiesSameOriginOnly \t NSXMLNodeOptionRawType", "contents": "NSXMLNodeLoadExternalEntitiesSameOriginOnly" },{ "trigger": "appendData) \t func NSMutableData -> void" , "contents": "appendData(${1:NSData}))" },{ "trigger": "textWithStringValue) \t class NSXMLNode -> AnyObject" , "contents": "textWithStringValue(${1:String}))" },{ "trigger": "dateWithEra) \t func NSCalendar -> NSDate?" , "contents": "dateWithEra(${1:Int}), yearForWeekOfYear:${2:Int}), weekOfYear:${3:Int}), weekday:${4:Int}), hour:${5:Int}), minute:${6:Int}), second:${7:Int}), nanosecond:${8:Int}))" },{ "trigger": "NSOrderedSet) \t coder:" , "contents": "NSOrderedSet(coder:${1:NSCoder}))" },{ "trigger": "writeToFile) \t func NSData -> void" , "contents": "writeToFile(${1:String}), options:${2:NSDataWritingOptions}))" },{ "trigger": "indexLessThanIndex) \t func NSIndexSet -> Int" , "contents": "indexLessThanIndex(${1:Int}))" },{ "trigger": "decimalNumberByAdding) \t func NSDecimalNumber -> NSDecimalNumber" , "contents": "decimalNumberByAdding(${1:NSDecimalNumber}), withBehavior:${2:NSDecimalNumberBehaviors?}))" },{ "trigger": "NSURLErrorFailingURLErrorKey \t String", "contents": "NSURLErrorFailingURLErrorKey" },{ "trigger": "resetWithCompletionHandler) \t func NSURLSession -> Void)" , "contents": "resetWithCompletionHandler(${1: - Void}))" },{ "trigger": "mutableCopyWithZone) \t func Generator -> AnyObject" , "contents": "mutableCopyWithZone(${1:NSZone}))" },{ "trigger": "NSBundle) \t URL:" , "contents": "NSBundle(URL:${1:NSURL}))" },{ "trigger": "NSNumberFormatterPadPosition \t NSNumberFormatterPadPosition", "contents": "NSNumberFormatterPadPosition" },{ "trigger": "stringByAppendingPathComponent) \t func NSString -> String" , "contents": "stringByAppendingPathComponent(${1:String}))" },{ "trigger": "processInfo) \t class NSProcessInfo -> NSProcessInfo" , "contents": "processInfo(${1:}))" },{ "trigger": "credentialsForProtectionSpace) \t func NSURLCredentialStorage -> [String" , "contents": "credentialsForProtectionSpace(${1:NSURLProtectionSpace}))" },{ "trigger": "NSURLAuthenticationMethodHTTPBasic \t String", "contents": "NSURLAuthenticationMethodHTTPBasic" },{ "trigger": "setRootElement) \t func NSXMLDocument -> void" , "contents": "setRootElement(${1:NSXMLElement}))" },{ "trigger": "NSNumber) \t unsignedInt:" , "contents": "NSNumber(unsignedInt:${1:UInt32}))" },{ "trigger": "removeObjectsInRange) \t func NSMutableOrderedSet -> void" , "contents": "removeObjectsInRange(${1:NSRange}))" },{ "trigger": "NSXMLDocumentValidate \t NSXMLNodeOptionRawType", "contents": "NSXMLDocumentValidate" },{ "trigger": "NSStreamSOCKSProxyHostKey \t String", "contents": "NSStreamSOCKSProxyHostKey" },{ "trigger": "objectsWithOptions) \t func NSSet -> Bool)" , "contents": "objectsWithOptions(${1:NSEnumerationOptions}), passingTest:${2:AnyObject}), UnsafeMutablePointerObjCBool:${3:}))" },{ "trigger": "NSString) \t extendedGraphemeClusterLiteral:" , "contents": "NSString(extendedGraphemeClusterLiteral:${1:StaticString}))" },{ "trigger": "indexesOfObjectsAtIndexes) \t func NSOrderedSet -> Bool)" , "contents": "indexesOfObjectsAtIndexes(${1:NSIndexSet}), options:${2:NSEnumerationOptions}), passingTest:${3:AnyObject}), Int:${4:}), UnsafeMutablePointerObjCBool:${5:}))" },{ "trigger": "bridge) \t func Dictionary -> NSDictionary" , "contents": "bridge(${1:}))" },{ "trigger": "NSMutableURLRequest) \t coder:" , "contents": "NSMutableURLRequest(coder:${1:NSCoder}))" },{ "trigger": "compare) \t func NSDate -> NSComparisonResult" , "contents": "compare(${1:NSDate}))" },{ "trigger": "copyWithZone) \t func NSURLSessionTask -> AnyObject" , "contents": "copyWithZone(${1:NSZone}))" },{ "trigger": "enumerateObjectsWithOptions) \t func Generator -> Void)" , "contents": "enumerateObjectsWithOptions(${1:NSEnumerationOptions}), usingBlock:${2:AnyObject}), Int:${3:}), UnsafeMutablePointerObjCBool:${4:}))" },{ "trigger": "NSArray \t NSArray", "contents": "NSArray" },{ "trigger": "unknown) \t :" , "contents": "unknown(${1:}))" },{ "trigger": "NSUnicodeStringEncoding \t UInt", "contents": "NSUnicodeStringEncoding" },{ "trigger": "copyWithZone) \t func NSCachedURLResponse -> AnyObject" , "contents": "copyWithZone(${1:NSZone}))" },{ "trigger": "NSStringFromPoint) \t func unknown -> String" , "contents": "NSStringFromPoint(${1:NSPoint}))" },{ "trigger": "linkItemAtURL) \t func NSFileManager -> void" , "contents": "linkItemAtURL(${1:NSURL}), toURL:${2:NSURL}))" },{ "trigger": "NSSocketPort) \t coder:" , "contents": "NSSocketPort(coder:${1:NSCoder}))" },{ "trigger": "NSXMLDTDNode) \t kind: options:" , "contents": "NSXMLDTDNode(${1:NSXMLNodeKind}), options:${2:Int}))" },{ "trigger": "NSMatchingOptions \t NSMatchingOptions", "contents": "NSMatchingOptions" },{ "trigger": "daylightSavingTimeOffset \t NSTimeInterval", "contents": "daylightSavingTimeOffset" },{ "trigger": "client \t NSURLProtocolClient", "contents": "client" },{ "trigger": "NSSizeFromCGSize) \t func unknown -> NSSize" , "contents": "NSSizeFromCGSize(${1:CGSize}))" },{ "trigger": "NSRegularExpression) \t pattern: options:" , "contents": "NSRegularExpression(${1:String}), options:${2:NSRegularExpressionOptions}))" },{ "trigger": "writeToURL) \t func NSData -> void" , "contents": "writeToURL(${1:NSURL}), options:${2:NSDataWritingOptions}))" },{ "trigger": "NSVolumeEnumerationOptions \t NSVolumeEnumerationOptions", "contents": "NSVolumeEnumerationOptions" },{ "trigger": "NSLengthFormatter) \t coder:" , "contents": "NSLengthFormatter(${1:NSCoder}))" },{ "trigger": "scanInteger) \t func NSScanner -> Int?" , "contents": "scanInteger(${1:}))" },{ "trigger": "addChild) \t func NSXMLDTD -> void" , "contents": "addChild(${1:NSXMLNode}))" },{ "trigger": "removeFromRunLoop) \t func NSStream -> void" , "contents": "removeFromRunLoop(${1:NSRunLoop}), forMode:${2:String}))" },{ "trigger": "copyWithZone) \t func Generator -> AnyObject" , "contents": "copyWithZone(${1:NSZone}))" },{ "trigger": "NSURLErrorCannotDecodeRawData \t Int", "contents": "NSURLErrorCannotDecodeRawData" },{ "trigger": "response \t NSURLResponse", "contents": "response" },{ "trigger": "NSPersonNameComponentsFormatterOptions) \t rawValue:" , "contents": "NSPersonNameComponentsFormatterOptions(${1:UInt}))" },{ "trigger": "scanDecimal) \t func NSScanner -> Bool" , "contents": "scanDecimal(${1:UnsafeMutablePointerNSDecimal}))" },{ "trigger": "postNotificationName) \t func NSNotificationCenter -> void" , "contents": "postNotificationName(${1:String}), object:${2:AnyObject?}))" },{ "trigger": "NSStreamSOCKSProxyPortKey \t String", "contents": "NSStreamSOCKSProxyPortKey" },{ "trigger": "URLForAuxiliaryExecutable) \t func NSBundle -> NSURL?" , "contents": "URLForAuxiliaryExecutable(${1:String}))" },{ "trigger": "removeChildAtIndex) \t func NSXMLDocument -> void" , "contents": "removeChildAtIndex(${1:Int}))" },{ "trigger": "NSURLQueryItem \t NSURLQueryItem", "contents": "NSURLQueryItem" },{ "trigger": "NSXMLNodePreserveEntities \t NSXMLNodeOptionRawType", "contents": "NSXMLNodePreserveEntities" },{ "trigger": "NSURLErrorServerCertificateHasUnknownRoot \t Int", "contents": "NSURLErrorServerCertificateHasUnknownRoot" },{ "trigger": "NSOperationQueuePriority \t NSOperationQueuePriority", "contents": "NSOperationQueuePriority" },{ "trigger": "setCookie) \t func NSHTTPCookieStorage -> void" , "contents": "setCookie(${1:NSHTTPCookie}))" },{ "trigger": "minimumRangeOfUnit) \t func NSCalendar -> NSRange" , "contents": "minimumRangeOfUnit(${1:NSCalendarUnit}))" },{ "trigger": "daylightSavingTime \t Bool", "contents": "daylightSavingTime" },{ "trigger": "NSDecimalNormalize) \t func unknown -> NSCalculationError" , "contents": "NSDecimalNormalize(${1:UnsafeMutablePointerNSDecimal}), _:${2:UnsafeMutablePointerNSDecimal}), _:${3:NSRoundingMode}))" },{ "trigger": "_conditionallyBridgeFromObject) \t static Array -> Bool" , "contents": "_conditionallyBridgeFromObject(${1:NSArray}), inout:${2:Array?}))" },{ "trigger": "enumeratorAtURL) \t func NSFileManager -> Bool)?)" , "contents": "enumeratorAtURL(${1:NSURL}), includingPropertiesForKeys:${2:[String]?}), options:${3:NSDirectoryEnumerationOptions}), errorHandler:${4:NSURL}), NSError:${5:}))" },{ "trigger": "NSCalendarIdentifierIslamicTabular \t String", "contents": "NSCalendarIdentifierIslamicTabular" },{ "trigger": "NSKeyedUnarchiver \t NSKeyedUnarchiver", "contents": "NSKeyedUnarchiver" },{ "trigger": "setObject) \t func NSMutableDictionary -> void" , "contents": "setObject(${1:AnyObject}), forKey:${2:NSObject}))" },{ "trigger": "supportsSecureCoding) \t static NSSet -> Bool" , "contents": "supportsSecureCoding(${1:}))" },{ "trigger": "keyEnumerator) \t func Generator -> NSEnumerator" , "contents": "keyEnumerator(${1:}))" },{ "trigger": "isEqualToArray) \t func Generator -> Bool" , "contents": "isEqualToArray(${1:[AnyObject]}))" },{ "trigger": "NSRegularExpressionOptions \t NSRegularExpressionOptions", "contents": "NSRegularExpressionOptions" },{ "trigger": "supportsSecureCoding) \t func NSDateComponents -> Bool" , "contents": "supportsSecureCoding(${1:}))" },{ "trigger": "shouldReportNamespacePrefixes \t Bool", "contents": "shouldReportNamespacePrefixes" },{ "trigger": "NSPredicate) \t coder:" , "contents": "NSPredicate(coder:${1:NSCoder}))" },{ "trigger": "addEntriesFromDictionary) \t func NSMutableDictionary -> void" , "contents": "addEntriesFromDictionary(${1:[NSObject }))" },{ "trigger": "NSCountedSet) \t capacity:" , "contents": "NSCountedSet(capacity:${1:Int}))" },{ "trigger": "indexesOfObjectsWithOptions) \t func Generator -> Bool)" , "contents": "indexesOfObjectsWithOptions(${1:NSEnumerationOptions}), passingTest:${2:AnyObject}), Int:${3:}), UnsafeMutablePointerObjCBool:${4:}))" },{ "trigger": "substringFromIndex) \t func NSString -> String" , "contents": "substringFromIndex(${1:Int}))" },{ "trigger": "NSNumber) \t long:" , "contents": "NSNumber(long:${1:Int}))" },{ "trigger": "proxyType \t String", "contents": "proxyType" },{ "trigger": "insertAttributedString) \t func NSMutableAttributedString -> void" , "contents": "insertAttributedString(${1:NSAttributedString}), atIndex:${2:Int}))" },{ "trigger": "generate) \t func NSDictionary -> Generator" , "contents": "generate(${1:}))" },{ "trigger": "dateWithEra) \t func NSCalendar -> NSDate?" , "contents": "dateWithEra(${1:Int}), year:${2:Int}), month:${3:Int}), day:${4:Int}), hour:${5:Int}), minute:${6:Int}), second:${7:Int}), nanosecond:${8:Int}))" },{ "trigger": "NSURLProtocol \t NSURLProtocol", "contents": "NSURLProtocol" },{ "trigger": "NSDictionary \t NSDictionary", "contents": "NSDictionary" },{ "trigger": "unlock) \t func NSConditionLock -> void" , "contents": "unlock(${1:}))" },{ "trigger": "stringFromDate) \t func NSDateFormatter -> String" , "contents": "stringFromDate(${1:NSDate}))" },{ "trigger": "stringByRemovingPercentEncoding \t String", "contents": "stringByRemovingPercentEncoding" },{ "trigger": "finishTasksAndInvalidate) \t func NSURLSession -> void" , "contents": "finishTasksAndInvalidate(${1:}))" },{ "trigger": "floatValue \t Float", "contents": "floatValue" },{ "trigger": "NSRangeFromString) \t func unknown -> NSRange" , "contents": "NSRangeFromString(${1:String}))" },{ "trigger": "floatForKey) \t func NSUserDefaults -> Float" , "contents": "floatForKey(${1:String}))" },{ "trigger": "_bridgeToObject) \t func Double -> NSNumber" , "contents": "_bridgeToObject(${1:}))" },{ "trigger": "filePathURL \t NSURL", "contents": "filePathURL" },{ "trigger": "NSCalendarUnit) \t rawValue:" , "contents": "NSCalendarUnit(${1:UInt}))" },{ "trigger": "NSXMLElement) \t name: URI:" , "contents": "NSXMLElement(${1:String}), URI:${2:String?}))" },{ "trigger": "NSHost) \t address:" , "contents": "NSHost(${1:String}))" },{ "trigger": "+) \t func unknown -> CGFloat" , "contents": "+(${1:CGFloat}), rhs:${2:CGFloat}))" },{ "trigger": "operand \t NSExpression", "contents": "operand" },{ "trigger": "supportsSecureCoding) \t static NSData -> Bool" , "contents": "supportsSecureCoding(${1:}))" },{ "trigger": "NSURLProtectionSpace) \t host: port: `protocol`: realm: authenticationMethod:" , "contents": "NSURLProtectionSpace(${1:String}), port:${2:Int}), `protocol`:${3:String?}), realm:${4:String?}), authenticationMethod:${5:String?}))" },{ "trigger": "NSZeroPoint \t NSPoint", "contents": "NSZeroPoint" },{ "trigger": "NSEdgeInsetsEqual) \t func unknown -> Bool" , "contents": "NSEdgeInsetsEqual(${1:NSEdgeInsets}), _:${2:NSEdgeInsets}))" },{ "trigger": "getParagraphStart) \t func NSString -> void" , "contents": "getParagraphStart(${1:UnsafeMutablePointerInt}), end:${2:UnsafeMutablePointerInt}), contentsEnd:${3:UnsafeMutablePointerInt}), forRange:${4:NSRange}))" },{ "trigger": "fileSystemRepresentationWithPath) \t func NSFileManager -> UnsafePointer Int8 " , "contents": "fileSystemRepresentationWithPath(${1:String}))" },{ "trigger": "localeIdentifierFromWindowsLocaleCode) \t class NSLocale -> String?" , "contents": "localeIdentifierFromWindowsLocaleCode(${1:UInt32}))" },{ "trigger": "NSCalendar) \t calendarIdentifier:" , "contents": "NSCalendar(calendarIdentifier:${1:String}))" },{ "trigger": "escapedPatternForString) \t class NSRegularExpression -> String" , "contents": "escapedPatternForString(${1:String}))" },{ "trigger": "preflight) \t func NSBundle -> void" , "contents": "preflight(${1:}))" },{ "trigger": "NSMutableSet \t NSMutableSet", "contents": "NSMutableSet" },{ "trigger": "NSSortDescriptor) \t coder:" , "contents": "NSSortDescriptor(coder:${1:NSCoder}))" },{ "trigger": "_forceBridgeFromObject) \t static Int -> void" , "contents": "_forceBridgeFromObject(${1:NSNumber}), inout:${2:Int?}))" },{ "trigger": "encodeWithCoder) \t func NSRegularExpression -> void" , "contents": "encodeWithCoder(${1:NSCoder}))" },{ "trigger": "receivesCredentialSecurely \t Bool", "contents": "receivesCredentialSecurely" },{ "trigger": "removeObjectAtIndex) \t func NSMutableArray -> void" , "contents": "removeObjectAtIndex(${1:Int}))" },{ "trigger": "objectForKey) \t func NSCache -> AnyObject?" , "contents": "objectForKey(${1:AnyObject}))" },{ "trigger": "removeObjectsInArray) \t func NSMutableArray -> void" , "contents": "removeObjectsInArray(${1:[AnyObject]}))" },{ "trigger": "rectValue \t NSRect", "contents": "rectValue" },{ "trigger": "NSIndexSet) \t :" , "contents": "NSIndexSet(${1:}))" },{ "trigger": "enqueueNotification) \t func NSNotificationQueue -> void" , "contents": "enqueueNotification(${1:NSNotification}), postingStyle:${2:NSPostingStyle}), coalesceMask:${3:NSNotificationCoalescing}), forModes:${4:[String]?}))" },{ "trigger": "unsignedIntegerValue \t UInt", "contents": "unsignedIntegerValue" },{ "trigger": "password \t String", "contents": "password" },{ "trigger": "cancelByProducingResumeData) \t func NSURLSessionDownloadTask -> Void)" , "contents": "cancelByProducingResumeData(${1:NSData? - Void}))" },{ "trigger": "NSInputStream) \t fileAtPath:" , "contents": "NSInputStream(fileAtPath:${1:String}))" },{ "trigger": "NSNumber) \t unsignedLongLong:" , "contents": "NSNumber(unsignedLongLong:${1:UInt64}))" },{ "trigger": "NSURLCredential) \t user: password: persistence:" , "contents": "NSURLCredential(${1:String}), password:${2:String}), persistence:${3:NSURLCredentialPersistence}))" },{ "trigger": "NSUserDefaults \t NSUserDefaults", "contents": "NSUserDefaults" },{ "trigger": "standalone \t Bool", "contents": "standalone" },{ "trigger": "NSMutableArray) \t coder:" , "contents": "NSMutableArray(${1:NSCoder}))" },{ "trigger": "isMultiThreaded) \t class NSThread -> Bool" , "contents": "isMultiThreaded(${1:}))" },{ "trigger": "NSXMLDocumentXInclude \t NSXMLNodeOptionRawType", "contents": "NSXMLDocumentXInclude" },{ "trigger": "NSDecimal) \t :" , "contents": "NSDecimal(${1:}))" },{ "trigger": "NSError) \t coder:" , "contents": "NSError(coder:${1:NSCoder}))" },{ "trigger": "encodePoint) \t func NSCoder -> void" , "contents": "encodePoint(${1:NSPoint}))" },{ "trigger": "setObject) \t func NSUserDefaults -> void" , "contents": "setObject(${1:AnyObject?}), forKey:${2:String}))" },{ "trigger": "propertyForKey) \t func NSStream -> AnyObject?" , "contents": "propertyForKey(${1:String}))" },{ "trigger": "level \t Int", "contents": "level" },{ "trigger": "localizedLowercaseString \t String", "contents": "localizedLowercaseString" },{ "trigger": "dateBySettingUnit) \t func NSCalendar -> NSDate?" , "contents": "dateBySettingUnit(${1:NSCalendarUnit}), value:${2:Int}), ofDate:${3:NSDate}), options:${4:NSCalendarOptions}))" },{ "trigger": "allowsFractionalUnits \t Bool", "contents": "allowsFractionalUnits" },{ "trigger": "NSMutableDictionary) \t objects: forKeys: count:" , "contents": "NSMutableDictionary(${1:UnsafePointerAnyObject}), forKeys:${2:UnsafePointerNSObject}), count:${3:Int}))" },{ "trigger": "classNameForClass) \t class NSKeyedArchiver -> String?" , "contents": "classNameForClass(${1:AnyClass}))" },{ "trigger": "encodePoint) \t func NSCoder -> void" , "contents": "encodePoint(${1:NSPoint}), forKey:${2:String}))" },{ "trigger": "addDependency) \t func NSOperation -> void" , "contents": "addDependency(${1:NSOperation}))" },{ "trigger": "uppercaseStringWithLocale) \t func NSString -> String" , "contents": "uppercaseStringWithLocale(${1:NSLocale?}))" },{ "trigger": "_forceBridgeFromObject) \t static Double -> void" , "contents": "_forceBridgeFromObject(${1:NSNumber}), inout:${2:Double?}))" },{ "trigger": "copyWithZone) \t func NSOrderedSet -> AnyObject" , "contents": "copyWithZone(${1:NSZone}))" },{ "trigger": "NSFileHandleNotificationDataItem \t String", "contents": "NSFileHandleNotificationDataItem" },{ "trigger": "attributedSubstringFromRange) \t func NSAttributedString -> NSAttributedString" , "contents": "attributedSubstringFromRange(${1:NSRange}))" },{ "trigger": "rangeOfFirstMatchInString) \t func NSRegularExpression -> NSRange" , "contents": "rangeOfFirstMatchInString(${1:String}), options:${2:NSMatchingOptions}), range:${3:NSRange}))" },{ "trigger": "NSLocaleGroupingSeparator \t String", "contents": "NSLocaleGroupingSeparator" },{ "trigger": "filteredSetUsingPredicate) \t func NSSet -> Set NSObject " , "contents": "filteredSetUsingPredicate(${1:NSPredicate}))" },{ "trigger": "limitDateForMode) \t func NSRunLoop -> NSDate?" , "contents": "limitDateForMode(${1:String}))" },{ "trigger": "nextDateAfterDate) \t func NSCalendar -> NSDate?" , "contents": "nextDateAfterDate(${1:NSDate}), matchingComponents:${2:NSDateComponents}), options:${3:NSCalendarOptions}))" },{ "trigger": "suspend) \t func NSTask -> Bool" , "contents": "suspend(${1:}))" },{ "trigger": "encodeWithCoder) \t func NSTextCheckingResult -> void" , "contents": "encodeWithCoder(${1:NSCoder}))" },{ "trigger": "decomposableCharacterSet) \t class NSCharacterSet -> NSCharacterSet" , "contents": "decomposableCharacterSet(${1:}))" },{ "trigger": "generate) \t func NSSet -> Generator" , "contents": "generate(${1:}))" },{ "trigger": "NSURLErrorCannotCreateFile \t Int", "contents": "NSURLErrorCannotCreateFile" },{ "trigger": "NSNull) \t coder:" , "contents": "NSNull(coder:${1:NSCoder}))" },{ "trigger": "registerDefaults) \t func NSUserDefaults -> void" , "contents": "registerDefaults(${1:[String }))" },{ "trigger": "encodeWithCoder) \t func NSSet -> void" , "contents": "encodeWithCoder(${1:NSCoder}))" },{ "trigger": "commonISOCurrencyCodes) \t class NSLocale -> [String]" , "contents": "commonISOCurrencyCodes(${1:}))" },{ "trigger": "NSMutableSet) \t objects: count:" , "contents": "NSMutableSet(${1:UnsafePointerAnyObject?}), count:${2:Int}))" },{ "trigger": "unlock) \t func NSCondition -> void" , "contents": "unlock(${1:}))" },{ "trigger": "unsignedShortValue \t UInt", "contents": "unsignedShortValue" },{ "trigger": "positiveSuffix \t String", "contents": "positiveSuffix" },{ "trigger": "NSCoder \t NSCoder", "contents": "NSCoder" },{ "trigger": "_forceBridgeFromObject) \t static UInt -> void" , "contents": "_forceBridgeFromObject(${1:NSNumber}), inout:${2:UInt?}))" },{ "trigger": "waitUntilFinished) \t func NSOperation -> void" , "contents": "waitUntilFinished(${1:}))" },{ "trigger": "indexOfObjectIdenticalTo) \t func Generator -> Int" , "contents": "indexOfObjectIdenticalTo(${1:AnyObject}))" },{ "trigger": "NSURLErrorFileIsDirectory \t Int", "contents": "NSURLErrorFileIsDirectory" },{ "trigger": "NSProgress) \t totalUnitCount: parent: pendingUnitCount:" , "contents": "NSProgress(totalUnitCount:${1:Int64}), parent:${2:NSProgress}), pendingUnitCount:${3:Int64}))" },{ "trigger": "streamTaskWithHostName) \t func NSURLSession -> NSURLSessionStreamTask" , "contents": "streamTaskWithHostName(${1:String}), port:${2:Int}))" },{ "trigger": "CGFloat) \t _:" , "contents": "CGFloat(_:${1:Float}))" },{ "trigger": "NSURLCredentialPersistence \t NSURLCredentialPersistence", "contents": "NSURLCredentialPersistence" },{ "trigger": "timeIntervalSinceReferenceDate \t NSTimeInterval", "contents": "timeIntervalSinceReferenceDate" },{ "trigger": "removeLastObject) \t func NSMutableArray -> void" , "contents": "removeLastObject(${1:}))" },{ "trigger": "base64EncodedStringWithOptions) \t func NSData -> String" , "contents": "base64EncodedStringWithOptions(${1:NSDataBase64EncodingOptions}))" },{ "trigger": "stringFromNumber) \t func NSNumberFormatter -> String?" , "contents": "stringFromNumber(${1:NSNumber}))" },{ "trigger": "totalUnitCount \t Int", "contents": "totalUnitCount" },{ "trigger": "timeZoneDataVersion) \t class NSTimeZone -> String" , "contents": "timeZoneDataVersion(${1:}))" },{ "trigger": "keysOfEntriesWithOptions) \t func Generator -> Bool)" , "contents": "keysOfEntriesWithOptions(${1:NSEnumerationOptions}), passingTest:${2:AnyObject}), AnyObject:${3:}), UnsafeMutablePointerObjCBool:${4:}))" },{ "trigger": "NSNumber) \t unsignedShort:" , "contents": "NSNumber(unsignedShort:${1:UInt16}))" },{ "trigger": "NSStringEnumerationOptions \t NSStringEnumerationOptions", "contents": "NSStringEnumerationOptions" },{ "trigger": "NSMassFormatterUnit \t NSMassFormatterUnit", "contents": "NSMassFormatterUnit" },{ "trigger": "NSXMLDocumentTidyHTML \t NSXMLNodeOptionRawType", "contents": "NSXMLDocumentTidyHTML" },{ "trigger": "NSOrderedSet) \t array:" , "contents": "NSOrderedSet(${1:[AnyObject]}))" },{ "trigger": "CGRect \t CGRect", "contents": "CGRect" },{ "trigger": "NSOrderedSet) \t object:" , "contents": "NSOrderedSet(${1:AnyObject}))" },{ "trigger": "right \t CGFloat", "contents": "right" },{ "trigger": "NSNEXTSTEPStringEncoding \t UInt", "contents": "NSNEXTSTEPStringEncoding" },{ "trigger": "encodeWithCoder) \t func NSNotification -> void" , "contents": "encodeWithCoder(${1:NSCoder}))" },{ "trigger": "year \t Int", "contents": "year" },{ "trigger": "decimalNumberBySubtracting) \t func NSDecimalNumber -> NSDecimalNumber" , "contents": "decimalNumberBySubtracting(${1:NSDecimalNumber}))" },{ "trigger": "tryLock) \t func NSRecursiveLock -> Bool" , "contents": "tryLock(${1:}))" },{ "trigger": "maximumUnitCount \t Int", "contents": "maximumUnitCount" },{ "trigger": "isReadableFileAtPath) \t func NSFileManager -> Bool" , "contents": "isReadableFileAtPath(${1:String}))" },{ "trigger": "encodeWithCoder) \t func NSDecimalNumberHandler -> void" , "contents": "encodeWithCoder(${1:NSCoder}))" },{ "trigger": "height \t CGFloat", "contents": "height" },{ "trigger": "NSMutableIndexSet \t NSMutableIndexSet", "contents": "NSMutableIndexSet" },{ "trigger": "NSDecimalDivide) \t func unknown -> NSCalculationError" , "contents": "NSDecimalDivide(${1:UnsafeMutablePointerNSDecimal}), _:${2:UnsafePointerNSDecimal}), _:${3:UnsafePointerNSDecimal}), _:${4:NSRoundingMode}))" },{ "trigger": "task \t NSURLSessionTask", "contents": "task" },{ "trigger": "indexOfObject) \t func Generator -> Int" , "contents": "indexOfObject(${1:AnyObject}), inSortedRange:${2:NSRange}), options:${3:NSBinarySearchingOptions}), usingComparator:${4:NSComparator}))" },{ "trigger": "threadPriority \t Double", "contents": "threadPriority" },{ "trigger": "notANumberSymbol \t String", "contents": "notANumberSymbol" },{ "trigger": "NSDecimalMaxSize \t Int", "contents": "NSDecimalMaxSize" },{ "trigger": "sendBeforeDate) \t func NSPort -> Bool" , "contents": "sendBeforeDate(${1:NSDate}), components:${2:NSMutableArray?}), from:${3:NSPort?}), reserved:${4:Int}))" },{ "trigger": "NSURLAuthenticationMethodHTTPDigest \t String", "contents": "NSURLAuthenticationMethodHTTPDigest" },{ "trigger": "NSPort) \t :" , "contents": "NSPort(${1:}))" },{ "trigger": "yearForWeekOfYear \t Int", "contents": "yearForWeekOfYear" },{ "trigger": "sharedCookieStorageForGroupContainerIdentifier) \t class NSHTTPCookieStorage -> NSHTTPCookieStorage" , "contents": "sharedCookieStorageForGroupContainerIdentifier(${1:String}))" },{ "trigger": "proposedCredential \t NSURLCredential", "contents": "proposedCredential" },{ "trigger": "objectAtIndex) \t func NSOrderedSet -> AnyObject" , "contents": "objectAtIndex(${1:Int}))" },{ "trigger": "NSURLRequest \t NSURLRequest", "contents": "NSURLRequest" },{ "trigger": "indexOfObjectWithOptions) \t func NSOrderedSet -> Bool)" , "contents": "indexOfObjectWithOptions(${1:NSEnumerationOptions}), passingTest:${2:AnyObject}), Int:${3:}), UnsafeMutablePointerObjCBool:${4:}))" },{ "trigger": "dateFormatFromTemplate) \t class NSDateFormatter -> String?" , "contents": "dateFormatFromTemplate(${1:String}), options:${2:Int}), locale:${3:NSLocale?}))" },{ "trigger": "NSURLSessionConfiguration \t NSURLSessionConfiguration", "contents": "NSURLSessionConfiguration" },{ "trigger": "components) \t func NSCalendar -> NSDateComponents?" , "contents": "components(${1:NSCalendarUnit}), fromDateComponents:${2:NSDateComponents}), toDateComponents:${3:NSDateComponents}), options:${4:NSCalendarOptions}))" },{ "trigger": "/) \t func unknown -> CGFloat" , "contents": "/(${1:CGFloat}), rhs:${2:CGFloat}))" },{ "trigger": "phoneticRepresentation \t NSPersonNameComponents", "contents": "phoneticRepresentation" },{ "trigger": "NSOrderedSet) \t objects: count:" , "contents": "NSOrderedSet(${1:UnsafePointerAnyObject?}), count:${2:Int}))" },{ "trigger": "longLongValue \t Int", "contents": "longLongValue" },{ "trigger": "NSURLErrorDownloadDecodingFailedMidStream \t Int", "contents": "NSURLErrorDownloadDecodingFailedMidStream" },{ "trigger": "rawValue \t :", "contents": "rawValue" },{ "trigger": "decodeTopLevelObjectOfClasses) \t func NSCoder -> AnyObject?" , "contents": "decodeTopLevelObjectOfClasses(${1:NSSet?}), forKey:${2:String}))" },{ "trigger": "NSNumber) \t float:" , "contents": "NSNumber(float:${1:Float}))" },{ "trigger": "object \t AnyObject", "contents": "object" },{ "trigger": "transformSize) \t func NSAffineTransform -> NSSize" , "contents": "transformSize(${1:NSSize}))" },{ "trigger": "NSFileManagerItemReplacementOptions) \t rawValue:" , "contents": "NSFileManagerItemReplacementOptions(${1:UInt}))" },{ "trigger": "native \t NativeType", "contents": "native" },{ "trigger": "NSFileHandleNotificationFileHandleItem \t String", "contents": "NSFileHandleNotificationFileHandleItem" },{ "trigger": "insertObjects) \t func NSMutableOrderedSet -> void" , "contents": "insertObjects(${1:[AnyObject]}), atIndexes:${2:NSIndexSet}))" },{ "trigger": "NSRegularExpression) \t coder:" , "contents": "NSRegularExpression(coder:${1:NSCoder}))" },{ "trigger": "open) \t func NSStream -> void" , "contents": "open(${1:}))" },{ "trigger": "NSURLErrorResourceUnavailable \t Int", "contents": "NSURLErrorResourceUnavailable" },{ "trigger": "socketType \t Int", "contents": "socketType" },{ "trigger": "lowercaseString \t String", "contents": "lowercaseString" },{ "trigger": "NSAffineTransform) \t transform:" , "contents": "NSAffineTransform(${1:NSAffineTransform}))" },{ "trigger": "closeRead) \t func NSURLSessionStreamTask -> void" , "contents": "closeRead(${1:}))" },{ "trigger": "NSBlockOperation \t NSBlockOperation", "contents": "NSBlockOperation" },{ "trigger": "capitalizedLetterCharacterSet) \t class NSCharacterSet -> NSCharacterSet" , "contents": "capitalizedLetterCharacterSet(${1:}))" },{ "trigger": "removeCredential) \t func NSURLCredentialStorage -> void" , "contents": "removeCredential(${1:NSURLCredential}), forProtectionSpace:${2:NSURLProtectionSpace}))" },{ "trigger": "month \t Int", "contents": "month" },{ "trigger": "decodeObjectOfClasses) \t func NSCoder -> AnyObject?" , "contents": "decodeObjectOfClasses(${1:NSSet?}), forKey:${2:String}))" },{ "trigger": "encodeWithCoder) \t func NSPort -> void" , "contents": "encodeWithCoder(${1:NSCoder}))" },{ "trigger": "nextObject) \t func NSEnumerator -> AnyObject?" , "contents": "nextObject(${1:}))" },{ "trigger": "scanHexInt) \t func NSScanner -> UInt32?" , "contents": "scanHexInt(${1:}))" },{ "trigger": "skipDescendants) \t func NSDirectoryEnumerator -> void" , "contents": "skipDescendants(${1:}))" },{ "trigger": "nextDaylightSavingTimeTransition \t NSDate", "contents": "nextDaylightSavingTimeTransition" },{ "trigger": "scanLongLong) \t func NSScanner -> Int64?" , "contents": "scanLongLong(${1:}))" },{ "trigger": "supportsSecureCoding) \t static NSTimeZone -> Bool" , "contents": "supportsSecureCoding(${1:}))" },{ "trigger": "supportsSecureCoding) \t static NSError -> Bool" , "contents": "supportsSecureCoding(${1:}))" },{ "trigger": "delegate \t NSURLSessionDelegate", "contents": "delegate" },{ "trigger": "insertString) \t func NSMutableString -> void" , "contents": "insertString(${1:String}), atIndex:${2:Int}))" },{ "trigger": "generatesCalendarDates \t Bool", "contents": "generatesCalendarDates" },{ "trigger": "NSXMLDocumentIncludeContentTypeDeclaration \t NSXMLNodeOptionRawType", "contents": "NSXMLDocumentIncludeContentTypeDeclaration" },{ "trigger": "NSPipe) \t :" , "contents": "NSPipe(${1:}))" },{ "trigger": "NSEnumerationOptions) \t rawValue:" , "contents": "NSEnumerationOptions(${1:UInt}))" },{ "trigger": "privateFrameworksPath \t String", "contents": "privateFrameworksPath" },{ "trigger": "tY \t CGFloat", "contents": "tY" },{ "trigger": "NSString) \t format: arguments:" , "contents": "NSString(${1:String}), arguments:${2:CVaListPointer}))" },{ "trigger": "startOfDayForDate) \t func NSCalendar -> NSDate" , "contents": "startOfDayForDate(${1:NSDate}))" },{ "trigger": "removeCookiesSinceDate) \t func NSHTTPCookieStorage -> void" , "contents": "removeCookiesSinceDate(${1:NSDate}))" },{ "trigger": "path \t String", "contents": "path" },{ "trigger": "indexPassingTest) \t func NSIndexSet -> Bool)" , "contents": "indexPassingTest(${1:Int}), UnsafeMutablePointerObjCBool:${2:}))" },{ "trigger": "NSJSONSerialization \t NSJSONSerialization", "contents": "NSJSONSerialization" },{ "trigger": "arrayByAddingObject) \t func Generator -> [AnyObject]" , "contents": "arrayByAddingObject(${1:AnyObject}))" },{ "trigger": "adaptive \t Bool", "contents": "adaptive" },{ "trigger": "supportsSecureCoding) \t static NSURLProtectionSpace -> Bool" , "contents": "supportsSecureCoding(${1:}))" },{ "trigger": "appendTransform) \t func NSAffineTransform -> void" , "contents": "appendTransform(${1:NSAffineTransform}))" },{ "trigger": "removeObjectIdenticalTo) \t func NSMutableArray -> void" , "contents": "removeObjectIdenticalTo(${1:AnyObject}), inRange:${2:NSRange}))" },{ "trigger": "NSInputStream \t NSInputStream", "contents": "NSInputStream" },{ "trigger": "NSURL \t NSURL", "contents": "NSURL" },{ "trigger": "weekOfYear \t Int", "contents": "weekOfYear" },{ "trigger": "setObject) \t func NSCache -> void" , "contents": "setObject(${1:AnyObject}), forKey:${2:AnyObject}))" },{ "trigger": "NSFileTypeDirectory \t String", "contents": "NSFileTypeDirectory" },{ "trigger": "dequeueNotificationsMatching) \t func NSNotificationQueue -> void" , "contents": "dequeueNotificationsMatching(${1:NSNotification}), coalesceMask:${2:Int}))" },{ "trigger": "createDirectoryAtPath) \t func NSFileManager -> void" , "contents": "createDirectoryAtPath(${1:String}), withIntermediateDirectories:${2:Bool}), attributes:${3:[String }))" },{ "trigger": "allowEvaluation) \t func NSSortDescriptor -> void" , "contents": "allowEvaluation(${1:}))" },{ "trigger": "objectForInfoDictionaryKey) \t func NSBundle -> AnyObject?" , "contents": "objectForInfoDictionaryKey(${1:String}))" },{ "trigger": "decimalNumberByMultiplyingByPowerOf10) \t func NSDecimalNumber -> NSDecimalNumber" , "contents": "decimalNumberByMultiplyingByPowerOf10(${1:Int16}))" },{ "trigger": "decodeObjectOfClassDecodedObjectType) \t func NSCoder -> DecodedObjectType?" , "contents": "decodeObjectOfClassDecodedObjectType(${1:DecodedObjectType.Type}), forKey:${2:String}))" },{ "trigger": "NSXMLNodeIsCDATA \t NSXMLNodeOptionRawType", "contents": "NSXMLNodeIsCDATA" },{ "trigger": "NSMakeSize) \t func unknown -> NSSize" , "contents": "NSMakeSize(${1:CGFloat}), _:${2:CGFloat}))" },{ "trigger": "isEqualToString) \t func NSString -> Bool" , "contents": "isEqualToString(${1:String}))" },{ "trigger": "objectsForXQuery) \t func NSXMLNode -> [AnyObject]" , "contents": "objectsForXQuery(${1:String}), constants:${2:[String }))" },{ "trigger": "NSStringEncodingErrorKey \t String", "contents": "NSStringEncodingErrorKey" },{ "trigger": "classForClassName) \t class NSKeyedUnarchiver -> AnyClass?" , "contents": "classForClassName(${1:String}))" },{ "trigger": "rawValue \t Int", "contents": "rawValue" },{ "trigger": "NSArgumentDomain \t String", "contents": "NSArgumentDomain" },{ "trigger": "persistence \t NSURLCredentialPersistence", "contents": "persistence" },{ "trigger": "NSCompoundPredicate \t NSCompoundPredicate", "contents": "NSCompoundPredicate" },{ "trigger": "stringFromDate) \t func NSDateComponentsFormatter -> String?" , "contents": "stringFromDate(${1:NSDate}), toDate:${2:NSDate}))" },{ "trigger": "seekToEndOfFile) \t func NSFileHandle -> UInt64" , "contents": "seekToEndOfFile(${1:}))" },{ "trigger": "NSNumber) \t unsignedChar:" , "contents": "NSNumber(unsignedChar:${1:UInt8}))" },{ "trigger": "NSPredicate \t NSPredicate", "contents": "NSPredicate" },{ "trigger": "encodeSize) \t func NSCoder -> void" , "contents": "encodeSize(${1:NSSize}), forKey:${2:String}))" },{ "trigger": "addAttributes) \t func NSMutableAttributedString -> void" , "contents": "addAttributes(${1:[String }), range:${2:NSRange}))" },{ "trigger": "NSEnergyFormatter \t NSEnergyFormatter", "contents": "NSEnergyFormatter" },{ "trigger": "waitUntilAllOperationsAreFinished) \t func NSOperationQueue -> void" , "contents": "waitUntilAllOperationsAreFinished(${1:}))" },{ "trigger": "scanString) \t func NSScanner -> String?" , "contents": "scanString(string:${1:String}))" },{ "trigger": "NSCalendarIdentifierIslamic \t String", "contents": "NSCalendarIdentifierIslamic" },{ "trigger": "decodeIntForKey) \t func NSCoder -> Int32" , "contents": "decodeIntForKey(${1:String}))" },{ "trigger": "getHour) \t func NSCalendar -> void" , "contents": "getHour(${1:UnsafeMutablePointerInt}), minute:${2:UnsafeMutablePointerInt}), second:${3:UnsafeMutablePointerInt}), nanosecond:${4:UnsafeMutablePointerInt}), fromDate:${5:NSDate}))" },{ "trigger": "NSSet \t NSSet", "contents": "NSSet" },{ "trigger": "NSCompoundPredicate) \t coder:" , "contents": "NSCompoundPredicate(${1:NSCoder}))" },{ "trigger": "resetSystemTimeZone) \t class NSTimeZone -> void" , "contents": "resetSystemTimeZone(${1:}))" },{ "trigger": "addOperations) \t func NSOperationQueue -> void" , "contents": "addOperations(${1:[NSOperation]}), waitUntilFinished:${2:Bool}))" },{ "trigger": "userInfoValueProviderForDomain) \t class NSError -> ((NSError," , "contents": "userInfoValueProviderForDomain(${1:String - NSError}), String:${2:}))" },{ "trigger": "generate) \t func NSArray -> Generator" , "contents": "generate(${1:}))" },{ "trigger": "indexesOfObjectsPassingTest) \t func Generator -> Bool)" , "contents": "indexesOfObjectsPassingTest(${1:AnyObject}), Int:${2:}), UnsafeMutablePointerObjCBool:${3:}))" },{ "trigger": "NSComparisonPredicate) \t leftExpression: rightExpression: modifier: type: options:" , "contents": "NSComparisonPredicate(leftExpression:${1:NSExpression}), rightExpression:${2:NSExpression}), modifier:${3:NSComparisonPredicateModifier}), type:${4:NSPredicateOperatorType}), options:${5:NSComparisonPredicateOptions}))" },{ "trigger": "NSFileTypeRegular \t String", "contents": "NSFileTypeRegular" },{ "trigger": "_bridgeToObject) \t func Float -> NSNumber" , "contents": "_bridgeToObject(${1:}))" },{ "trigger": "isDate) \t func NSCalendar -> Bool" , "contents": "isDate(${1:NSDate}), equalToDate:${2:NSDate}), toUnitGranularity:${3:NSCalendarUnit}))" },{ "trigger": "_forceBridgeFromObject) \t static Array -> void" , "contents": "_forceBridgeFromObject(${1:NSArray}), inout:${2:Array?}))" },{ "trigger": "mutableString \t NSMutableString", "contents": "mutableString" },{ "trigger": "NSDataSearchOptions \t NSDataSearchOptions", "contents": "NSDataSearchOptions" },{ "trigger": "_bridgeToObject) \t func Dictionary -> NSDictionary" , "contents": "_bridgeToObject(${1:}))" },{ "trigger": "NSSortOptions) \t rawValue:" , "contents": "NSSortOptions(${1:UInt}))" },{ "trigger": "scanHexDouble) \t func NSScanner -> Double?" , "contents": "scanHexDouble(${1:}))" },{ "trigger": "read) \t func NSInputStream -> Int" , "contents": "read(${1:UnsafeMutablePointerUInt8}), maxLength:${2:Int}))" },{ "trigger": "builtInPlugInsURL \t NSURL", "contents": "builtInPlugInsURL" },{ "trigger": "NSKeyedArchiver) \t forWritingWithMutableData:" , "contents": "NSKeyedArchiver(forWritingWithMutableData:${1:NSMutableData}))" },{ "trigger": "NSByteCountFormatterUnits) \t rawValue:" , "contents": "NSByteCountFormatterUnits(${1:UInt}))" },{ "trigger": "NSASCIIStringEncoding \t UInt", "contents": "NSASCIIStringEncoding" },{ "trigger": "rangeOfScheme \t NSRange", "contents": "rangeOfScheme" },{ "trigger": "allowedUnits \t NSByteCountFormatterUnits", "contents": "allowedUnits" },{ "trigger": "NSFileSystemFileNumber \t String", "contents": "NSFileSystemFileNumber" },{ "trigger": "NSURLErrorClientCertificateRequired \t Int", "contents": "NSURLErrorClientCertificateRequired" },{ "trigger": "stringFromDate) \t func NSDateIntervalFormatter -> String" , "contents": "stringFromDate(${1:NSDate}), toDate:${2:NSDate}))" },{ "trigger": "physicalMemory \t UInt", "contents": "physicalMemory" },{ "trigger": "NSURLErrorBackgroundSessionInUseByAnotherProcess \t Int", "contents": "NSURLErrorBackgroundSessionInUseByAnotherProcess" },{ "trigger": "NSURLSessionTaskPriorityHigh \t Float", "contents": "NSURLSessionTaskPriorityHigh" },{ "trigger": "namespaceWithName) \t class NSXMLNode -> AnyObject" , "contents": "namespaceWithName(${1:String}), stringValue:${2:String}))" }]
 }
